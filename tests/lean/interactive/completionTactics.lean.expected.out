{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 20, "character": 20}}
{"items": [], "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 23, "character": 21}}
{"items":
 [{"sortText": "00",
   "label": "exact",
   "kind": 14,
   "documentation": {"value": "Another docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 23, "character": 21}}}},
  {"sortText": "01",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 23, "character": 21}}}},
  {"sortText": "02",
   "label": "Lean.Parser.Tactic.decideBang",
   "kind": 14,
   "documentation":
   {"value":
    "`decide!` is a variant of the `decide` tactic that uses kernel reduction to prove the goal.\nIt has the following properties:\n- Since it uses kernel reduction instead of elaborator reduction, it ignores transparency and can unfold everything.\n- While `decide` needs to reduce the `Decidable` instance twice (once during elaboration to verify whether the tactic succeeds,\n  and once during kernel type checking), the `decide!` tactic reduces it exactly once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 23, "character": 21}}}},
  {"sortText": "03",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 23, "character": 21}}}},
  {"sortText": "04",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 23, "character": 21}}}},
  {"sortText": "05",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 23, "character": 21}}}},
  {"sortText": "06",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 23, "character": 21}}}},
  {"sortText": "07",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 23, "character": 21}}}},
  {"sortText": "08",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 23, "character": 21}}}},
  {"sortText": "09",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 23, "character": 21}}}},
  {"sortText": "10",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "A docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 23, "character": 21}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 26, "character": 24}}
{"items":
 [{"sortText": "00",
   "label": "exact",
   "kind": 14,
   "documentation": {"value": "Another docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 26, "character": 24}}}},
  {"sortText": "01",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 26, "character": 24}}}},
  {"sortText": "02",
   "label": "Lean.Parser.Tactic.decideBang",
   "kind": 14,
   "documentation":
   {"value":
    "`decide!` is a variant of the `decide` tactic that uses kernel reduction to prove the goal.\nIt has the following properties:\n- Since it uses kernel reduction instead of elaborator reduction, it ignores transparency and can unfold everything.\n- While `decide` needs to reduce the `Decidable` instance twice (once during elaboration to verify whether the tactic succeeds,\n  and once during kernel type checking), the `decide!` tactic reduces it exactly once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 26, "character": 24}}}},
  {"sortText": "03",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 26, "character": 24}}}},
  {"sortText": "04",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 26, "character": 24}}}},
  {"sortText": "05",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 26, "character": 24}}}},
  {"sortText": "06",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 26, "character": 24}}}},
  {"sortText": "07",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 26, "character": 24}}}},
  {"sortText": "08",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 26, "character": 24}}}},
  {"sortText": "09",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 26, "character": 24}}}},
  {"sortText": "10",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "A docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 26, "character": 24}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 29, "character": 25}}
{"items": [], "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 32, "character": 26}}
{"items":
 [{"sortText": "00",
   "label": "exact",
   "kind": 14,
   "documentation": {"value": "Another docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 32, "character": 26}}}},
  {"sortText": "01",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 32, "character": 26}}}},
  {"sortText": "02",
   "label": "Lean.Parser.Tactic.decideBang",
   "kind": 14,
   "documentation":
   {"value":
    "`decide!` is a variant of the `decide` tactic that uses kernel reduction to prove the goal.\nIt has the following properties:\n- Since it uses kernel reduction instead of elaborator reduction, it ignores transparency and can unfold everything.\n- While `decide` needs to reduce the `Decidable` instance twice (once during elaboration to verify whether the tactic succeeds,\n  and once during kernel type checking), the `decide!` tactic reduces it exactly once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 32, "character": 26}}}},
  {"sortText": "03",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 32, "character": 26}}}},
  {"sortText": "04",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 32, "character": 26}}}},
  {"sortText": "05",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 32, "character": 26}}}},
  {"sortText": "06",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 32, "character": 26}}}},
  {"sortText": "07",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 32, "character": 26}}}},
  {"sortText": "08",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 32, "character": 26}}}},
  {"sortText": "09",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 32, "character": 26}}}},
  {"sortText": "10",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "A docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 32, "character": 26}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 35, "character": 27}}
{"items":
 [{"sortText": "00",
   "label": "exact",
   "kind": 14,
   "documentation": {"value": "Another docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 35, "character": 27}}}},
  {"sortText": "01",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 35, "character": 27}}}},
  {"sortText": "02",
   "label": "Lean.Parser.Tactic.decideBang",
   "kind": 14,
   "documentation":
   {"value":
    "`decide!` is a variant of the `decide` tactic that uses kernel reduction to prove the goal.\nIt has the following properties:\n- Since it uses kernel reduction instead of elaborator reduction, it ignores transparency and can unfold everything.\n- While `decide` needs to reduce the `Decidable` instance twice (once during elaboration to verify whether the tactic succeeds,\n  and once during kernel type checking), the `decide!` tactic reduces it exactly once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 35, "character": 27}}}},
  {"sortText": "03",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 35, "character": 27}}}},
  {"sortText": "04",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 35, "character": 27}}}},
  {"sortText": "05",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 35, "character": 27}}}},
  {"sortText": "06",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 35, "character": 27}}}},
  {"sortText": "07",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 35, "character": 27}}}},
  {"sortText": "08",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 35, "character": 27}}}},
  {"sortText": "09",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 35, "character": 27}}}},
  {"sortText": "10",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "A docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 35, "character": 27}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 40, "character": 7}}
{"items":
 [{"sortText": "00",
   "label": "exact",
   "kind": 14,
   "documentation": {"value": "Another docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 40, "character": 7}}}},
  {"sortText": "01",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 40, "character": 7}}}},
  {"sortText": "02",
   "label": "Lean.Parser.Tactic.decideBang",
   "kind": 14,
   "documentation":
   {"value":
    "`decide!` is a variant of the `decide` tactic that uses kernel reduction to prove the goal.\nIt has the following properties:\n- Since it uses kernel reduction instead of elaborator reduction, it ignores transparency and can unfold everything.\n- While `decide` needs to reduce the `Decidable` instance twice (once during elaboration to verify whether the tactic succeeds,\n  and once during kernel type checking), the `decide!` tactic reduces it exactly once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 40, "character": 7}}}},
  {"sortText": "03",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 40, "character": 7}}}},
  {"sortText": "04",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 40, "character": 7}}}},
  {"sortText": "05",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 40, "character": 7}}}},
  {"sortText": "06",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 40, "character": 7}}}},
  {"sortText": "07",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 40, "character": 7}}}},
  {"sortText": "08",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 40, "character": 7}}}},
  {"sortText": "09",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 40, "character": 7}}}},
  {"sortText": "10",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "A docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 40, "character": 7}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 44, "character": 2}}
{"items":
 [{"sortText": "00",
   "label": "exact",
   "kind": 14,
   "documentation": {"value": "Another docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 44, "character": 2}}}},
  {"sortText": "01",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 44, "character": 2}}}},
  {"sortText": "02",
   "label": "Lean.Parser.Tactic.decideBang",
   "kind": 14,
   "documentation":
   {"value":
    "`decide!` is a variant of the `decide` tactic that uses kernel reduction to prove the goal.\nIt has the following properties:\n- Since it uses kernel reduction instead of elaborator reduction, it ignores transparency and can unfold everything.\n- While `decide` needs to reduce the `Decidable` instance twice (once during elaboration to verify whether the tactic succeeds,\n  and once during kernel type checking), the `decide!` tactic reduces it exactly once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 44, "character": 2}}}},
  {"sortText": "03",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 44, "character": 2}}}},
  {"sortText": "04",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 44, "character": 2}}}},
  {"sortText": "05",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 44, "character": 2}}}},
  {"sortText": "06",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 44, "character": 2}}}},
  {"sortText": "07",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 44, "character": 2}}}},
  {"sortText": "08",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 44, "character": 2}}}},
  {"sortText": "09",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 44, "character": 2}}}},
  {"sortText": "10",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "A docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 44, "character": 2}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 49, "character": 2}}
{"items":
 [{"sortText": "00",
   "label": "exact",
   "kind": 14,
   "documentation": {"value": "Another docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 49, "character": 2}}}},
  {"sortText": "01",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 49, "character": 2}}}},
  {"sortText": "02",
   "label": "Lean.Parser.Tactic.decideBang",
   "kind": 14,
   "documentation":
   {"value":
    "`decide!` is a variant of the `decide` tactic that uses kernel reduction to prove the goal.\nIt has the following properties:\n- Since it uses kernel reduction instead of elaborator reduction, it ignores transparency and can unfold everything.\n- While `decide` needs to reduce the `Decidable` instance twice (once during elaboration to verify whether the tactic succeeds,\n  and once during kernel type checking), the `decide!` tactic reduces it exactly once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 49, "character": 2}}}},
  {"sortText": "03",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 49, "character": 2}}}},
  {"sortText": "04",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 49, "character": 2}}}},
  {"sortText": "05",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 49, "character": 2}}}},
  {"sortText": "06",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 49, "character": 2}}}},
  {"sortText": "07",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 49, "character": 2}}}},
  {"sortText": "08",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 49, "character": 2}}}},
  {"sortText": "09",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 49, "character": 2}}}},
  {"sortText": "10",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "A docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 49, "character": 2}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 53, "character": 2}}
{"items":
 [{"sortText": "00",
   "label": "exact",
   "kind": 14,
   "documentation": {"value": "Another docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 53, "character": 2}}}},
  {"sortText": "01",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 53, "character": 2}}}},
  {"sortText": "02",
   "label": "Lean.Parser.Tactic.decideBang",
   "kind": 14,
   "documentation":
   {"value":
    "`decide!` is a variant of the `decide` tactic that uses kernel reduction to prove the goal.\nIt has the following properties:\n- Since it uses kernel reduction instead of elaborator reduction, it ignores transparency and can unfold everything.\n- While `decide` needs to reduce the `Decidable` instance twice (once during elaboration to verify whether the tactic succeeds,\n  and once during kernel type checking), the `decide!` tactic reduces it exactly once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 53, "character": 2}}}},
  {"sortText": "03",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 53, "character": 2}}}},
  {"sortText": "04",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 53, "character": 2}}}},
  {"sortText": "05",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 53, "character": 2}}}},
  {"sortText": "06",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 53, "character": 2}}}},
  {"sortText": "07",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 53, "character": 2}}}},
  {"sortText": "08",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 53, "character": 2}}}},
  {"sortText": "09",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 53, "character": 2}}}},
  {"sortText": "10",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "A docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 53, "character": 2}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 59, "character": 4}}
{"items":
 [{"sortText": "00",
   "label": "exact",
   "kind": 14,
   "documentation": {"value": "Another docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 59, "character": 4}}}},
  {"sortText": "01",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 59, "character": 4}}}},
  {"sortText": "02",
   "label": "Lean.Parser.Tactic.decideBang",
   "kind": 14,
   "documentation":
   {"value":
    "`decide!` is a variant of the `decide` tactic that uses kernel reduction to prove the goal.\nIt has the following properties:\n- Since it uses kernel reduction instead of elaborator reduction, it ignores transparency and can unfold everything.\n- While `decide` needs to reduce the `Decidable` instance twice (once during elaboration to verify whether the tactic succeeds,\n  and once during kernel type checking), the `decide!` tactic reduces it exactly once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 59, "character": 4}}}},
  {"sortText": "03",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 59, "character": 4}}}},
  {"sortText": "04",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 59, "character": 4}}}},
  {"sortText": "05",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 59, "character": 4}}}},
  {"sortText": "06",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 59, "character": 4}}}},
  {"sortText": "07",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 59, "character": 4}}}},
  {"sortText": "08",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 59, "character": 4}}}},
  {"sortText": "09",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 59, "character": 4}}}},
  {"sortText": "10",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "A docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 59, "character": 4}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 64, "character": 2}}
{"items":
 [{"sortText": "00",
   "label": "exact",
   "kind": 14,
   "documentation": {"value": "Another docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 64, "character": 2}}}},
  {"sortText": "01",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 64, "character": 2}}}},
  {"sortText": "02",
   "label": "Lean.Parser.Tactic.decideBang",
   "kind": 14,
   "documentation":
   {"value":
    "`decide!` is a variant of the `decide` tactic that uses kernel reduction to prove the goal.\nIt has the following properties:\n- Since it uses kernel reduction instead of elaborator reduction, it ignores transparency and can unfold everything.\n- While `decide` needs to reduce the `Decidable` instance twice (once during elaboration to verify whether the tactic succeeds,\n  and once during kernel type checking), the `decide!` tactic reduces it exactly once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 64, "character": 2}}}},
  {"sortText": "03",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 64, "character": 2}}}},
  {"sortText": "04",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 64, "character": 2}}}},
  {"sortText": "05",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 64, "character": 2}}}},
  {"sortText": "06",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 64, "character": 2}}}},
  {"sortText": "07",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 64, "character": 2}}}},
  {"sortText": "08",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 64, "character": 2}}}},
  {"sortText": "09",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 64, "character": 2}}}},
  {"sortText": "10",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "A docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 64, "character": 2}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 70, "character": 4}}
{"items":
 [{"sortText": "00",
   "label": "exact",
   "kind": 14,
   "documentation": {"value": "Another docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 70, "character": 4}}}},
  {"sortText": "01",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 70, "character": 4}}}},
  {"sortText": "02",
   "label": "Lean.Parser.Tactic.decideBang",
   "kind": 14,
   "documentation":
   {"value":
    "`decide!` is a variant of the `decide` tactic that uses kernel reduction to prove the goal.\nIt has the following properties:\n- Since it uses kernel reduction instead of elaborator reduction, it ignores transparency and can unfold everything.\n- While `decide` needs to reduce the `Decidable` instance twice (once during elaboration to verify whether the tactic succeeds,\n  and once during kernel type checking), the `decide!` tactic reduces it exactly once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 70, "character": 4}}}},
  {"sortText": "03",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 70, "character": 4}}}},
  {"sortText": "04",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 70, "character": 4}}}},
  {"sortText": "05",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 70, "character": 4}}}},
  {"sortText": "06",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 70, "character": 4}}}},
  {"sortText": "07",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 70, "character": 4}}}},
  {"sortText": "08",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 70, "character": 4}}}},
  {"sortText": "09",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 70, "character": 4}}}},
  {"sortText": "10",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "A docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 70, "character": 4}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 76, "character": 2}}
{"items":
 [{"sortText": "00",
   "label": "exact",
   "kind": 14,
   "documentation": {"value": "Another docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 76, "character": 2}}}},
  {"sortText": "01",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 76, "character": 2}}}},
  {"sortText": "02",
   "label": "Lean.Parser.Tactic.decideBang",
   "kind": 14,
   "documentation":
   {"value":
    "`decide!` is a variant of the `decide` tactic that uses kernel reduction to prove the goal.\nIt has the following properties:\n- Since it uses kernel reduction instead of elaborator reduction, it ignores transparency and can unfold everything.\n- While `decide` needs to reduce the `Decidable` instance twice (once during elaboration to verify whether the tactic succeeds,\n  and once during kernel type checking), the `decide!` tactic reduces it exactly once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 76, "character": 2}}}},
  {"sortText": "03",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 76, "character": 2}}}},
  {"sortText": "04",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 76, "character": 2}}}},
  {"sortText": "05",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 76, "character": 2}}}},
  {"sortText": "06",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 76, "character": 2}}}},
  {"sortText": "07",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 76, "character": 2}}}},
  {"sortText": "08",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 76, "character": 2}}}},
  {"sortText": "09",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 76, "character": 2}}}},
  {"sortText": "10",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "A docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 76, "character": 2}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 81, "character": 4}}
{"items": [], "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 86, "character": 2}}
{"items":
 [{"sortText": "00",
   "label": "exact",
   "kind": 14,
   "documentation": {"value": "Another docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 86, "character": 2}}}},
  {"sortText": "01",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 86, "character": 2}}}},
  {"sortText": "02",
   "label": "Lean.Parser.Tactic.decideBang",
   "kind": 14,
   "documentation":
   {"value":
    "`decide!` is a variant of the `decide` tactic that uses kernel reduction to prove the goal.\nIt has the following properties:\n- Since it uses kernel reduction instead of elaborator reduction, it ignores transparency and can unfold everything.\n- While `decide` needs to reduce the `Decidable` instance twice (once during elaboration to verify whether the tactic succeeds,\n  and once during kernel type checking), the `decide!` tactic reduces it exactly once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 86, "character": 2}}}},
  {"sortText": "03",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 86, "character": 2}}}},
  {"sortText": "04",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 86, "character": 2}}}},
  {"sortText": "05",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 86, "character": 2}}}},
  {"sortText": "06",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 86, "character": 2}}}},
  {"sortText": "07",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 86, "character": 2}}}},
  {"sortText": "08",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 86, "character": 2}}}},
  {"sortText": "09",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 86, "character": 2}}}},
  {"sortText": "10",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "A docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 86, "character": 2}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 91, "character": 4}}
{"items":
 [{"sortText": "00",
   "label": "exact",
   "kind": 14,
   "documentation": {"value": "Another docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 91, "character": 4}}}},
  {"sortText": "01",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 91, "character": 4}}}},
  {"sortText": "02",
   "label": "Lean.Parser.Tactic.decideBang",
   "kind": 14,
   "documentation":
   {"value":
    "`decide!` is a variant of the `decide` tactic that uses kernel reduction to prove the goal.\nIt has the following properties:\n- Since it uses kernel reduction instead of elaborator reduction, it ignores transparency and can unfold everything.\n- While `decide` needs to reduce the `Decidable` instance twice (once during elaboration to verify whether the tactic succeeds,\n  and once during kernel type checking), the `decide!` tactic reduces it exactly once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 91, "character": 4}}}},
  {"sortText": "03",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 91, "character": 4}}}},
  {"sortText": "04",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 91, "character": 4}}}},
  {"sortText": "05",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 91, "character": 4}}}},
  {"sortText": "06",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 91, "character": 4}}}},
  {"sortText": "07",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 91, "character": 4}}}},
  {"sortText": "08",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 91, "character": 4}}}},
  {"sortText": "09",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 91, "character": 4}}}},
  {"sortText": "10",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "A docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 91, "character": 4}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 96, "character": 2}}
{"items":
 [{"sortText": "00",
   "label": "exact",
   "kind": 14,
   "documentation": {"value": "Another docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 96, "character": 2}}}},
  {"sortText": "01",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 96, "character": 2}}}},
  {"sortText": "02",
   "label": "Lean.Parser.Tactic.decideBang",
   "kind": 14,
   "documentation":
   {"value":
    "`decide!` is a variant of the `decide` tactic that uses kernel reduction to prove the goal.\nIt has the following properties:\n- Since it uses kernel reduction instead of elaborator reduction, it ignores transparency and can unfold everything.\n- While `decide` needs to reduce the `Decidable` instance twice (once during elaboration to verify whether the tactic succeeds,\n  and once during kernel type checking), the `decide!` tactic reduces it exactly once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 96, "character": 2}}}},
  {"sortText": "03",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 96, "character": 2}}}},
  {"sortText": "04",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 96, "character": 2}}}},
  {"sortText": "05",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 96, "character": 2}}}},
  {"sortText": "06",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 96, "character": 2}}}},
  {"sortText": "07",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 96, "character": 2}}}},
  {"sortText": "08",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 96, "character": 2}}}},
  {"sortText": "09",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 96, "character": 2}}}},
  {"sortText": "10",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "A docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 96, "character": 2}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 102, "character": 4}}
{"items":
 [{"sortText": "00",
   "label": "exact",
   "kind": 14,
   "documentation": {"value": "Another docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 102, "character": 4}}}},
  {"sortText": "01",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 102, "character": 4}}}},
  {"sortText": "02",
   "label": "Lean.Parser.Tactic.decideBang",
   "kind": 14,
   "documentation":
   {"value":
    "`decide!` is a variant of the `decide` tactic that uses kernel reduction to prove the goal.\nIt has the following properties:\n- Since it uses kernel reduction instead of elaborator reduction, it ignores transparency and can unfold everything.\n- While `decide` needs to reduce the `Decidable` instance twice (once during elaboration to verify whether the tactic succeeds,\n  and once during kernel type checking), the `decide!` tactic reduces it exactly once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 102, "character": 4}}}},
  {"sortText": "03",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 102, "character": 4}}}},
  {"sortText": "04",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 102, "character": 4}}}},
  {"sortText": "05",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 102, "character": 4}}}},
  {"sortText": "06",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 102, "character": 4}}}},
  {"sortText": "07",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 102, "character": 4}}}},
  {"sortText": "08",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 102, "character": 4}}}},
  {"sortText": "09",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 102, "character": 4}}}},
  {"sortText": "10",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "A docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 102, "character": 4}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 108, "character": 2}}
{"items": [], "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 112, "character": 2}}
{"items":
 [{"sortText": "00",
   "label": "exact",
   "kind": 14,
   "documentation": {"value": "Another docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 112, "character": 2}}}},
  {"sortText": "01",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 112, "character": 2}}}},
  {"sortText": "02",
   "label": "Lean.Parser.Tactic.decideBang",
   "kind": 14,
   "documentation":
   {"value":
    "`decide!` is a variant of the `decide` tactic that uses kernel reduction to prove the goal.\nIt has the following properties:\n- Since it uses kernel reduction instead of elaborator reduction, it ignores transparency and can unfold everything.\n- While `decide` needs to reduce the `Decidable` instance twice (once during elaboration to verify whether the tactic succeeds,\n  and once during kernel type checking), the `decide!` tactic reduces it exactly once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 112, "character": 2}}}},
  {"sortText": "03",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 112, "character": 2}}}},
  {"sortText": "04",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 112, "character": 2}}}},
  {"sortText": "05",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 112, "character": 2}}}},
  {"sortText": "06",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 112, "character": 2}}}},
  {"sortText": "07",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 112, "character": 2}}}},
  {"sortText": "08",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 112, "character": 2}}}},
  {"sortText": "09",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 112, "character": 2}}}},
  {"sortText": "10",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "A docstring ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 112, "character": 2}}}}],
 "isIncomplete": true}
