def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) : obj :=
  case x_1 : obj of
  Lean.Compiler.LCNF.Code.let →
    let x_8 : obj := proj[0] x_1;
    inc x_8;
    let x_9 : obj := proj[1] x_1;
    inc x_9;
    inc x_9;
    let x_10 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_9 x_2 x_3 x_4 x_5 x_6 x_7;
    case x_10 : obj of
    EStateM.Result.ok →
      let x_11 : u8 := isShared x_10;
      case x_11 : u8 of
      Bool.false →
        let x_12 : obj := proj[0] x_10;
        let x_13 : usize := ptrAddrUnsafe ◾ x_9;
        dec x_9;
        let x_14 : usize := ptrAddrUnsafe ◾ x_12;
        let x_15 : u8 := USize.decEq x_13 x_14;
        case x_15 : u8 of
        Bool.false →
          let x_16 : u8 := isShared x_1;
          case x_16 : u8 of
          Bool.false →
            let x_17 : obj := proj[1] x_1;
            dec x_17;
            let x_18 : obj := proj[0] x_1;
            dec x_18;
            set x_1[1] := x_12;
            set x_10[0] := x_1;
            ret x_10
          Bool.true →
            dec x_1;
            let x_19 : obj := ctor_0[Lean.Compiler.LCNF.Code.let] x_8 x_12;
            set x_10[0] := x_19;
            ret x_10
        Bool.true →
          let x_20 : usize := ptrAddrUnsafe ◾ x_8;
          let x_21 : u8 := USize.decEq x_20 x_20;
          case x_21 : u8 of
          Bool.false →
            let x_22 : u8 := isShared x_1;
            case x_22 : u8 of
            Bool.false →
              let x_23 : obj := proj[1] x_1;
              dec x_23;
              let x_24 : obj := proj[0] x_1;
              dec x_24;
              set x_1[1] := x_12;
              set x_10[0] := x_1;
              ret x_10
            Bool.true →
              dec x_1;
              let x_25 : obj := ctor_0[Lean.Compiler.LCNF.Code.let] x_8 x_12;
              set x_10[0] := x_25;
              ret x_10
          Bool.true →
            dec x_12;
            dec x_8;
            set x_10[0] := x_1;
            ret x_10
      Bool.true →
        let x_26 : obj := proj[0] x_10;
        let x_27 : obj := proj[1] x_10;
        inc x_27;
        inc x_26;
        dec x_10;
        let x_28 : usize := ptrAddrUnsafe ◾ x_9;
        dec x_9;
        let x_29 : usize := ptrAddrUnsafe ◾ x_26;
        let x_30 : u8 := USize.decEq x_28 x_29;
        case x_30 : u8 of
        Bool.false →
          let x_31 : obj := reset[2] x_1;
          let x_32 : obj := reuse x_31 in ctor_0[Lean.Compiler.LCNF.Code.let] x_8 x_26;
          let x_33 : obj := ctor_0[EStateM.Result.ok] x_32 x_27;
          ret x_33
        Bool.true →
          let x_34 : usize := ptrAddrUnsafe ◾ x_8;
          let x_35 : u8 := USize.decEq x_34 x_34;
          case x_35 : u8 of
          Bool.false →
            let x_36 : obj := reset[2] x_1;
            let x_37 : obj := reuse x_36 in ctor_0[Lean.Compiler.LCNF.Code.let] x_8 x_26;
            let x_38 : obj := ctor_0[EStateM.Result.ok] x_37 x_27;
            ret x_38
          Bool.true →
            dec x_26;
            dec x_8;
            let x_39 : obj := ctor_0[EStateM.Result.ok] x_1 x_27;
            ret x_39
    EStateM.Result.error →
      dec x_9;
      dec x_8;
      dec x_1;
      let x_40 : u8 := isShared x_10;
      case x_40 : u8 of
      Bool.false →
        ret x_10
      Bool.true →
        let x_41 : obj := proj[0] x_10;
        let x_42 : obj := proj[1] x_10;
        inc x_42;
        inc x_41;
        dec x_10;
        let x_43 : obj := ctor_1[EStateM.Result.error] x_41 x_42;
        ret x_43
  Lean.Compiler.LCNF.Code.fun →
    let x_44 : obj := proj[0] x_1;
    inc x_44;
    let x_45 : obj := proj[1] x_1;
    inc x_45;
    let x_46 : obj := proj[4] x_44;
    inc x_46;
    inc x_6;
    inc x_5;
    inc x_4;
    inc x_3;
    inc x_2;
    let x_47 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_46 x_2 x_3 x_4 x_5 x_6 x_7;
    case x_47 : obj of
    EStateM.Result.ok →
      let x_48 : obj := proj[0] x_47;
      inc x_48;
      let x_49 : obj := proj[1] x_47;
      inc x_49;
      dec x_47;
      let x_50 : obj := proj[3] x_44;
      inc x_50;
      let x_51 : obj := proj[2] x_44;
      inc x_51;
      inc x_44;
      let x_52 : obj := _private.Lean.Compiler.LCNF.CompilerM.0.Lean.Compiler.LCNF.updateFunDeclImp x_44 x_50 x_51 x_48 x_3 x_4 x_5 x_6 x_49;
      let x_53 : obj := proj[0] x_52;
      inc x_53;
      let x_54 : obj := proj[1] x_52;
      inc x_54;
      dec x_52;
      inc x_45;
      let x_55 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_45 x_2 x_3 x_4 x_5 x_6 x_54;
      case x_55 : obj of
      EStateM.Result.ok →
        let x_56 : u8 := isShared x_55;
        case x_56 : u8 of
        Bool.false →
          let x_57 : obj := proj[0] x_55;
          let x_58 : usize := ptrAddrUnsafe ◾ x_45;
          dec x_45;
          let x_59 : usize := ptrAddrUnsafe ◾ x_57;
          let x_60 : u8 := USize.decEq x_58 x_59;
          case x_60 : u8 of
          Bool.false →
            dec x_44;
            let x_61 : u8 := isShared x_1;
            case x_61 : u8 of
            Bool.false →
              let x_62 : obj := proj[1] x_1;
              dec x_62;
              let x_63 : obj := proj[0] x_1;
              dec x_63;
              set x_1[1] := x_57;
              set x_1[0] := x_53;
              set x_55[0] := x_1;
              ret x_55
            Bool.true →
              dec x_1;
              let x_64 : obj := ctor_1[Lean.Compiler.LCNF.Code.fun] x_53 x_57;
              set x_55[0] := x_64;
              ret x_55
          Bool.true →
            let x_65 : usize := ptrAddrUnsafe ◾ x_44;
            dec x_44;
            let x_66 : usize := ptrAddrUnsafe ◾ x_53;
            let x_67 : u8 := USize.decEq x_65 x_66;
            case x_67 : u8 of
            Bool.false →
              let x_68 : u8 := isShared x_1;
              case x_68 : u8 of
              Bool.false →
                let x_69 : obj := proj[1] x_1;
                dec x_69;
                let x_70 : obj := proj[0] x_1;
                dec x_70;
                set x_1[1] := x_57;
                set x_1[0] := x_53;
                set x_55[0] := x_1;
                ret x_55
              Bool.true →
                dec x_1;
                let x_71 : obj := ctor_1[Lean.Compiler.LCNF.Code.fun] x_53 x_57;
                set x_55[0] := x_71;
                ret x_55
            Bool.true →
              dec x_57;
              dec x_53;
              set x_55[0] := x_1;
              ret x_55
        Bool.true →
          let x_72 : obj := proj[0] x_55;
          let x_73 : obj := proj[1] x_55;
          inc x_73;
          inc x_72;
          dec x_55;
          let x_74 : usize := ptrAddrUnsafe ◾ x_45;
          dec x_45;
          let x_75 : usize := ptrAddrUnsafe ◾ x_72;
          let x_76 : u8 := USize.decEq x_74 x_75;
          case x_76 : u8 of
          Bool.false →
            dec x_44;
            let x_77 : obj := reset[2] x_1;
            let x_78 : obj := reuse x_77 in ctor_1[Lean.Compiler.LCNF.Code.fun] x_53 x_72;
            let x_79 : obj := ctor_0[EStateM.Result.ok] x_78 x_73;
            ret x_79
          Bool.true →
            let x_80 : usize := ptrAddrUnsafe ◾ x_44;
            dec x_44;
            let x_81 : usize := ptrAddrUnsafe ◾ x_53;
            let x_82 : u8 := USize.decEq x_80 x_81;
            case x_82 : u8 of
            Bool.false →
              let x_83 : obj := reset[2] x_1;
              let x_84 : obj := reuse x_83 in ctor_1[Lean.Compiler.LCNF.Code.fun] x_53 x_72;
              let x_85 : obj := ctor_0[EStateM.Result.ok] x_84 x_73;
              ret x_85
            Bool.true →
              dec x_72;
              dec x_53;
              let x_86 : obj := ctor_0[EStateM.Result.ok] x_1 x_73;
              ret x_86
      EStateM.Result.error →
        dec x_53;
        dec x_45;
        dec x_44;
        dec x_1;
        let x_87 : u8 := isShared x_55;
        case x_87 : u8 of
        Bool.false →
          ret x_55
        Bool.true →
          let x_88 : obj := proj[0] x_55;
          let x_89 : obj := proj[1] x_55;
          inc x_89;
          inc x_88;
          dec x_55;
          let x_90 : obj := ctor_1[EStateM.Result.error] x_88 x_89;
          ret x_90
    EStateM.Result.error →
      dec x_45;
      dec x_44;
      dec x_6;
      dec x_5;
      dec x_4;
      dec x_3;
      dec x_2;
      dec x_1;
      let x_91 : u8 := isShared x_47;
      case x_91 : u8 of
      Bool.false →
        ret x_47
      Bool.true →
        let x_92 : obj := proj[0] x_47;
        let x_93 : obj := proj[1] x_47;
        inc x_93;
        inc x_92;
        dec x_47;
        let x_94 : obj := ctor_1[EStateM.Result.error] x_92 x_93;
        ret x_94
  Lean.Compiler.LCNF.Code.jp →
    let x_95 : obj := proj[0] x_1;
    inc x_95;
    let x_96 : obj := proj[1] x_1;
    inc x_96;
    let x_97 : obj := proj[0] x_95;
    inc x_97;
    let x_98 : obj := Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1 x_2 x_97;
    dec x_97;
    case x_98 : obj of
    Option.none →
      inc x_96;
      let x_99 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_96 x_2 x_3 x_4 x_5 x_6 x_7;
      case x_99 : obj of
      EStateM.Result.ok →
        let x_100 : u8 := isShared x_99;
        case x_100 : u8 of
        Bool.false →
          let x_101 : obj := proj[0] x_99;
          let x_102 : usize := ptrAddrUnsafe ◾ x_96;
          dec x_96;
          let x_103 : usize := ptrAddrUnsafe ◾ x_101;
          let x_104 : u8 := USize.decEq x_102 x_103;
          case x_104 : u8 of
          Bool.false →
            let x_105 : u8 := isShared x_1;
            case x_105 : u8 of
            Bool.false →
              let x_106 : obj := proj[1] x_1;
              dec x_106;
              let x_107 : obj := proj[0] x_1;
              dec x_107;
              set x_1[1] := x_101;
              set x_99[0] := x_1;
              ret x_99
            Bool.true →
              dec x_1;
              let x_108 : obj := ctor_2[Lean.Compiler.LCNF.Code.jp] x_95 x_101;
              set x_99[0] := x_108;
              ret x_99
          Bool.true →
            let x_109 : usize := ptrAddrUnsafe ◾ x_95;
            let x_110 : u8 := USize.decEq x_109 x_109;
            case x_110 : u8 of
            Bool.false →
              let x_111 : u8 := isShared x_1;
              case x_111 : u8 of
              Bool.false →
                let x_112 : obj := proj[1] x_1;
                dec x_112;
                let x_113 : obj := proj[0] x_1;
                dec x_113;
                set x_1[1] := x_101;
                set x_99[0] := x_1;
                ret x_99
              Bool.true →
                dec x_1;
                let x_114 : obj := ctor_2[Lean.Compiler.LCNF.Code.jp] x_95 x_101;
                set x_99[0] := x_114;
                ret x_99
            Bool.true →
              dec x_101;
              dec x_95;
              set x_99[0] := x_1;
              ret x_99
        Bool.true →
          let x_115 : obj := proj[0] x_99;
          let x_116 : obj := proj[1] x_99;
          inc x_116;
          inc x_115;
          dec x_99;
          let x_117 : usize := ptrAddrUnsafe ◾ x_96;
          dec x_96;
          let x_118 : usize := ptrAddrUnsafe ◾ x_115;
          let x_119 : u8 := USize.decEq x_117 x_118;
          case x_119 : u8 of
          Bool.false →
            let x_120 : obj := reset[2] x_1;
            let x_121 : obj := reuse x_120 in ctor_2[Lean.Compiler.LCNF.Code.jp] x_95 x_115;
            let x_122 : obj := ctor_0[EStateM.Result.ok] x_121 x_116;
            ret x_122
          Bool.true →
            let x_123 : usize := ptrAddrUnsafe ◾ x_95;
            let x_124 : u8 := USize.decEq x_123 x_123;
            case x_124 : u8 of
            Bool.false →
              let x_125 : obj := reset[2] x_1;
              let x_126 : obj := reuse x_125 in ctor_2[Lean.Compiler.LCNF.Code.jp] x_95 x_115;
              let x_127 : obj := ctor_0[EStateM.Result.ok] x_126 x_116;
              ret x_127
            Bool.true →
              dec x_115;
              dec x_95;
              let x_128 : obj := ctor_0[EStateM.Result.ok] x_1 x_116;
              ret x_128
      EStateM.Result.error →
        dec x_96;
        dec x_95;
        dec x_1;
        let x_129 : u8 := isShared x_99;
        case x_129 : u8 of
        Bool.false →
          ret x_99
        Bool.true →
          let x_130 : obj := proj[0] x_99;
          let x_131 : obj := proj[1] x_99;
          inc x_131;
          inc x_130;
          dec x_99;
          let x_132 : obj := ctor_1[EStateM.Result.error] x_130 x_131;
          ret x_132
    Option.some →
      let x_133 : obj := proj[0] x_98;
      inc x_133;
      dec x_98;
      let x_134 : obj := proj[2] x_95;
      inc x_134;
      let x_135 : obj := Array.size ◾ x_134;
      let x_136 : obj := 0;
      let x_137 : u8 := Nat.decLt x_136 x_135;
      case x_137 : u8 of
      Bool.false →
        dec x_134;
        let x_138 : obj := proj[4] x_95;
        inc x_138;
        inc x_6;
        inc x_5;
        inc x_4;
        inc x_3;
        inc x_2;
        let x_139 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_138 x_2 x_3 x_4 x_5 x_6 x_7;
        case x_139 : obj of
        EStateM.Result.ok →
          let x_140 : obj := proj[0] x_139;
          inc x_140;
          let x_141 : obj := proj[1] x_139;
          inc x_141;
          dec x_139;
          let x_142 : u8 := 0;
          inc x_6;
          inc x_5;
          inc x_4;
          inc x_3;
          let x_143 : obj := Lean.Compiler.LCNF.normCodeImp x_142 x_140 x_133 x_3 x_4 x_5 x_6 x_141;
          case x_143 : obj of
          EStateM.Result.ok →
            let x_144 : obj := proj[0] x_143;
            inc x_144;
            let x_145 : obj := proj[1] x_143;
            inc x_145;
            dec x_143;
            let x_146 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_2;
            let x_147 : u8 := Nat.beq x_146 x_135;
            dec x_135;
            dec x_146;
            case x_147 : u8 of
            Bool.false →
              inc x_6;
              inc x_5;
              inc x_4;
              inc x_3;
              inc x_144;
              let x_148 : obj := Lean.Compiler.LCNF.Code.inferType x_144 x_3 x_4 x_5 x_6 x_145;
              case x_148 : obj of
              EStateM.Result.ok →
                let x_149 : obj := proj[0] x_148;
                inc x_149;
                let x_150 : obj := proj[1] x_148;
                inc x_150;
                dec x_148;
                let x_151 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
                inc x_6;
                inc x_5;
                inc x_4;
                inc x_3;
                inc x_151;
                let x_152 : obj := Lean.Compiler.LCNF.mkForallParams x_151 x_149 x_3 x_4 x_5 x_6 x_150;
                case x_152 : obj of
                EStateM.Result.ok →
                  let x_153 : obj := proj[0] x_152;
                  inc x_153;
                  let x_154 : obj := proj[1] x_152;
                  inc x_154;
                  dec x_152;
                  let x_155 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_96 x_95 x_151 x_144 x_1 x_153 x_2 x_3 x_4 x_5 x_6 x_154;
                  ret x_155
                EStateM.Result.error →
                  dec x_151;
                  dec x_144;
                  dec x_96;
                  dec x_95;
                  dec x_6;
                  dec x_5;
                  dec x_4;
                  dec x_3;
                  dec x_2;
                  dec x_1;
                  let x_156 : u8 := isShared x_152;
                  case x_156 : u8 of
                  Bool.false →
                    ret x_152
                  Bool.true →
                    let x_157 : obj := proj[0] x_152;
                    let x_158 : obj := proj[1] x_152;
                    inc x_158;
                    inc x_157;
                    dec x_152;
                    let x_159 : obj := ctor_1[EStateM.Result.error] x_157 x_158;
                    ret x_159
              EStateM.Result.error →
                dec x_144;
                dec x_96;
                dec x_95;
                dec x_6;
                dec x_5;
                dec x_4;
                dec x_3;
                dec x_2;
                dec x_1;
                let x_160 : u8 := isShared x_148;
                case x_160 : u8 of
                Bool.false →
                  ret x_148
                Bool.true →
                  let x_161 : obj := proj[0] x_148;
                  let x_162 : obj := proj[1] x_148;
                  inc x_162;
                  inc x_161;
                  dec x_148;
                  let x_163 : obj := ctor_1[EStateM.Result.error] x_161 x_162;
                  ret x_163
            Bool.true →
              let x_164 : obj := proj[3] x_95;
              inc x_164;
              let x_165 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
              let x_166 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_96 x_95 x_165 x_144 x_1 x_164 x_2 x_3 x_4 x_5 x_6 x_145;
              ret x_166
          EStateM.Result.error →
            dec x_135;
            dec x_96;
            dec x_95;
            dec x_6;
            dec x_5;
            dec x_4;
            dec x_3;
            dec x_2;
            dec x_1;
            let x_167 : u8 := isShared x_143;
            case x_167 : u8 of
            Bool.false →
              ret x_143
            Bool.true →
              let x_168 : obj := proj[0] x_143;
              let x_169 : obj := proj[1] x_143;
              inc x_169;
              inc x_168;
              dec x_143;
              let x_170 : obj := ctor_1[EStateM.Result.error] x_168 x_169;
              ret x_170
        EStateM.Result.error →
          dec x_135;
          dec x_133;
          dec x_96;
          dec x_95;
          dec x_6;
          dec x_5;
          dec x_4;
          dec x_3;
          dec x_2;
          dec x_1;
          let x_171 : u8 := isShared x_139;
          case x_171 : u8 of
          Bool.false →
            ret x_139
          Bool.true →
            let x_172 : obj := proj[0] x_139;
            let x_173 : obj := proj[1] x_139;
            inc x_173;
            inc x_172;
            dec x_139;
            let x_174 : obj := ctor_1[EStateM.Result.error] x_172 x_173;
            ret x_174
      Bool.true →
        let x_175 : u8 := Nat.decLe x_135 x_135;
        case x_175 : u8 of
        Bool.false →
          dec x_134;
          let x_176 : obj := proj[4] x_95;
          inc x_176;
          inc x_6;
          inc x_5;
          inc x_4;
          inc x_3;
          inc x_2;
          let x_177 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_176 x_2 x_3 x_4 x_5 x_6 x_7;
          case x_177 : obj of
          EStateM.Result.ok →
            let x_178 : obj := proj[0] x_177;
            inc x_178;
            let x_179 : obj := proj[1] x_177;
            inc x_179;
            dec x_177;
            let x_180 : u8 := 0;
            inc x_6;
            inc x_5;
            inc x_4;
            inc x_3;
            let x_181 : obj := Lean.Compiler.LCNF.normCodeImp x_180 x_178 x_133 x_3 x_4 x_5 x_6 x_179;
            case x_181 : obj of
            EStateM.Result.ok →
              let x_182 : obj := proj[0] x_181;
              inc x_182;
              let x_183 : obj := proj[1] x_181;
              inc x_183;
              dec x_181;
              let x_184 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_2;
              let x_185 : u8 := Nat.beq x_184 x_135;
              dec x_135;
              dec x_184;
              case x_185 : u8 of
              Bool.false →
                inc x_6;
                inc x_5;
                inc x_4;
                inc x_3;
                inc x_182;
                let x_186 : obj := Lean.Compiler.LCNF.Code.inferType x_182 x_3 x_4 x_5 x_6 x_183;
                case x_186 : obj of
                EStateM.Result.ok →
                  let x_187 : obj := proj[0] x_186;
                  inc x_187;
                  let x_188 : obj := proj[1] x_186;
                  inc x_188;
                  dec x_186;
                  let x_189 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
                  inc x_6;
                  inc x_5;
                  inc x_4;
                  inc x_3;
                  inc x_189;
                  let x_190 : obj := Lean.Compiler.LCNF.mkForallParams x_189 x_187 x_3 x_4 x_5 x_6 x_188;
                  case x_190 : obj of
                  EStateM.Result.ok →
                    let x_191 : obj := proj[0] x_190;
                    inc x_191;
                    let x_192 : obj := proj[1] x_190;
                    inc x_192;
                    dec x_190;
                    let x_193 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_96 x_95 x_189 x_182 x_1 x_191 x_2 x_3 x_4 x_5 x_6 x_192;
                    ret x_193
                  EStateM.Result.error →
                    dec x_189;
                    dec x_182;
                    dec x_96;
                    dec x_95;
                    dec x_6;
                    dec x_5;
                    dec x_4;
                    dec x_3;
                    dec x_2;
                    dec x_1;
                    let x_194 : u8 := isShared x_190;
                    case x_194 : u8 of
                    Bool.false →
                      ret x_190
                    Bool.true →
                      let x_195 : obj := proj[0] x_190;
                      let x_196 : obj := proj[1] x_190;
                      inc x_196;
                      inc x_195;
                      dec x_190;
                      let x_197 : obj := ctor_1[EStateM.Result.error] x_195 x_196;
                      ret x_197
                EStateM.Result.error →
                  dec x_182;
                  dec x_96;
                  dec x_95;
                  dec x_6;
                  dec x_5;
                  dec x_4;
                  dec x_3;
                  dec x_2;
                  dec x_1;
                  let x_198 : u8 := isShared x_186;
                  case x_198 : u8 of
                  Bool.false →
                    ret x_186
                  Bool.true →
                    let x_199 : obj := proj[0] x_186;
                    let x_200 : obj := proj[1] x_186;
                    inc x_200;
                    inc x_199;
                    dec x_186;
                    let x_201 : obj := ctor_1[EStateM.Result.error] x_199 x_200;
                    ret x_201
              Bool.true →
                let x_202 : obj := proj[3] x_95;
                inc x_202;
                let x_203 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
                let x_204 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_96 x_95 x_203 x_182 x_1 x_202 x_2 x_3 x_4 x_5 x_6 x_183;
                ret x_204
            EStateM.Result.error →
              dec x_135;
              dec x_96;
              dec x_95;
              dec x_6;
              dec x_5;
              dec x_4;
              dec x_3;
              dec x_2;
              dec x_1;
              let x_205 : u8 := isShared x_181;
              case x_205 : u8 of
              Bool.false →
                ret x_181
              Bool.true →
                let x_206 : obj := proj[0] x_181;
                let x_207 : obj := proj[1] x_181;
                inc x_207;
                inc x_206;
                dec x_181;
                let x_208 : obj := ctor_1[EStateM.Result.error] x_206 x_207;
                ret x_208
          EStateM.Result.error →
            dec x_135;
            dec x_133;
            dec x_96;
            dec x_95;
            dec x_6;
            dec x_5;
            dec x_4;
            dec x_3;
            dec x_2;
            dec x_1;
            let x_209 : u8 := isShared x_177;
            case x_209 : u8 of
            Bool.false →
              ret x_177
            Bool.true →
              let x_210 : obj := proj[0] x_177;
              let x_211 : obj := proj[1] x_177;
              inc x_211;
              inc x_210;
              dec x_177;
              let x_212 : obj := ctor_1[EStateM.Result.error] x_210 x_211;
              ret x_212
        Bool.true →
          let x_213 : usize := 0;
          let x_214 : usize := USize.ofNat x_135;
          let x_215 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
          let x_216 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2 x_133 x_134 x_213 x_214 x_215 x_2 x_3 x_4 x_5 x_6 x_7;
          dec x_134;
          let x_217 : obj := proj[0] x_216;
          inc x_217;
          let x_218 : obj := proj[1] x_216;
          inc x_218;
          dec x_216;
          let x_219 : obj := proj[4] x_95;
          inc x_219;
          inc x_6;
          inc x_5;
          inc x_4;
          inc x_3;
          inc x_2;
          let x_220 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_219 x_2 x_3 x_4 x_5 x_6 x_218;
          case x_220 : obj of
          EStateM.Result.ok →
            let x_221 : obj := proj[0] x_220;
            inc x_221;
            let x_222 : obj := proj[1] x_220;
            inc x_222;
            dec x_220;
            let x_223 : u8 := 0;
            inc x_6;
            inc x_5;
            inc x_4;
            inc x_3;
            let x_224 : obj := Lean.Compiler.LCNF.normCodeImp x_223 x_221 x_133 x_3 x_4 x_5 x_6 x_222;
            case x_224 : obj of
            EStateM.Result.ok →
              let x_225 : obj := proj[0] x_224;
              inc x_225;
              let x_226 : obj := proj[1] x_224;
              inc x_226;
              dec x_224;
              let x_227 : obj := Array.size ◾ x_217;
              let x_228 : u8 := Nat.beq x_227 x_135;
              dec x_135;
              dec x_227;
              case x_228 : u8 of
              Bool.false →
                inc x_6;
                inc x_5;
                inc x_4;
                inc x_3;
                inc x_225;
                let x_229 : obj := Lean.Compiler.LCNF.Code.inferType x_225 x_3 x_4 x_5 x_6 x_226;
                case x_229 : obj of
                EStateM.Result.ok →
                  let x_230 : obj := proj[0] x_229;
                  inc x_230;
                  let x_231 : obj := proj[1] x_229;
                  inc x_231;
                  dec x_229;
                  inc x_6;
                  inc x_5;
                  inc x_4;
                  inc x_3;
                  inc x_217;
                  let x_232 : obj := Lean.Compiler.LCNF.mkForallParams x_217 x_230 x_3 x_4 x_5 x_6 x_231;
                  case x_232 : obj of
                  EStateM.Result.ok →
                    let x_233 : obj := proj[0] x_232;
                    inc x_233;
                    let x_234 : obj := proj[1] x_232;
                    inc x_234;
                    dec x_232;
                    let x_235 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_96 x_95 x_217 x_225 x_1 x_233 x_2 x_3 x_4 x_5 x_6 x_234;
                    ret x_235
                  EStateM.Result.error →
                    dec x_225;
                    dec x_217;
                    dec x_96;
                    dec x_95;
                    dec x_6;
                    dec x_5;
                    dec x_4;
                    dec x_3;
                    dec x_2;
                    dec x_1;
                    let x_236 : u8 := isShared x_232;
                    case x_236 : u8 of
                    Bool.false →
                      ret x_232
                    Bool.true →
                      let x_237 : obj := proj[0] x_232;
                      let x_238 : obj := proj[1] x_232;
                      inc x_238;
                      inc x_237;
                      dec x_232;
                      let x_239 : obj := ctor_1[EStateM.Result.error] x_237 x_238;
                      ret x_239
                EStateM.Result.error →
                  dec x_225;
                  dec x_217;
                  dec x_96;
                  dec x_95;
                  dec x_6;
                  dec x_5;
                  dec x_4;
                  dec x_3;
                  dec x_2;
                  dec x_1;
                  let x_240 : u8 := isShared x_229;
                  case x_240 : u8 of
                  Bool.false →
                    ret x_229
                  Bool.true →
                    let x_241 : obj := proj[0] x_229;
                    let x_242 : obj := proj[1] x_229;
                    inc x_242;
                    inc x_241;
                    dec x_229;
                    let x_243 : obj := ctor_1[EStateM.Result.error] x_241 x_242;
                    ret x_243
              Bool.true →
                let x_244 : obj := proj[3] x_95;
                inc x_244;
                let x_245 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_96 x_95 x_217 x_225 x_1 x_244 x_2 x_3 x_4 x_5 x_6 x_226;
                ret x_245
            EStateM.Result.error →
              dec x_217;
              dec x_135;
              dec x_96;
              dec x_95;
              dec x_6;
              dec x_5;
              dec x_4;
              dec x_3;
              dec x_2;
              dec x_1;
              let x_246 : u8 := isShared x_224;
              case x_246 : u8 of
              Bool.false →
                ret x_224
              Bool.true →
                let x_247 : obj := proj[0] x_224;
                let x_248 : obj := proj[1] x_224;
                inc x_248;
                inc x_247;
                dec x_224;
                let x_249 : obj := ctor_1[EStateM.Result.error] x_247 x_248;
                ret x_249
          EStateM.Result.error →
            dec x_217;
            dec x_135;
            dec x_133;
            dec x_96;
            dec x_95;
            dec x_6;
            dec x_5;
            dec x_4;
            dec x_3;
            dec x_2;
            dec x_1;
            let x_250 : u8 := isShared x_220;
            case x_250 : u8 of
            Bool.false →
              ret x_220
            Bool.true →
              let x_251 : obj := proj[0] x_220;
              let x_252 : obj := proj[1] x_220;
              inc x_252;
              inc x_251;
              dec x_220;
              let x_253 : obj := ctor_1[EStateM.Result.error] x_251 x_252;
              ret x_253
  Lean.Compiler.LCNF.Code.jmp →
    let x_254 : obj := proj[0] x_1;
    inc x_254;
    let x_255 : obj := proj[1] x_1;
    inc x_255;
    block_299 (x_256 : obj) (x_257 : obj) (x_258 : obj) :=
      block_286 (x_259 : obj) :=
        case x_1 : obj of
        Lean.Compiler.LCNF.Code.jmp →
          let x_260 : obj := proj[0] x_1;
          inc x_260;
          let x_261 : obj := proj[1] x_1;
          inc x_261;
          let x_262 : obj := Array.size ◾ x_259;
          let x_263 : usize := USize.ofNat x_262;
          dec x_262;
          let x_264 : usize := 0;
          let x_265 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_3 x_263 x_264 x_259;
          let x_266 : u8 := Lean.Name.beq x_260 x_254;
          dec x_260;
          case x_266 : u8 of
          Bool.false →
            dec x_261;
            let x_267 : u8 := isShared x_1;
            case x_267 : u8 of
            Bool.false →
              let x_268 : obj := proj[1] x_1;
              dec x_268;
              let x_269 : obj := proj[0] x_1;
              dec x_269;
              set x_1[1] := x_265;
              let x_270 : obj := ctor_0[EStateM.Result.ok] x_1 x_258;
              ret x_270
            Bool.true →
              dec x_1;
              let x_271 : obj := ctor_3[Lean.Compiler.LCNF.Code.jmp] x_254 x_265;
              let x_272 : obj := ctor_0[EStateM.Result.ok] x_271 x_258;
              ret x_272
          Bool.true →
            let x_273 : usize := ptrAddrUnsafe ◾ x_261;
            dec x_261;
            let x_274 : usize := ptrAddrUnsafe ◾ x_265;
            let x_275 : u8 := USize.decEq x_273 x_274;
            case x_275 : u8 of
            Bool.false →
              let x_276 : u8 := isShared x_1;
              case x_276 : u8 of
              Bool.false →
                let x_277 : obj := proj[1] x_1;
                dec x_277;
                let x_278 : obj := proj[0] x_1;
                dec x_278;
                set x_1[1] := x_265;
                let x_279 : obj := ctor_0[EStateM.Result.ok] x_1 x_258;
                ret x_279
              Bool.true →
                dec x_1;
                let x_280 : obj := ctor_3[Lean.Compiler.LCNF.Code.jmp] x_254 x_265;
                let x_281 : obj := ctor_0[EStateM.Result.ok] x_280 x_258;
                ret x_281
            Bool.true →
              dec x_265;
              dec x_254;
              let x_282 : obj := ctor_0[EStateM.Result.ok] x_1 x_258;
              ret x_282
        default →
          dec x_259;
          dec x_254;
          dec x_1;
          let x_283 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5;
          let x_284 : obj := panic._at._private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltsImp._spec_1 x_283;
          let x_285 : obj := ctor_0[EStateM.Result.ok] x_284 x_258;
          ret x_285;
      let x_287 : obj := proj[2] x_257;
      inc x_287;
      dec x_257;
      let x_288 : obj := Array.zip._rarg x_287 x_255;
      dec x_255;
      dec x_287;
      let x_289 : obj := Array.size ◾ x_288;
      let x_290 : obj := 0;
      let x_291 : u8 := Nat.decLt x_290 x_289;
      case x_291 : u8 of
      Bool.false →
        dec x_289;
        dec x_288;
        dec x_256;
        let x_292 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
        jmp block_286 x_292
      Bool.true →
        let x_293 : u8 := Nat.decLe x_289 x_289;
        case x_293 : u8 of
        Bool.false →
          dec x_289;
          dec x_288;
          dec x_256;
          let x_294 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
          jmp block_286 x_294
        Bool.true →
          let x_295 : usize := 0;
          let x_296 : usize := USize.ofNat x_289;
          dec x_289;
          let x_297 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
          let x_298 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_4 x_256 x_288 x_295 x_296 x_297;
          dec x_288;
          dec x_256;
          jmp block_286 x_298;
    inc x_254;
    let x_300 : obj := Lean.Compiler.LCNF.getFunDecl x_254 x_3 x_4 x_5 x_6 x_7;
    dec x_6;
    dec x_5;
    dec x_4;
    dec x_3;
    let x_301 : obj := Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1 x_2 x_254;
    dec x_2;
    case x_301 : obj of
    Option.none →
      case x_300 : obj of
      EStateM.Result.ok →
        let x_302 : obj := proj[0] x_300;
        inc x_302;
        let x_303 : obj := proj[1] x_300;
        inc x_303;
        dec x_300;
        let x_304 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.isInJpScope._closed_3;
        let x_305 : obj := panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_5 x_304;
        jmp block_299 x_305 x_302 x_303
      EStateM.Result.error →
        dec x_255;
        dec x_254;
        dec x_1;
        let x_306 : u8 := isShared x_300;
        case x_306 : u8 of
        Bool.false →
          ret x_300
        Bool.true →
          let x_307 : obj := proj[0] x_300;
          let x_308 : obj := proj[1] x_300;
          inc x_308;
          inc x_307;
          dec x_300;
          let x_309 : obj := ctor_1[EStateM.Result.error] x_307 x_308;
          ret x_309
    Option.some →
      case x_300 : obj of
      EStateM.Result.ok →
        let x_310 : obj := proj[0] x_301;
        inc x_310;
        dec x_301;
        let x_311 : obj := proj[0] x_300;
        inc x_311;
        let x_312 : obj := proj[1] x_300;
        inc x_312;
        dec x_300;
        jmp block_299 x_310 x_311 x_312
      EStateM.Result.error →
        dec x_301;
        dec x_255;
        dec x_254;
        dec x_1;
        let x_313 : u8 := isShared x_300;
        case x_313 : u8 of
        Bool.false →
          ret x_300
        Bool.true →
          let x_314 : obj := proj[0] x_300;
          let x_315 : obj := proj[1] x_300;
          inc x_315;
          inc x_314;
          dec x_300;
          let x_316 : obj := ctor_1[EStateM.Result.error] x_314 x_315;
          ret x_316
  Lean.Compiler.LCNF.Code.cases →
    let x_317 : obj := proj[0] x_1;
    inc x_317;
    let x_318 : u8 := isShared x_317;
    case x_318 : u8 of
    Bool.false →
      let x_319 : obj := proj[0] x_317;
      let x_320 : obj := proj[1] x_317;
      let x_321 : obj := proj[2] x_317;
      let x_322 : obj := proj[3] x_317;
      let x_323 : obj := Array.size ◾ x_322;
      let x_324 : usize := USize.ofNat x_323;
      dec x_323;
      let x_325 : usize := 0;
      inc x_322;
      let x_326 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_7 x_324 x_325 x_322 x_2 x_3 x_4 x_5 x_6 x_7;
      case x_326 : obj of
      EStateM.Result.ok →
        let x_327 : u8 := isShared x_326;
        case x_327 : u8 of
        Bool.false →
          let x_328 : obj := proj[0] x_326;
          let x_329 : usize := ptrAddrUnsafe ◾ x_322;
          dec x_322;
          let x_330 : usize := ptrAddrUnsafe ◾ x_328;
          let x_331 : u8 := USize.decEq x_329 x_330;
          case x_331 : u8 of
          Bool.false →
            let x_332 : u8 := isShared x_1;
            case x_332 : u8 of
            Bool.false →
              let x_333 : obj := proj[0] x_1;
              dec x_333;
              set x_317[3] := x_328;
              set x_326[0] := x_1;
              ret x_326
            Bool.true →
              dec x_1;
              set x_317[3] := x_328;
              let x_334 : obj := ctor_4[Lean.Compiler.LCNF.Code.cases] x_317;
              set x_326[0] := x_334;
              ret x_326
          Bool.true →
            let x_335 : usize := ptrAddrUnsafe ◾ x_320;
            let x_336 : u8 := USize.decEq x_335 x_335;
            case x_336 : u8 of
            Bool.false →
              let x_337 : u8 := isShared x_1;
              case x_337 : u8 of
              Bool.false →
                let x_338 : obj := proj[0] x_1;
                dec x_338;
                set x_317[3] := x_328;
                set x_326[0] := x_1;
                ret x_326
              Bool.true →
                dec x_1;
                set x_317[3] := x_328;
                let x_339 : obj := ctor_4[Lean.Compiler.LCNF.Code.cases] x_317;
                set x_326[0] := x_339;
                ret x_326
            Bool.true →
              let x_340 : u8 := Lean.Name.beq x_321 x_321;
              case x_340 : u8 of
              Bool.false →
                let x_341 : u8 := isShared x_1;
                case x_341 : u8 of
                Bool.false →
                  let x_342 : obj := proj[0] x_1;
                  dec x_342;
                  set x_317[3] := x_328;
                  set x_326[0] := x_1;
                  ret x_326
                Bool.true →
                  dec x_1;
                  set x_317[3] := x_328;
                  let x_343 : obj := ctor_4[Lean.Compiler.LCNF.Code.cases] x_317;
                  set x_326[0] := x_343;
                  ret x_326
              Bool.true →
                dec x_328;
                del x_317;
                dec x_321;
                dec x_320;
                dec x_319;
                set x_326[0] := x_1;
                ret x_326
        Bool.true →
          let x_344 : obj := proj[0] x_326;
          let x_345 : obj := proj[1] x_326;
          inc x_345;
          inc x_344;
          dec x_326;
          let x_346 : usize := ptrAddrUnsafe ◾ x_322;
          dec x_322;
          let x_347 : usize := ptrAddrUnsafe ◾ x_344;
          let x_348 : u8 := USize.decEq x_346 x_347;
          case x_348 : u8 of
          Bool.false →
            let x_349 : obj := reset[1] x_1;
            set x_317[3] := x_344;
            let x_350 : obj := reuse x_349 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_317;
            let x_351 : obj := ctor_0[EStateM.Result.ok] x_350 x_345;
            ret x_351
          Bool.true →
            let x_352 : usize := ptrAddrUnsafe ◾ x_320;
            let x_353 : u8 := USize.decEq x_352 x_352;
            case x_353 : u8 of
            Bool.false →
              let x_354 : obj := reset[1] x_1;
              set x_317[3] := x_344;
              let x_355 : obj := reuse x_354 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_317;
              let x_356 : obj := ctor_0[EStateM.Result.ok] x_355 x_345;
              ret x_356
            Bool.true →
              let x_357 : u8 := Lean.Name.beq x_321 x_321;
              case x_357 : u8 of
              Bool.false →
                let x_358 : obj := reset[1] x_1;
                set x_317[3] := x_344;
                let x_359 : obj := reuse x_358 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_317;
                let x_360 : obj := ctor_0[EStateM.Result.ok] x_359 x_345;
                ret x_360
              Bool.true →
                dec x_344;
                del x_317;
                dec x_321;
                dec x_320;
                dec x_319;
                let x_361 : obj := ctor_0[EStateM.Result.ok] x_1 x_345;
                ret x_361
      EStateM.Result.error →
        del x_317;
        dec x_322;
        dec x_321;
        dec x_320;
        dec x_319;
        dec x_1;
        let x_362 : u8 := isShared x_326;
        case x_362 : u8 of
        Bool.false →
          ret x_326
        Bool.true →
          let x_363 : obj := proj[0] x_326;
          let x_364 : obj := proj[1] x_326;
          inc x_364;
          inc x_363;
          dec x_326;
          let x_365 : obj := ctor_1[EStateM.Result.error] x_363 x_364;
          ret x_365
    Bool.true →
      let x_366 : obj := proj[0] x_317;
      let x_367 : obj := proj[1] x_317;
      let x_368 : obj := proj[2] x_317;
      let x_369 : obj := proj[3] x_317;
      inc x_369;
      inc x_368;
      inc x_367;
      inc x_366;
      dec x_317;
      let x_370 : obj := Array.size ◾ x_369;
      let x_371 : usize := USize.ofNat x_370;
      dec x_370;
      let x_372 : usize := 0;
      inc x_369;
      let x_373 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_7 x_371 x_372 x_369 x_2 x_3 x_4 x_5 x_6 x_7;
      case x_373 : obj of
      EStateM.Result.ok →
        let x_374 : obj := proj[0] x_373;
        inc x_374;
        let x_375 : obj := proj[1] x_373;
        inc x_375;
        let x_376 : obj := reset[2] x_373;
        let x_377 : usize := ptrAddrUnsafe ◾ x_369;
        dec x_369;
        let x_378 : usize := ptrAddrUnsafe ◾ x_374;
        let x_379 : u8 := USize.decEq x_377 x_378;
        case x_379 : u8 of
        Bool.false →
          let x_380 : obj := reset[1] x_1;
          let x_381 : obj := ctor_0[Lean.Compiler.LCNF.CasesCore.mk] x_366 x_367 x_368 x_374;
          let x_382 : obj := reuse x_380 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_381;
          let x_383 : obj := reuse x_376 in ctor_0[EStateM.Result.ok] x_382 x_375;
          ret x_383
        Bool.true →
          let x_384 : usize := ptrAddrUnsafe ◾ x_367;
          let x_385 : u8 := USize.decEq x_384 x_384;
          case x_385 : u8 of
          Bool.false →
            let x_386 : obj := reset[1] x_1;
            let x_387 : obj := ctor_0[Lean.Compiler.LCNF.CasesCore.mk] x_366 x_367 x_368 x_374;
            let x_388 : obj := reuse x_386 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_387;
            let x_389 : obj := reuse x_376 in ctor_0[EStateM.Result.ok] x_388 x_375;
            ret x_389
          Bool.true →
            let x_390 : u8 := Lean.Name.beq x_368 x_368;
            case x_390 : u8 of
            Bool.false →
              let x_391 : obj := reset[1] x_1;
              let x_392 : obj := ctor_0[Lean.Compiler.LCNF.CasesCore.mk] x_366 x_367 x_368 x_374;
              let x_393 : obj := reuse x_391 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_392;
              let x_394 : obj := reuse x_376 in ctor_0[EStateM.Result.ok] x_393 x_375;
              ret x_394
            Bool.true →
              dec x_374;
              dec x_368;
              dec x_367;
              dec x_366;
              let x_395 : obj := reuse x_376 in ctor_0[EStateM.Result.ok] x_1 x_375;
              ret x_395
      EStateM.Result.error →
        dec x_369;
        dec x_368;
        dec x_367;
        dec x_366;
        dec x_1;
        let x_396 : obj := proj[0] x_373;
        inc x_396;
        let x_397 : obj := proj[1] x_373;
        inc x_397;
        let x_398 : obj := reset[2] x_373;
        let x_399 : obj := reuse x_398 in ctor_1[EStateM.Result.error] x_396 x_397;
        ret x_399
  default →
    dec x_6;
    dec x_5;
    dec x_4;
    dec x_3;
    dec x_2;
    let x_400 : obj := ctor_0[EStateM.Result.ok] x_1 x_7;
    ret x_400
def Lean.HashMapImp.contains._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_1._boxed (x_1 : obj) (x_2 : obj) : obj :=
