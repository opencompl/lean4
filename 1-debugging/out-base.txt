
[reset_reuse]
def ReaderT.pure._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_1._rarg (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  let x_10 : obj := ctor_0[EStateM.Result.ok] x_1 x_9;
  ret x_10
def ReaderT.pure._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_1 (x_1 : ◾) : obj :=
  let x_2 : obj := pap ReaderT.pure._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_1._rarg;
  ret x_2
def ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) : obj :=
  let x_11 : obj := app x_1 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
  case x_11 : obj of
  EStateM.Result.ok →
    let x_12 : obj := proj[0] x_11;
    let x_13 : obj := proj[1] x_11;
    let x_14 : obj := app x_2 x_12 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_13;
    ret x_14
  EStateM.Result.error →
    let x_15 : obj := proj[0] x_11;
    let x_16 : obj := proj[1] x_11;
    let x_19 : obj := reset[2] x_11;
    let x_17 : obj := reuse x_19 in ctor_1[EStateM.Result.error] x_15 x_16;
    ret x_17
def ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2 (x_1 : ◾) (x_2 : ◾) : obj :=
  let x_3 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg;
  ret x_3
def Lean.Compiler.LCNF.ScopeM.withBackTrackingScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_4 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  let x_10 : obj := Lean.Compiler.LCNF.ScopeM.getScope x_4 x_5 x_6 x_7 x_8 x_9;
  case x_10 : obj of
  EStateM.Result.ok →
    let x_11 : obj := proj[0] x_10;
    let x_12 : obj := proj[1] x_10;
    let x_13 : obj := app x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_12;
    case x_13 : obj of
    EStateM.Result.ok →
      let x_14 : obj := proj[0] x_13;
      let x_15 : obj := proj[1] x_13;
      let x_16 : obj := Lean.Compiler.LCNF.ScopeM.setScope x_11 x_4 x_5 x_6 x_7 x_8 x_15;
      case x_16 : obj of
      EStateM.Result.ok →
        let x_17 : obj := proj[1] x_16;
        let x_24 : obj := reset[2] x_16;
        let x_18 : obj := reuse x_24 in ctor_0[EStateM.Result.ok] x_14 x_17;
        ret x_18
      EStateM.Result.error →
        ⊥
    EStateM.Result.error →
      let x_19 : obj := proj[0] x_13;
      let x_20 : obj := proj[1] x_13;
      let x_21 : obj := Lean.Compiler.LCNF.ScopeM.setScope x_11 x_4 x_5 x_6 x_7 x_8 x_20;
      case x_21 : obj of
      EStateM.Result.ok →
        let x_22 : obj := proj[1] x_21;
        let x_27 : obj := reset[2] x_21;
        let x_23 : obj := reuse! x_27 in ctor_1[EStateM.Result.error] x_19 x_22;
        ret x_23
      EStateM.Result.error →
        ⊥
  EStateM.Result.error →
    ⊥
def Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_3 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  let x_10 : obj := pap Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointFinder.find.go._spec_2._lambda_2 x_1;
  let x_11 : obj := Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointFinder.find.go._spec_2._closed_1;
  let x_12 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg x_11 x_10;
  let x_13 : obj := Lean.Compiler.LCNF.ScopeM.withBackTrackingScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_4 x_12 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
  ret x_13
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_5 (x_1 : obj) (x_2 : usize) (x_3 : usize) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) (x_11 : obj) (x_12 : obj) : obj :=
  let x_13 : u8 := USize.decEq x_2 x_3;
  case x_13 : obj of
  Bool.false →
    let x_14 : obj := Array.uget ◾ x_1 x_2 ◾;
    let x_15 : obj := proj[0] x_14;
    let x_16 : obj := Lean.Compiler.LCNF.ScopeM.addToScope x_15 x_7 x_8 x_9 x_10 x_11 x_12;
    case x_16 : obj of
    EStateM.Result.ok →
      let x_17 : obj := proj[0] x_16;
      let x_18 : obj := proj[1] x_16;
      let x_19 : usize := 1;
      let x_20 : usize := USize.add x_2 x_19;
      let x_21 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_5 x_1 x_20 x_3 x_17 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_18;
      ret x_21
    EStateM.Result.error →
      ⊥
  Bool.true →
    let x_22 : obj := ctor_0[EStateM.Result.ok] x_4 x_12;
    ret x_22
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._lambda_1 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) : obj :=
  let x_11 : obj := proj[4] x_1;
  let x_12 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze x_11 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
  ret x_12
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  let x_10 : obj := proj[2] x_1;
  let x_11 : obj := Array.size ◾ x_10;
  let x_12 : obj := 0;
  let x_13 : u8 := Nat.decLt x_12 x_11;
  let x_14 : obj := pap Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._lambda_1 x_1;
  case x_13 : obj of
  Bool.false →
    let x_15 : obj := ctor_0[PUnit.unit];
    let x_16 : obj := pap ReaderT.pure._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_1._rarg x_15;
    let x_17 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg x_16 x_14;
    let x_18 : obj := Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_3 x_17 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
    ret x_18
  Bool.true →
    let x_19 : u8 := Nat.decLe x_11 x_11;
    case x_19 : obj of
    Bool.false →
      let x_20 : obj := ctor_0[PUnit.unit];
      let x_21 : obj := pap ReaderT.pure._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_1._rarg x_20;
      let x_22 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg x_21 x_14;
      let x_23 : obj := Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_3 x_22 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
      ret x_23
    Bool.true →
      let x_24 : usize := 0;
      let x_25 : usize := USize.ofNat x_11;
      let x_26 : obj := ctor_0[PUnit.unit];
      let x_27 : obj := pap Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_5 x_10 x_24 x_25 x_26;
      let x_28 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg x_27 x_14;
      let x_29 : obj := Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_3 x_28 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
      ret x_29
def Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1 (x_1 : obj) (x_2 : obj) : obj :=
  case x_1 : obj of
  Lean.RBNode.leaf →
    let x_3 : obj := ctor_0[Option.none];
    ret x_3
  Lean.RBNode.node →
    let x_4 : obj := proj[0] x_1;
    let x_5 : obj := proj[1] x_1;
    let x_6 : obj := proj[2] x_1;
    let x_7 : obj := proj[3] x_1;
    let x_8 : u8 := Lean.Name.quickCmp x_2 x_5;
    case x_8 : obj of
    Ordering.lt →
      let x_9 : obj := Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1 x_4 x_2;
      ret x_9
    Ordering.eq →
      let x_10 : obj := ctor_1[Option.some] x_6;
      ret x_10
    Ordering.gt →
      let x_11 : obj := Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1 x_7 x_2;
      ret x_11
def Lean.Compiler.LCNF.allFVarM.go._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_3._closed_1 : obj :=
  let x_1 : obj := ctor_0[PUnit.unit];
  let x_2 : obj := ctor_1[Option.some] x_1;
  ret x_2
def Lean.Compiler.LCNF.allFVarM.go._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_3 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) : obj :=
  let x_11 : obj := app x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
  case x_11 : obj of
  EStateM.Result.ok →
    let x_12 : obj := proj[0] x_11;
    case x_12 : obj of
    Bool.false →
      let x_13 : obj := proj[1] x_11;
      let x_22 : obj := reset[2] x_11;
      let x_14 : obj := ctor_0[Option.none];
      let x_15 : obj := reuse x_22 in ctor_0[EStateM.Result.ok] x_14 x_13;
      ret x_15
    Bool.true →
      let x_16 : obj := proj[1] x_11;
      let x_23 : obj := reset[2] x_11;
      let x_17 : obj := Lean.Compiler.LCNF.allFVarM.go._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_3._closed_1;
      let x_18 : obj := reuse x_23 in ctor_0[EStateM.Result.ok] x_17 x_16;
      ret x_18
  EStateM.Result.error →
    let x_19 : obj := proj[0] x_11;
    let x_20 : obj := proj[1] x_11;
    let x_24 : obj := reset[2] x_11;
    let x_21 : obj := reuse x_24 in ctor_1[EStateM.Result.error] x_19 x_20;
    ret x_21
def panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_6._closed_1 : obj :=
  let x_1 : obj := panic._at._private.miscompile.0.Lean.Compiler.LCNF.JoinPointFinder.removeCandidatesInArg._spec_3._closed_3;
  let x_2 : obj := OptionT.instMonadOptionT._rarg x_1;
  ret x_2
def panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_6._closed_2 : obj :=
  let x_1 : obj := panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_6._closed_1;
  let x_2 : obj := instInhabitedPUnit;
  let x_3 : obj := instInhabited._rarg x_1 x_2;
  ret x_3
def panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_6 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  let x_10 : obj := panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_6._closed_2;
  let x_11 : obj := panicCore ◾ x_10 x_1;
  let x_12 : obj := app x_11 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
  ret x_12
def Lean.Compiler.LCNF.Expr.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_5 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) : obj :=
  case x_2 : obj of
  Lean.Expr.bvar._impl →
    let x_11 : obj := Lean.Compiler.LCNF.allFVarM.go._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_3._closed_1;
    let x_12 : obj := ctor_0[EStateM.Result.ok] x_11 x_10;
    ret x_12
  Lean.Expr.fvar._impl →
    let x_13 : obj := proj[0] x_2;
    let x_14 : obj := app x_1 x_13 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    ret x_14
  Lean.Expr.mvar._impl →
    let x_15 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at._private.miscompile.0.Lean.Compiler.LCNF.JoinPointFinder.removeCandidatesInArg._spec_2._closed_4;
    let x_16 : obj := panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_6 x_15 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    ret x_16
  Lean.Expr.sort._impl →
    let x_17 : obj := Lean.Compiler.LCNF.allFVarM.go._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_3._closed_1;
    let x_18 : obj := ctor_0[EStateM.Result.ok] x_17 x_10;
    ret x_18
  Lean.Expr.const._impl →
    let x_19 : obj := Lean.Compiler.LCNF.allFVarM.go._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_3._closed_1;
    let x_20 : obj := ctor_0[EStateM.Result.ok] x_19 x_10;
    ret x_20
  Lean.Expr.app._impl →
    let x_21 : obj := proj[0] x_2;
    let x_22 : obj := proj[1] x_2;
    let x_23 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_5 x_1 x_21 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    case x_23 : obj of
    EStateM.Result.ok →
      let x_24 : obj := proj[0] x_23;
      case x_24 : obj of
      Option.none →
        let x_25 : obj := proj[1] x_23;
        let x_71 : obj := reset[2] x_23;
        let x_26 : obj := ctor_0[Option.none];
        let x_27 : obj := reuse x_71 in ctor_0[EStateM.Result.ok] x_26 x_25;
        ret x_27
      Option.some →
        let x_28 : obj := proj[1] x_23;
        let x_29 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_5 x_1 x_22 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_28;
        ret x_29
    EStateM.Result.error →
      let x_30 : obj := proj[0] x_23;
      let x_31 : obj := proj[1] x_23;
      let x_73 : obj := reset[2] x_23;
      let x_32 : obj := reuse x_73 in ctor_1[EStateM.Result.error] x_30 x_31;
      ret x_32
  Lean.Expr.lam._impl →
    let x_33 : obj := proj[1] x_2;
    let x_34 : obj := proj[2] x_2;
    let x_35 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_5 x_1 x_33 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    case x_35 : obj of
    EStateM.Result.ok →
      let x_36 : obj := proj[0] x_35;
      case x_36 : obj of
      Option.none →
        let x_37 : obj := proj[1] x_35;
        let x_76 : obj := reset[2] x_35;
        let x_38 : obj := ctor_0[Option.none];
        let x_39 : obj := reuse x_76 in ctor_0[EStateM.Result.ok] x_38 x_37;
        ret x_39
      Option.some →
        let x_40 : obj := proj[1] x_35;
        let x_41 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_5 x_1 x_34 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_40;
        ret x_41
    EStateM.Result.error →
      let x_42 : obj := proj[0] x_35;
      let x_43 : obj := proj[1] x_35;
      let x_78 : obj := reset[2] x_35;
      let x_44 : obj := reuse x_78 in ctor_1[EStateM.Result.error] x_42 x_43;
      ret x_44
  Lean.Expr.forallE._impl →
    let x_45 : obj := proj[1] x_2;
    let x_46 : obj := proj[2] x_2;
    let x_47 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_5 x_1 x_45 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    case x_47 : obj of
    EStateM.Result.ok →
      let x_48 : obj := proj[0] x_47;
      case x_48 : obj of
      Option.none →
        let x_49 : obj := proj[1] x_47;
        let x_81 : obj := reset[2] x_47;
        let x_50 : obj := ctor_0[Option.none];
        let x_51 : obj := reuse x_81 in ctor_0[EStateM.Result.ok] x_50 x_49;
        ret x_51
      Option.some →
        let x_52 : obj := proj[1] x_47;
        let x_53 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_5 x_1 x_46 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_52;
        ret x_53
    EStateM.Result.error →
      let x_54 : obj := proj[0] x_47;
      let x_55 : obj := proj[1] x_47;
      let x_83 : obj := reset[2] x_47;
      let x_56 : obj := reuse x_83 in ctor_1[EStateM.Result.error] x_54 x_55;
      ret x_56
  Lean.Expr.letE._impl →
    let x_57 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at._private.miscompile.0.Lean.Compiler.LCNF.JoinPointFinder.removeCandidatesInArg._spec_2._closed_4;
    let x_58 : obj := panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_6 x_57 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    ret x_58
  Lean.Expr.lit._impl →
    let x_59 : obj := Lean.Compiler.LCNF.allFVarM.go._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_3._closed_1;
    let x_60 : obj := ctor_0[EStateM.Result.ok] x_59 x_10;
    ret x_60
  Lean.Expr.mdata._impl →
    let x_61 : obj := Lean.Compiler.LCNF.allFVarM.go._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_3._closed_1;
    let x_62 : obj := ctor_0[EStateM.Result.ok] x_61 x_10;
    ret x_62
  Lean.Expr.proj._impl →
    let x_63 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at._private.miscompile.0.Lean.Compiler.LCNF.JoinPointFinder.removeCandidatesInArg._spec_2._closed_4;
    let x_64 : obj := panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_6 x_63 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    ret x_64
def Lean.Compiler.LCNF.Arg.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_4 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) : obj :=
  case x_2 : obj of
  Lean.Compiler.LCNF.Arg.erased →
    let x_11 : obj := Lean.Compiler.LCNF.allFVarM.go._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_3._closed_1;
    let x_12 : obj := ctor_0[EStateM.Result.ok] x_11 x_10;
    ret x_12
  Lean.Compiler.LCNF.Arg.fvar →
    let x_13 : obj := proj[0] x_2;
    let x_14 : obj := app x_1 x_13 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    ret x_14
  Lean.Compiler.LCNF.Arg.type →
    let x_15 : obj := proj[0] x_2;
    let x_16 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_5 x_1 x_15 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    ret x_16
def Lean.Compiler.LCNF.allFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_2 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) : obj :=
  let x_11 : obj := pap Lean.Compiler.LCNF.allFVarM.go._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_3 x_1;
  let x_12 : obj := Lean.Compiler.LCNF.Arg.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_4 x_11 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
  case x_12 : obj of
  EStateM.Result.ok →
    let x_13 : obj := proj[0] x_12;
    case x_13 : obj of
    Option.none →
      let x_14 : obj := proj[1] x_12;
      let x_24 : obj := reset[2] x_12;
      let x_15 : u8 := 0;
      let x_16 : obj := reuse x_24 in ctor_0[EStateM.Result.ok] x_15 x_14;
      ret x_16
    Option.some →
      let x_17 : obj := proj[1] x_12;
      let x_25 : obj := reset[2] x_12;
      let x_18 : u8 := 1;
      let x_19 : obj := reuse x_25 in ctor_0[EStateM.Result.ok] x_18 x_17;
      ret x_19
  EStateM.Result.error →
    let x_20 : obj := proj[0] x_12;
    let x_21 : obj := proj[1] x_12;
    let x_26 : obj := reset[2] x_12;
    let x_22 : obj := reuse x_26 in ctor_1[EStateM.Result.error] x_20 x_21;
    ret x_22
def Lean.mkHashMap._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_7 (x_1 : obj) : obj :=
  let x_2 : obj := Lean.mkHashMapImp._rarg x_1;
  ret x_2
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_8 (x_1 : obj) (x_2 : obj) (x_3 : usize) (x_4 : usize) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) (x_11 : obj) (x_12 : obj) (x_13 : obj) : obj :=
  let x_14 : u8 := USize.decEq x_3 x_4;
  case x_14 : obj of
  Bool.false →
    let x_15 : obj := Array.uget ◾ x_2 x_3 ◾;
    case x_15 : obj of
    Prod.mk →
      let x_16 : obj := proj[0] x_15;
      let x_17 : obj := proj[1] x_15;
      let x_18 : obj := pap Lean.Compiler.LCNF.JoinPointCommonArgs.isInJpScope x_1;
      let x_19 : obj := Lean.Compiler.LCNF.allFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_2 x_18 x_17 x_6 x_7 x_8 x_9 x_10 x_11 x_12 x_13;
      case x_19 : obj of
      EStateM.Result.ok →
        let x_20 : obj := proj[0] x_19;
        case x_20 : obj of
        Bool.false →
          let x_21 : obj := proj[1] x_19;
          let x_22 : usize := 1;
          let x_23 : usize := USize.add x_3 x_22;
          let x_24 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_8 x_1 x_2 x_23 x_4 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12 x_21;
          ret x_24
        Bool.true →
          let x_25 : obj := proj[1] x_19;
          let x_26 : obj := proj[0] x_16;
          let x_27 : obj := Lean.Compiler.LCNF.Arg.toExpr x_17;
          let x_28 : obj := Lean.HashMap.insert._at.Lean.Compiler.LCNF.addFVarSubst._spec_1 x_5 x_26 x_27;
          let x_29 : usize := 1;
          let x_30 : usize := USize.add x_3 x_29;
          let x_31 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_8 x_1 x_2 x_30 x_4 x_28 x_6 x_7 x_8 x_9 x_10 x_11 x_12 x_25;
          ret x_31
      EStateM.Result.error →
        let x_32 : obj := proj[0] x_19;
        let x_33 : obj := proj[1] x_19;
        let x_38 : obj := reset[2] x_19;
        let x_34 : obj := reuse x_38 in ctor_1[EStateM.Result.error] x_32 x_33;
        ret x_34
  Bool.true →
    let x_35 : obj := ctor_0[EStateM.Result.ok] x_5 x_13;
    ret x_35
def Lean.AssocList.erase._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_10 (x_1 : obj) (x_2 : obj) : obj :=
  case x_2 : obj of
  Lean.AssocList.nil →
    let x_3 : obj := ctor_0[Lean.AssocList.nil];
    ret x_3
  Lean.AssocList.cons →
    let x_4 : obj := proj[0] x_2;
    let x_5 : obj := proj[1] x_2;
    let x_6 : obj := proj[2] x_2;
    let x_10 : obj := reset[3] x_2;
    let x_7 : u8 := Lean.Name.beq x_4 x_1;
    case x_7 : obj of
    Bool.false →
      let x_8 : obj := Lean.AssocList.erase._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_10 x_1 x_6;
      let x_9 : obj := reuse x_10 in ctor_1[Lean.AssocList.cons] x_4 x_5 x_8;
      ret x_9
    Bool.true →
      ret x_6
def Lean.HashMapImp.erase._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_9 (x_1 : obj) (x_2 : obj) : obj :=
  case x_1 : obj of
  Lean.HashMapImp.mk →
    let x_3 : obj := proj[0] x_1;
    let x_4 : obj := proj[1] x_1;
    let x_5 : obj := Array.size ◾ x_4;
    let x_6 : u64 := _private.Lean.Expr.0.Lean.hashFVarId._@.Lean.Expr._hyg.1674 x_2;
    let x_7 : usize := _private.Lean.Data.HashMap.0.Lean.HashMapImp.mkIdx x_5 x_6 ◾;
    let x_8 : obj := Array.uget ◾ x_4 x_7 ◾;
    let x_9 : u8 := Lean.AssocList.contains._at.Lean.Compiler.LCNF.addFVarSubst._spec_2 x_2 x_8;
    case x_9 : obj of
    Bool.false →
      ret x_1
    Bool.true →
      let x_15 : obj := reset[2] x_1;
      let x_10 : obj := 1;
      let x_11 : obj := Nat.sub x_3 x_10;
      let x_12 : obj := Lean.AssocList.erase._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_10 x_2 x_8;
      let x_13 : obj := Array.uset ◾ x_4 x_7 x_12 ◾;
      let x_14 : obj := reuse x_15 in ctor_0[Lean.HashMapImp.mk] x_11 x_13;
      ret x_14
def Array.forInUnsafe.loop._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_11 (x_1 : obj) (x_2 : usize) (x_3 : usize) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) (x_11 : obj) (x_12 : obj) : obj :=
  let x_13 : u8 := USize.decLt x_3 x_2;
  case x_13 : obj of
  Bool.false →
    let x_14 : obj := ctor_0[EStateM.Result.ok] x_4 x_12;
    ret x_14
  Bool.true →
    let x_15 : obj := Array.uget ◾ x_1 x_3 ◾;
    case x_15 : obj of
    Prod.mk →
      let x_16 : obj := proj[0] x_15;
      let x_17 : obj := proj[1] x_15;
      let x_18 : obj := proj[0] x_16;
      let x_19 : obj := Lean.HashMapImp.find?._at._private.Lean.Compiler.LCNF.CompilerM.0.Lean.Compiler.LCNF.normExprImp.go._spec_1 x_4 x_18;
      case x_19 : obj of
      Option.none →
        let x_20 : usize := 1;
        let x_21 : usize := USize.add x_3 x_20;
        let x_22 : obj := Array.forInUnsafe.loop._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_11 x_1 x_2 x_21 x_4 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12;
        ret x_22
      Option.some →
        let x_23 : obj := proj[0] x_19;
        let x_24 : obj := Lean.Compiler.LCNF.Arg.toExpr x_17;
        let x_25 : u8 := Lean.Expr.eqv x_24 x_23;
        case x_25 : obj of
        Bool.false →
          let x_26 : obj := Lean.HashMapImp.erase._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_9 x_4 x_18;
          let x_27 : usize := 1;
          let x_28 : usize := USize.add x_3 x_27;
          let x_29 : obj := Array.forInUnsafe.loop._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_11 x_1 x_2 x_28 x_26 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12;
          ret x_29
        Bool.true →
          let x_30 : usize := 1;
          let x_31 : usize := USize.add x_3 x_30;
          let x_32 : obj := Array.forInUnsafe.loop._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_11 x_1 x_2 x_31 x_4 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12;
          ret x_32
def Lean.Compiler.LCNF.ScopeM.withBackTrackingScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_13 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  let x_10 : obj := Lean.Compiler.LCNF.ScopeM.getScope x_4 x_5 x_6 x_7 x_8 x_9;
  case x_10 : obj of
  EStateM.Result.ok →
    let x_11 : obj := proj[0] x_10;
    let x_12 : obj := proj[1] x_10;
    let x_13 : obj := app x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_12;
    case x_13 : obj of
    EStateM.Result.ok →
      let x_14 : obj := proj[0] x_13;
      let x_15 : obj := proj[1] x_13;
      let x_16 : obj := Lean.Compiler.LCNF.ScopeM.setScope x_11 x_4 x_5 x_6 x_7 x_8 x_15;
      case x_16 : obj of
      EStateM.Result.ok →
        let x_17 : obj := proj[1] x_16;
        let x_24 : obj := reset[2] x_16;
        let x_18 : obj := reuse x_24 in ctor_0[EStateM.Result.ok] x_14 x_17;
        ret x_18
      EStateM.Result.error →
        ⊥
    EStateM.Result.error →
      let x_19 : obj := proj[0] x_13;
      let x_20 : obj := proj[1] x_13;
      let x_21 : obj := Lean.Compiler.LCNF.ScopeM.setScope x_11 x_4 x_5 x_6 x_7 x_8 x_20;
      case x_21 : obj of
      EStateM.Result.ok →
        let x_22 : obj := proj[1] x_21;
        let x_27 : obj := reset[2] x_21;
        let x_23 : obj := reuse! x_27 in ctor_1[EStateM.Result.error] x_19 x_22;
        ret x_23
      EStateM.Result.error →
        ⊥
  EStateM.Result.error →
    ⊥
def Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_12 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  let x_10 : obj := pap Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointFinder.find.go._spec_2._lambda_2 x_1;
  let x_11 : obj := Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointFinder.find.go._spec_2._closed_1;
  let x_12 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg x_11 x_10;
  let x_13 : obj := Lean.Compiler.LCNF.ScopeM.withBackTrackingScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_13 x_12 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
  ret x_13
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14._lambda_1 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) : obj :=
  let x_11 : obj := Lean.Compiler.LCNF.AltCore.getCode x_1;
  let x_12 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze x_11 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
  ret x_12
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14 (x_1 : obj) (x_2 : usize) (x_3 : usize) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) (x_11 : obj) (x_12 : obj) : obj :=
  let x_13 : u8 := USize.decEq x_2 x_3;
  case x_13 : obj of
  Bool.false →
    let x_14 : obj := Array.uget ◾ x_1 x_2 ◾;
    let x_15 : obj := Lean.Compiler.LCNF.AltCore.getParams x_14;
    let x_16 : obj := Array.size ◾ x_15;
    let x_17 : obj := 0;
    let x_18 : u8 := Nat.decLt x_17 x_16;
    let x_19 : obj := pap Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14._lambda_1 x_14;
    case x_18 : obj of
    Bool.false →
      let x_20 : obj := ctor_0[PUnit.unit];
      let x_21 : obj := pap ReaderT.pure._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_1._rarg x_20;
      let x_22 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg x_21 x_19;
      let x_23 : obj := Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_12 x_22 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12;
      case x_23 : obj of
      EStateM.Result.ok →
        let x_24 : obj := proj[0] x_23;
        let x_25 : obj := proj[1] x_23;
        let x_26 : usize := 1;
        let x_27 : usize := USize.add x_2 x_26;
        let x_28 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14 x_1 x_27 x_3 x_24 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_25;
        ret x_28
      EStateM.Result.error →
        let x_29 : obj := proj[0] x_23;
        let x_30 : obj := proj[1] x_23;
        let x_61 : obj := reset[2] x_23;
        let x_31 : obj := reuse x_61 in ctor_1[EStateM.Result.error] x_29 x_30;
        ret x_31
    Bool.true →
      let x_32 : u8 := Nat.decLe x_16 x_16;
      case x_32 : obj of
      Bool.false →
        let x_33 : obj := ctor_0[PUnit.unit];
        let x_34 : obj := pap ReaderT.pure._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_1._rarg x_33;
        let x_35 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg x_34 x_19;
        let x_36 : obj := Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_12 x_35 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12;
        case x_36 : obj of
        EStateM.Result.ok →
          let x_37 : obj := proj[0] x_36;
          let x_38 : obj := proj[1] x_36;
          let x_39 : usize := 1;
          let x_40 : usize := USize.add x_2 x_39;
          let x_41 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14 x_1 x_40 x_3 x_37 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_38;
          ret x_41
        EStateM.Result.error →
          let x_42 : obj := proj[0] x_36;
          let x_43 : obj := proj[1] x_36;
          let x_63 : obj := reset[2] x_36;
          let x_44 : obj := reuse x_63 in ctor_1[EStateM.Result.error] x_42 x_43;
          ret x_44
      Bool.true →
        let x_45 : usize := 0;
        let x_46 : usize := USize.ofNat x_16;
        let x_47 : obj := ctor_0[PUnit.unit];
        let x_48 : obj := pap Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_5 x_15 x_45 x_46 x_47;
        let x_49 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg x_48 x_19;
        let x_50 : obj := Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_12 x_49 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12;
        case x_50 : obj of
        EStateM.Result.ok →
          let x_51 : obj := proj[0] x_50;
          let x_52 : obj := proj[1] x_50;
          let x_53 : usize := 1;
          let x_54 : usize := USize.add x_2 x_53;
          let x_55 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14 x_1 x_54 x_3 x_51 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_52;
          ret x_55
        EStateM.Result.error →
          let x_56 : obj := proj[0] x_50;
          let x_57 : obj := proj[1] x_50;
          let x_65 : obj := reset[2] x_50;
          let x_58 : obj := reuse x_65 in ctor_1[EStateM.Result.error] x_56 x_57;
          ret x_58
  Bool.true →
    let x_59 : obj := ctor_0[EStateM.Result.ok] x_4 x_12;
    ret x_59
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  case x_1 : obj of
  Lean.Compiler.LCNF.Code.let →
    let x_10 : obj := proj[0] x_1;
    let x_11 : obj := proj[1] x_1;
    let x_12 : obj := proj[0] x_10;
    let x_13 : obj := Lean.Compiler.LCNF.ScopeM.addToScope x_12 x_4 x_5 x_6 x_7 x_8 x_9;
    case x_13 : obj of
    EStateM.Result.ok →
      let x_14 : obj := proj[1] x_13;
      let x_15 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze x_11 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_14;
      ret x_15
    EStateM.Result.error →
      ⊥
  Lean.Compiler.LCNF.Code.fun →
    let x_16 : obj := proj[0] x_1;
    let x_17 : obj := proj[1] x_1;
    let x_18 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl x_16 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
    case x_18 : obj of
    EStateM.Result.ok →
      let x_19 : obj := proj[1] x_18;
      let x_20 : obj := proj[0] x_16;
      let x_21 : obj := Lean.Compiler.LCNF.ScopeM.addToScope x_20 x_4 x_5 x_6 x_7 x_8 x_19;
      case x_21 : obj of
      EStateM.Result.ok →
        let x_22 : obj := proj[1] x_21;
        let x_23 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze x_17 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_22;
        ret x_23
      EStateM.Result.error →
        ⊥
    EStateM.Result.error →
      let x_24 : obj := proj[0] x_18;
      let x_25 : obj := proj[1] x_18;
      let x_135 : obj := reset[2] x_18;
      let x_26 : obj := reuse x_135 in ctor_1[EStateM.Result.error] x_24 x_25;
      ret x_26
  Lean.Compiler.LCNF.Code.jp →
    let x_27 : obj := proj[0] x_1;
    let x_28 : obj := proj[1] x_1;
    let x_29 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl x_27 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
    case x_29 : obj of
    EStateM.Result.ok →
      let x_30 : obj := proj[1] x_29;
      let x_31 : obj := Lean.Compiler.LCNF.ScopeM.getScope x_4 x_5 x_6 x_7 x_8 x_30;
      case x_31 : obj of
      EStateM.Result.ok →
        let x_32 : obj := proj[0] x_31;
        let x_33 : obj := proj[1] x_31;
        let x_34 : obj := proj[0] x_27;
        let x_35 : obj := Lean.RBNode.insert._at.Lean.FVarIdMap.insert._spec_1._rarg x_2 x_34 x_32;
        let x_36 : obj := Lean.Compiler.LCNF.ScopeM.addToScope x_34 x_4 x_5 x_6 x_7 x_8 x_33;
        case x_36 : obj of
        EStateM.Result.ok →
          let x_37 : obj := proj[1] x_36;
          let x_38 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze x_28 x_35 x_3 x_4 x_5 x_6 x_7 x_8 x_37;
          ret x_38
        EStateM.Result.error →
          ⊥
      EStateM.Result.error →
        ⊥
    EStateM.Result.error →
      let x_39 : obj := proj[0] x_29;
      let x_40 : obj := proj[1] x_29;
      let x_142 : obj := reset[2] x_29;
      let x_41 : obj := reuse x_142 in ctor_1[EStateM.Result.error] x_39 x_40;
      ret x_41
  Lean.Compiler.LCNF.Code.jmp →
    let x_42 : obj := proj[0] x_1;
    let x_43 : obj := proj[1] x_1;
    let x_44 : obj := Lean.Compiler.LCNF.getFunDecl x_42 x_5 x_6 x_7 x_8 x_9;
    case x_44 : obj of
    EStateM.Result.ok →
      let x_45 : obj := proj[0] x_44;
      let x_46 : obj := proj[1] x_44;
      let x_47 : obj := ST.Prim.Ref.get ◾ ◾ x_3 x_46;
      case x_47 : obj of
      EStateM.Result.ok →
        let x_48 : obj := proj[0] x_47;
        let x_49 : obj := proj[1] x_47;
        let x_50 : obj := Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1 x_48 x_42;
        case x_50 : obj of
        Option.none →
          let x_51 : obj := 8;
          let x_52 : obj := Lean.mkHashMapImp._rarg x_51;
          let x_53 : obj := proj[2] x_45;
          let x_54 : obj := Array.zip._rarg x_53 x_43;
          let x_55 : obj := Array.size ◾ x_54;
          let x_56 : obj := 0;
          let x_57 : u8 := Nat.decLt x_56 x_55;
          case x_57 : obj of
          Bool.false →
            let x_58 : obj := ST.Prim.Ref.take ◾ ◾ x_3 x_49;
            case x_58 : obj of
            EStateM.Result.ok →
              let x_59 : obj := proj[0] x_58;
              let x_60 : obj := proj[1] x_58;
              let x_61 : obj := Lean.RBNode.insert._at.Lean.FVarIdMap.insert._spec_1._rarg x_59 x_42 x_52;
              let x_62 : obj := ST.Prim.Ref.set ◾ ◾ x_3 x_61 x_60;
              case x_62 : obj of
              EStateM.Result.ok →
                let x_63 : obj := proj[1] x_62;
                let x_144 : obj := reset[2] x_62;
                let x_64 : obj := ctor_0[PUnit.unit];
                let x_65 : obj := reuse x_144 in ctor_0[EStateM.Result.ok] x_64 x_63;
                ret x_65
              EStateM.Result.error →
                ⊥
            EStateM.Result.error →
              ⊥
          Bool.true →
            let x_66 : u8 := Nat.decLe x_55 x_55;
            case x_66 : obj of
            Bool.false →
              let x_67 : obj := ST.Prim.Ref.take ◾ ◾ x_3 x_49;
              case x_67 : obj of
              EStateM.Result.ok →
                let x_68 : obj := proj[0] x_67;
                let x_69 : obj := proj[1] x_67;
                let x_70 : obj := Lean.RBNode.insert._at.Lean.FVarIdMap.insert._spec_1._rarg x_68 x_42 x_52;
                let x_71 : obj := ST.Prim.Ref.set ◾ ◾ x_3 x_70 x_69;
                case x_71 : obj of
                EStateM.Result.ok →
                  let x_72 : obj := proj[1] x_71;
                  let x_148 : obj := reset[2] x_71;
                  let x_73 : obj := ctor_0[PUnit.unit];
                  let x_74 : obj := reuse x_148 in ctor_0[EStateM.Result.ok] x_73 x_72;
                  ret x_74
                EStateM.Result.error →
                  ⊥
              EStateM.Result.error →
                ⊥
            Bool.true →
              let x_75 : usize := 0;
              let x_76 : usize := USize.ofNat x_55;
              let x_77 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_8 x_42 x_54 x_75 x_76 x_52 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_49;
              case x_77 : obj of
              EStateM.Result.ok →
                let x_78 : obj := proj[0] x_77;
                let x_79 : obj := proj[1] x_77;
                let x_80 : obj := ST.Prim.Ref.take ◾ ◾ x_3 x_79;
                case x_80 : obj of
                EStateM.Result.ok →
                  let x_81 : obj := proj[0] x_80;
                  let x_82 : obj := proj[1] x_80;
                  let x_83 : obj := Lean.RBNode.insert._at.Lean.FVarIdMap.insert._spec_1._rarg x_81 x_42 x_78;
                  let x_84 : obj := ST.Prim.Ref.set ◾ ◾ x_3 x_83 x_82;
                  case x_84 : obj of
                  EStateM.Result.ok →
                    let x_85 : obj := proj[1] x_84;
                    let x_152 : obj := reset[2] x_84;
                    let x_86 : obj := ctor_0[PUnit.unit];
                    let x_87 : obj := reuse x_152 in ctor_0[EStateM.Result.ok] x_86 x_85;
                    ret x_87
                  EStateM.Result.error →
                    ⊥
                EStateM.Result.error →
                  ⊥
              EStateM.Result.error →
                let x_88 : obj := proj[0] x_77;
                let x_89 : obj := proj[1] x_77;
                let x_157 : obj := reset[2] x_77;
                let x_90 : obj := reuse x_157 in ctor_1[EStateM.Result.error] x_88 x_89;
                ret x_90
        Option.some →
          let x_91 : obj := proj[0] x_50;
          let x_92 : obj := proj[2] x_45;
          let x_93 : obj := Array.zip._rarg x_92 x_43;
          let x_94 : obj := Array.size ◾ x_93;
          let x_95 : usize := USize.ofNat x_94;
          let x_96 : usize := 0;
          let x_97 : obj := Array.forInUnsafe.loop._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_11 x_93 x_95 x_96 x_91 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_49;
          case x_97 : obj of
          EStateM.Result.ok →
            let x_98 : obj := proj[0] x_97;
            let x_99 : obj := proj[1] x_97;
            let x_100 : obj := ST.Prim.Ref.take ◾ ◾ x_3 x_99;
            case x_100 : obj of
            EStateM.Result.ok →
              let x_101 : obj := proj[0] x_100;
              let x_102 : obj := proj[1] x_100;
              let x_103 : obj := Lean.RBNode.insert._at.Lean.FVarIdMap.insert._spec_1._rarg x_101 x_42 x_98;
              let x_104 : obj := ST.Prim.Ref.set ◾ ◾ x_3 x_103 x_102;
              case x_104 : obj of
              EStateM.Result.ok →
                let x_105 : obj := proj[1] x_104;
                let x_158 : obj := reset[2] x_104;
                let x_106 : obj := ctor_0[PUnit.unit];
                let x_107 : obj := reuse x_158 in ctor_0[EStateM.Result.ok] x_106 x_105;
                ret x_107
              EStateM.Result.error →
                ⊥
            EStateM.Result.error →
              ⊥
          EStateM.Result.error →
            ⊥
      EStateM.Result.error →
        ⊥
    EStateM.Result.error →
      let x_108 : obj := proj[0] x_44;
      let x_109 : obj := proj[1] x_44;
      let x_168 : obj := reset[2] x_44;
      let x_110 : obj := reuse x_168 in ctor_1[EStateM.Result.error] x_108 x_109;
      ret x_110
  Lean.Compiler.LCNF.Code.cases →
    let x_111 : obj := proj[0] x_1;
    let x_112 : obj := proj[3] x_111;
    let x_113 : obj := Array.size ◾ x_112;
    let x_114 : obj := 0;
    let x_115 : u8 := Nat.decLt x_114 x_113;
    case x_115 : obj of
    Bool.false →
      let x_116 : obj := ctor_0[PUnit.unit];
      let x_117 : obj := ctor_0[EStateM.Result.ok] x_116 x_9;
      ret x_117
    Bool.true →
      let x_118 : u8 := Nat.decLe x_113 x_113;
      case x_118 : obj of
      Bool.false →
        let x_119 : obj := ctor_0[PUnit.unit];
        let x_120 : obj := ctor_0[EStateM.Result.ok] x_119 x_9;
        ret x_120
      Bool.true →
        let x_121 : usize := 0;
        let x_122 : usize := USize.ofNat x_113;
        let x_123 : obj := ctor_0[PUnit.unit];
        let x_124 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14 x_112 x_121 x_122 x_123 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
        ret x_124
  Lean.Compiler.LCNF.Code.return →
    let x_125 : obj := ctor_0[PUnit.unit];
    let x_126 : obj := ctor_0[EStateM.Result.ok] x_125 x_9;
    ret x_126
  Lean.Compiler.LCNF.Code.unreach →
    let x_127 : obj := ctor_0[PUnit.unit];
    let x_128 : obj := ctor_0[EStateM.Result.ok] x_127 x_9;
    ret x_128
[reset_reuse]
def Lean.HashMapImp.contains._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_1 (x_1 : obj) (x_2 : obj) : u8 :=
  case x_1 : obj of
  Lean.HashMapImp.mk →
    let x_3 : obj := proj[1] x_1;
    let x_4 : obj := Array.size ◾ x_3;
    let x_5 : u64 := _private.Lean.Expr.0.Lean.hashFVarId._@.Lean.Expr._hyg.1674 x_2;
    let x_6 : usize := _private.Lean.Data.HashMap.0.Lean.HashMapImp.mkIdx x_4 x_5 ◾;
    let x_7 : obj := Array.uget ◾ x_3 x_6 ◾;
    let x_8 : u8 := Lean.AssocList.contains._at.Lean.Compiler.LCNF.addFVarSubst._spec_2 x_2 x_7;
    ret x_8
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2._lambda_1 (x_1 : u8) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) : obj :=
  case x_1 : obj of
  Bool.false →
    let x_9 : u8 := 1;
    let x_10 : obj := ctor_0[EStateM.Result.ok] x_9 x_8;
    ret x_10
  Bool.true →
    let x_11 : u8 := 0;
    let x_12 : obj := ctor_0[EStateM.Result.ok] x_11 x_8;
    ret x_12
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2 (x_1 : obj) (x_2 : obj) (x_3 : usize) (x_4 : usize) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) (x_11 : obj) : obj :=
  let x_12 : u8 := USize.decEq x_3 x_4;
  case x_12 : obj of
  Bool.false →
    let x_13 : obj := Array.uget ◾ x_2 x_3 ◾;
    let x_14 : obj := proj[0] x_13;
    let x_15 : u8 := Lean.HashMapImp.contains._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_1 x_1 x_14;
    case x_15 : obj of
    Bool.false →
      let x_16 : obj := ctor_0[PUnit.unit];
      let x_17 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2._lambda_1 x_15 x_16 x_6 x_7 x_8 x_9 x_10 x_11;
      case x_17 : obj of
      EStateM.Result.ok →
        let x_18 : obj := proj[0] x_17;
        case x_18 : obj of
        Bool.false →
          let x_19 : obj := proj[1] x_17;
          let x_20 : usize := 1;
          let x_21 : usize := USize.add x_3 x_20;
          let x_22 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2 x_1 x_2 x_21 x_4 x_5 x_6 x_7 x_8 x_9 x_10 x_19;
          ret x_22
        Bool.true →
          let x_23 : obj := proj[1] x_17;
          let x_24 : obj := Array.push ◾ x_5 x_13;
          let x_25 : usize := 1;
          let x_26 : usize := USize.add x_3 x_25;
          let x_27 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2 x_1 x_2 x_26 x_4 x_24 x_6 x_7 x_8 x_9 x_10 x_23;
          ret x_27
      EStateM.Result.error →
        ⊥
    Bool.true →
      let x_28 : obj := Lean.Compiler.LCNF.eraseParam x_13 x_7 x_8 x_9 x_10 x_11;
      case x_28 : obj of
      EStateM.Result.ok →
        let x_29 : obj := proj[0] x_28;
        let x_30 : obj := proj[1] x_28;
        let x_31 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2._lambda_1 x_15 x_29 x_6 x_7 x_8 x_9 x_10 x_30;
        case x_31 : obj of
        EStateM.Result.ok →
          let x_32 : obj := proj[0] x_31;
          case x_32 : obj of
          Bool.false →
            let x_33 : obj := proj[1] x_31;
            let x_34 : usize := 1;
            let x_35 : usize := USize.add x_3 x_34;
            let x_36 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2 x_1 x_2 x_35 x_4 x_5 x_6 x_7 x_8 x_9 x_10 x_33;
            ret x_36
          Bool.true →
            let x_37 : obj := proj[1] x_31;
            let x_38 : obj := Array.push ◾ x_5 x_13;
            let x_39 : usize := 1;
            let x_40 : usize := USize.add x_3 x_39;
            let x_41 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2 x_1 x_2 x_40 x_4 x_38 x_6 x_7 x_8 x_9 x_10 x_37;
            ret x_41
        EStateM.Result.error →
          ⊥
      EStateM.Result.error →
        ⊥
  Bool.true →
    let x_42 : obj := ctor_0[EStateM.Result.ok] x_5 x_11;
    ret x_42
def Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_3 (x_1 : usize) (x_2 : usize) (x_3 : obj) : obj :=
  let x_4 : u8 := USize.decLt x_2 x_1;
  case x_4 : obj of
  Bool.false →
    ret x_3
  Bool.true →
    let x_5 : obj := Array.uget ◾ x_3 x_2 ◾;
    let x_6 : obj := 0;
    let x_7 : obj := Array.uset ◾ x_3 x_2 x_6 ◾;
    let x_8 : obj := proj[1] x_5;
    let x_9 : usize := 1;
    let x_10 : usize := USize.add x_2 x_9;
    let x_11 : obj := Array.uset ◾ x_7 x_2 x_8 ◾;
    let x_12 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_3 x_1 x_10 x_11;
    ret x_12
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_4 (x_1 : obj) (x_2 : obj) (x_3 : usize) (x_4 : usize) (x_5 : obj) : obj :=
  let x_6 : u8 := USize.decEq x_3 x_4;
  case x_6 : obj of
  Bool.false →
    let x_7 : obj := Array.uget ◾ x_2 x_3 ◾;
    let x_8 : obj := proj[0] x_7;
    let x_9 : obj := proj[0] x_8;
    let x_10 : usize := 1;
    let x_11 : usize := USize.add x_3 x_10;
    let x_12 : u8 := Lean.HashMapImp.contains._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_1 x_1 x_9;
    case x_12 : obj of
    Bool.false →
      let x_13 : obj := Array.push ◾ x_5 x_7;
      let x_14 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_4 x_1 x_2 x_11 x_4 x_13;
      ret x_14
    Bool.true →
      let x_15 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_4 x_1 x_2 x_11 x_4 x_5;
      ret x_15
  Bool.true →
    ret x_5
def panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_5 (x_1 : obj) : obj :=
  let x_2 : obj := Lean.Compiler.LCNF.JoinPointFinder.find._closed_1;
  let x_3 : obj := panicCore ◾ x_2 x_1;
  ret x_3
def Lean.Compiler.LCNF.AltCore.mapCodeM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_6 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) : obj :=
  let x_9 : obj := Lean.Compiler.LCNF.AltCore.getCode x_1;
  let x_10 : obj := app x_2 x_9 x_3 x_4 x_5 x_6 x_7 x_8;
  case x_10 : obj of
  EStateM.Result.ok →
    let x_11 : obj := proj[0] x_10;
    let x_12 : obj := proj[1] x_10;
    let x_18 : obj := reset[2] x_10;
    let x_13 : obj := _private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltCodeImp x_1 x_11;
    let x_14 : obj := reuse x_18 in ctor_0[EStateM.Result.ok] x_13 x_12;
    ret x_14
  EStateM.Result.error →
    let x_15 : obj := proj[0] x_10;
    let x_16 : obj := proj[1] x_10;
    let x_19 : obj := reset[2] x_10;
    let x_17 : obj := reuse x_19 in ctor_1[EStateM.Result.error] x_15 x_16;
    ret x_17
def Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_7._closed_1 : obj :=
  let x_1 : obj := pap Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce;
  ret x_1
def Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_7 (x_1 : usize) (x_2 : usize) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  let x_10 : u8 := USize.decLt x_2 x_1;
  case x_10 : obj of
  Bool.false →
    let x_11 : obj := ctor_0[EStateM.Result.ok] x_3 x_9;
    ret x_11
  Bool.true →
    let x_12 : obj := Array.uget ◾ x_3 x_2 ◾;
    let x_13 : obj := 0;
    let x_14 : obj := Array.uset ◾ x_3 x_2 x_13 ◾;
    let x_15 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_7._closed_1;
    let x_16 : obj := Lean.Compiler.LCNF.AltCore.mapCodeM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_6 x_12 x_15 x_4 x_5 x_6 x_7 x_8 x_9;
    case x_16 : obj of
    EStateM.Result.ok →
      let x_17 : obj := proj[0] x_16;
      let x_18 : obj := proj[1] x_16;
      let x_19 : usize := 1;
      let x_20 : usize := USize.add x_2 x_19;
      let x_21 : obj := Array.uset ◾ x_14 x_2 x_17 ◾;
      let x_22 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_7 x_1 x_20 x_21 x_4 x_5 x_6 x_7 x_8 x_18;
      ret x_22
    EStateM.Result.error →
      let x_23 : obj := proj[0] x_16;
      let x_24 : obj := proj[1] x_16;
      let x_27 : obj := reset[2] x_16;
      let x_25 : obj := reuse x_27 in ctor_1[EStateM.Result.error] x_23 x_24;
      ret x_25
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) (x_11 : obj) (x_12 : obj) : obj :=
  let x_13 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_1 x_7 x_8 x_9 x_10 x_11 x_12;
  case x_13 : obj of
  EStateM.Result.ok →
    let x_14 : obj := proj[0] x_13;
    let x_15 : obj := proj[1] x_13;
    let x_16 : obj := _private.Lean.Compiler.LCNF.CompilerM.0.Lean.Compiler.LCNF.updateFunDeclImp x_2 x_6 x_3 x_4 x_8 x_9 x_10 x_11 x_15;
    case x_16 : obj of
    EStateM.Result.ok →
      let x_17 : obj := proj[0] x_16;
      let x_18 : obj := proj[1] x_16;
      let x_33 : obj := reset[2] x_16;
      let x_19 : usize := ptrAddrUnsafe ◾ x_1;
      let x_20 : usize := ptrAddrUnsafe ◾ x_14;
      let x_21 : u8 := USize.decEq x_19 x_20;
      case x_21 : obj of
      Bool.false →
        let x_22 : obj := ctor_2[Lean.Compiler.LCNF.Code.jp] x_17 x_14;
        let x_23 : obj := reuse x_33 in ctor_0[EStateM.Result.ok] x_22 x_18;
        ret x_23
      Bool.true →
        let x_24 : usize := ptrAddrUnsafe ◾ x_2;
        let x_25 : usize := ptrAddrUnsafe ◾ x_17;
        let x_26 : u8 := USize.decEq x_24 x_25;
        case x_26 : obj of
        Bool.false →
          let x_27 : obj := ctor_2[Lean.Compiler.LCNF.Code.jp] x_17 x_14;
          let x_28 : obj := reuse x_33 in ctor_0[EStateM.Result.ok] x_27 x_18;
          ret x_28
        Bool.true →
          let x_29 : obj := reuse x_33 in ctor_0[EStateM.Result.ok] x_5 x_18;
          ret x_29
    EStateM.Result.error →
      ⊥
  EStateM.Result.error →
    let x_30 : obj := proj[0] x_13;
    let x_31 : obj := proj[1] x_13;
    let x_36 : obj := reset[2] x_13;
    let x_32 : obj := reuse x_36 in ctor_1[EStateM.Result.error] x_30 x_31;
    ret x_32
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1 : obj :=
  let x_1 : obj := 0;
  let x_2 : obj := Array.mkEmpty ◾ x_1;
  ret x_2
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_2 : obj :=
  let x_1 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
  let x_2 : obj := Array.size ◾ x_1;
  ret x_2
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_3 : obj :=
  let x_1 : obj := "Lean.Compiler.LCNF.Basic";
  ret x_1
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_4 : obj :=
  let x_1 : obj := "_private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateJmpImp";
  ret x_1
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5 : obj :=
  let x_1 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_3;
  let x_2 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_4;
  let x_3 : obj := 318;
  let x_4 : obj := 9;
  let x_5 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at._private.miscompile.0.Lean.Compiler.LCNF.JoinPointFinder.removeCandidatesInArg._spec_2._closed_3;
  let x_6 : obj := _private.Init.Util.0.mkPanicMessageWithDecl x_1 x_2 x_3 x_4 x_5;
  ret x_6
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) : obj :=
  case x_1 : obj of
  Lean.Compiler.LCNF.Code.let →
    let x_8 : obj := proj[0] x_1;
    let x_9 : obj := proj[1] x_1;
    let x_10 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_9 x_2 x_3 x_4 x_5 x_6 x_7;
    case x_10 : obj of
    EStateM.Result.ok →
      let x_11 : obj := proj[0] x_10;
      let x_12 : obj := proj[1] x_10;
      let x_286 : obj := reset[2] x_10;
      let x_13 : usize := ptrAddrUnsafe ◾ x_9;
      let x_14 : usize := ptrAddrUnsafe ◾ x_11;
      let x_15 : u8 := USize.decEq x_13 x_14;
      case x_15 : obj of
      Bool.false →
        let x_288 : obj := reset[2] x_1;
        let x_16 : obj := reuse x_288 in ctor_0[Lean.Compiler.LCNF.Code.let] x_8 x_11;
        let x_17 : obj := reuse x_286 in ctor_0[EStateM.Result.ok] x_16 x_12;
        ret x_17
      Bool.true →
        let x_18 : usize := ptrAddrUnsafe ◾ x_8;
        let x_19 : u8 := USize.decEq x_18 x_18;
        case x_19 : obj of
        Bool.false →
          let x_289 : obj := reset[2] x_1;
          let x_20 : obj := reuse x_289 in ctor_0[Lean.Compiler.LCNF.Code.let] x_8 x_11;
          let x_21 : obj := reuse x_286 in ctor_0[EStateM.Result.ok] x_20 x_12;
          ret x_21
        Bool.true →
          let x_22 : obj := reuse x_286 in ctor_0[EStateM.Result.ok] x_1 x_12;
          ret x_22
    EStateM.Result.error →
      let x_23 : obj := proj[0] x_10;
      let x_24 : obj := proj[1] x_10;
      let x_287 : obj := reset[2] x_10;
      let x_25 : obj := reuse x_287 in ctor_1[EStateM.Result.error] x_23 x_24;
      ret x_25
  Lean.Compiler.LCNF.Code.fun →
    let x_26 : obj := proj[0] x_1;
    let x_27 : obj := proj[1] x_1;
    let x_28 : obj := proj[4] x_26;
    let x_29 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_28 x_2 x_3 x_4 x_5 x_6 x_7;
    case x_29 : obj of
    EStateM.Result.ok →
      let x_30 : obj := proj[0] x_29;
      let x_31 : obj := proj[1] x_29;
      let x_32 : obj := proj[3] x_26;
      let x_33 : obj := proj[2] x_26;
      let x_34 : obj := _private.Lean.Compiler.LCNF.CompilerM.0.Lean.Compiler.LCNF.updateFunDeclImp x_26 x_32 x_33 x_30 x_3 x_4 x_5 x_6 x_31;
      case x_34 : obj of
      EStateM.Result.ok →
        let x_35 : obj := proj[0] x_34;
        let x_36 : obj := proj[1] x_34;
        let x_37 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_27 x_2 x_3 x_4 x_5 x_6 x_36;
        case x_37 : obj of
        EStateM.Result.ok →
          let x_38 : obj := proj[0] x_37;
          let x_39 : obj := proj[1] x_37;
          let x_292 : obj := reset[2] x_37;
          let x_40 : usize := ptrAddrUnsafe ◾ x_27;
          let x_41 : usize := ptrAddrUnsafe ◾ x_38;
          let x_42 : u8 := USize.decEq x_40 x_41;
          case x_42 : obj of
          Bool.false →
            let x_298 : obj := reset[2] x_1;
            let x_43 : obj := reuse x_298 in ctor_1[Lean.Compiler.LCNF.Code.fun] x_35 x_38;
            let x_44 : obj := reuse x_292 in ctor_0[EStateM.Result.ok] x_43 x_39;
            ret x_44
          Bool.true →
            let x_45 : usize := ptrAddrUnsafe ◾ x_26;
            let x_46 : usize := ptrAddrUnsafe ◾ x_35;
            let x_47 : u8 := USize.decEq x_45 x_46;
            case x_47 : obj of
            Bool.false →
              let x_299 : obj := reset[2] x_1;
              let x_48 : obj := reuse x_299 in ctor_1[Lean.Compiler.LCNF.Code.fun] x_35 x_38;
              let x_49 : obj := reuse x_292 in ctor_0[EStateM.Result.ok] x_48 x_39;
              ret x_49
            Bool.true →
              let x_50 : obj := reuse x_292 in ctor_0[EStateM.Result.ok] x_1 x_39;
              ret x_50
        EStateM.Result.error →
          let x_51 : obj := proj[0] x_37;
          let x_52 : obj := proj[1] x_37;
          let x_293 : obj := reset[2] x_37;
          let x_53 : obj := reuse x_293 in ctor_1[EStateM.Result.error] x_51 x_52;
          ret x_53
      EStateM.Result.error →
        ⊥
    EStateM.Result.error →
      let x_54 : obj := proj[0] x_29;
      let x_55 : obj := proj[1] x_29;
      let x_297 : obj := reset[2] x_29;
      let x_56 : obj := reuse x_297 in ctor_1[EStateM.Result.error] x_54 x_55;
      ret x_56
  Lean.Compiler.LCNF.Code.jp →
    let x_57 : obj := proj[0] x_1;
    let x_58 : obj := proj[1] x_1;
    let x_59 : obj := proj[0] x_57;
    let x_60 : obj := Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1 x_2 x_59;
    case x_60 : obj of
    Option.none →
      let x_61 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_58 x_2 x_3 x_4 x_5 x_6 x_7;
      case x_61 : obj of
      EStateM.Result.ok →
        let x_62 : obj := proj[0] x_61;
        let x_63 : obj := proj[1] x_61;
        let x_304 : obj := reset[2] x_61;
        let x_64 : usize := ptrAddrUnsafe ◾ x_58;
        let x_65 : usize := ptrAddrUnsafe ◾ x_62;
        let x_66 : u8 := USize.decEq x_64 x_65;
        case x_66 : obj of
        Bool.false →
          let x_333 : obj := reset[2] x_1;
          let x_67 : obj := reuse x_333 in ctor_2[Lean.Compiler.LCNF.Code.jp] x_57 x_62;
          let x_68 : obj := reuse x_304 in ctor_0[EStateM.Result.ok] x_67 x_63;
          ret x_68
        Bool.true →
          let x_69 : usize := ptrAddrUnsafe ◾ x_57;
          let x_70 : u8 := USize.decEq x_69 x_69;
          case x_70 : obj of
          Bool.false →
            let x_334 : obj := reset[2] x_1;
            let x_71 : obj := reuse x_334 in ctor_2[Lean.Compiler.LCNF.Code.jp] x_57 x_62;
            let x_72 : obj := reuse x_304 in ctor_0[EStateM.Result.ok] x_71 x_63;
            ret x_72
          Bool.true →
            let x_73 : obj := reuse x_304 in ctor_0[EStateM.Result.ok] x_1 x_63;
            ret x_73
      EStateM.Result.error →
        let x_74 : obj := proj[0] x_61;
        let x_75 : obj := proj[1] x_61;
        let x_305 : obj := reset[2] x_61;
        let x_76 : obj := reuse x_305 in ctor_1[EStateM.Result.error] x_74 x_75;
        ret x_76
    Option.some →
      let x_77 : obj := proj[0] x_60;
      let x_78 : obj := proj[2] x_57;
      let x_79 : obj := Array.size ◾ x_78;
      let x_80 : obj := 0;
      let x_81 : u8 := Nat.decLt x_80 x_79;
      case x_81 : obj of
      Bool.false →
        let x_82 : obj := proj[4] x_57;
        let x_83 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_82 x_2 x_3 x_4 x_5 x_6 x_7;
        case x_83 : obj of
        EStateM.Result.ok →
          let x_84 : obj := proj[0] x_83;
          let x_85 : obj := proj[1] x_83;
          let x_86 : u8 := 0;
          let x_87 : obj := Lean.Compiler.LCNF.normCodeImp x_86 x_84 x_77 x_3 x_4 x_5 x_6 x_85;
          case x_87 : obj of
          EStateM.Result.ok →
            let x_88 : obj := proj[0] x_87;
            let x_89 : obj := proj[1] x_87;
            let x_90 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_2;
            let x_91 : u8 := Nat.beq x_90 x_79;
            case x_91 : obj of
            Bool.false →
              let x_92 : obj := Lean.Compiler.LCNF.Code.inferType x_88 x_3 x_4 x_5 x_6 x_89;
              case x_92 : obj of
              EStateM.Result.ok →
                let x_93 : obj := proj[0] x_92;
                let x_94 : obj := proj[1] x_92;
                let x_95 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
                let x_96 : obj := Lean.Compiler.LCNF.mkForallParams x_95 x_93 x_3 x_4 x_5 x_6 x_94;
                case x_96 : obj of
                EStateM.Result.ok →
                  let x_97 : obj := proj[0] x_96;
                  let x_98 : obj := proj[1] x_96;
                  let x_99 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_58 x_57 x_95 x_88 x_1 x_97 x_2 x_3 x_4 x_5 x_6 x_98;
                  ret x_99
                EStateM.Result.error →
                  let x_100 : obj := proj[0] x_96;
                  let x_101 : obj := proj[1] x_96;
                  let x_307 : obj := reset[2] x_96;
                  let x_102 : obj := reuse x_307 in ctor_1[EStateM.Result.error] x_100 x_101;
                  ret x_102
              EStateM.Result.error →
                let x_103 : obj := proj[0] x_92;
                let x_104 : obj := proj[1] x_92;
                let x_309 : obj := reset[2] x_92;
                let x_105 : obj := reuse x_309 in ctor_1[EStateM.Result.error] x_103 x_104;
                ret x_105
            Bool.true →
              let x_106 : obj := proj[3] x_57;
              let x_107 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
              let x_108 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_58 x_57 x_107 x_88 x_1 x_106 x_2 x_3 x_4 x_5 x_6 x_89;
              ret x_108
          EStateM.Result.error →
            let x_109 : obj := proj[0] x_87;
            let x_110 : obj := proj[1] x_87;
            let x_311 : obj := reset[2] x_87;
            let x_111 : obj := reuse x_311 in ctor_1[EStateM.Result.error] x_109 x_110;
            ret x_111
        EStateM.Result.error →
          let x_112 : obj := proj[0] x_83;
          let x_113 : obj := proj[1] x_83;
          let x_313 : obj := reset[2] x_83;
          let x_114 : obj := reuse x_313 in ctor_1[EStateM.Result.error] x_112 x_113;
          ret x_114
      Bool.true →
        let x_115 : u8 := Nat.decLe x_79 x_79;
        case x_115 : obj of
        Bool.false →
          let x_116 : obj := proj[4] x_57;
          let x_117 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_116 x_2 x_3 x_4 x_5 x_6 x_7;
          case x_117 : obj of
          EStateM.Result.ok →
            let x_118 : obj := proj[0] x_117;
            let x_119 : obj := proj[1] x_117;
            let x_120 : u8 := 0;
            let x_121 : obj := Lean.Compiler.LCNF.normCodeImp x_120 x_118 x_77 x_3 x_4 x_5 x_6 x_119;
            case x_121 : obj of
            EStateM.Result.ok →
              let x_122 : obj := proj[0] x_121;
              let x_123 : obj := proj[1] x_121;
              let x_124 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_2;
              let x_125 : u8 := Nat.beq x_124 x_79;
              case x_125 : obj of
              Bool.false →
                let x_126 : obj := Lean.Compiler.LCNF.Code.inferType x_122 x_3 x_4 x_5 x_6 x_123;
                case x_126 : obj of
                EStateM.Result.ok →
                  let x_127 : obj := proj[0] x_126;
                  let x_128 : obj := proj[1] x_126;
                  let x_129 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
                  let x_130 : obj := Lean.Compiler.LCNF.mkForallParams x_129 x_127 x_3 x_4 x_5 x_6 x_128;
                  case x_130 : obj of
                  EStateM.Result.ok →
                    let x_131 : obj := proj[0] x_130;
                    let x_132 : obj := proj[1] x_130;
                    let x_133 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_58 x_57 x_129 x_122 x_1 x_131 x_2 x_3 x_4 x_5 x_6 x_132;
                    ret x_133
                  EStateM.Result.error →
                    let x_134 : obj := proj[0] x_130;
                    let x_135 : obj := proj[1] x_130;
                    let x_315 : obj := reset[2] x_130;
                    let x_136 : obj := reuse x_315 in ctor_1[EStateM.Result.error] x_134 x_135;
                    ret x_136
                EStateM.Result.error →
                  let x_137 : obj := proj[0] x_126;
                  let x_138 : obj := proj[1] x_126;
                  let x_317 : obj := reset[2] x_126;
                  let x_139 : obj := reuse x_317 in ctor_1[EStateM.Result.error] x_137 x_138;
                  ret x_139
              Bool.true →
                let x_140 : obj := proj[3] x_57;
                let x_141 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
                let x_142 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_58 x_57 x_141 x_122 x_1 x_140 x_2 x_3 x_4 x_5 x_6 x_123;
                ret x_142
            EStateM.Result.error →
              let x_143 : obj := proj[0] x_121;
              let x_144 : obj := proj[1] x_121;
              let x_319 : obj := reset[2] x_121;
              let x_145 : obj := reuse x_319 in ctor_1[EStateM.Result.error] x_143 x_144;
              ret x_145
          EStateM.Result.error →
            let x_146 : obj := proj[0] x_117;
            let x_147 : obj := proj[1] x_117;
            let x_321 : obj := reset[2] x_117;
            let x_148 : obj := reuse x_321 in ctor_1[EStateM.Result.error] x_146 x_147;
            ret x_148
        Bool.true →
          let x_149 : usize := 0;
          let x_150 : usize := USize.ofNat x_79;
          let x_151 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
          let x_152 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2 x_77 x_78 x_149 x_150 x_151 x_2 x_3 x_4 x_5 x_6 x_7;
          case x_152 : obj of
          EStateM.Result.ok →
            let x_153 : obj := proj[0] x_152;
            let x_154 : obj := proj[1] x_152;
            let x_155 : obj := proj[4] x_57;
            let x_156 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_155 x_2 x_3 x_4 x_5 x_6 x_154;
            case x_156 : obj of
            EStateM.Result.ok →
              let x_157 : obj := proj[0] x_156;
              let x_158 : obj := proj[1] x_156;
              let x_159 : u8 := 0;
              let x_160 : obj := Lean.Compiler.LCNF.normCodeImp x_159 x_157 x_77 x_3 x_4 x_5 x_6 x_158;
              case x_160 : obj of
              EStateM.Result.ok →
                let x_161 : obj := proj[0] x_160;
                let x_162 : obj := proj[1] x_160;
                let x_163 : obj := Array.size ◾ x_153;
                let x_164 : u8 := Nat.beq x_163 x_79;
                case x_164 : obj of
                Bool.false →
                  let x_165 : obj := Lean.Compiler.LCNF.Code.inferType x_161 x_3 x_4 x_5 x_6 x_162;
                  case x_165 : obj of
                  EStateM.Result.ok →
                    let x_166 : obj := proj[0] x_165;
                    let x_167 : obj := proj[1] x_165;
                    let x_168 : obj := Lean.Compiler.LCNF.mkForallParams x_153 x_166 x_3 x_4 x_5 x_6 x_167;
                    case x_168 : obj of
                    EStateM.Result.ok →
                      let x_169 : obj := proj[0] x_168;
                      let x_170 : obj := proj[1] x_168;
                      let x_171 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_58 x_57 x_153 x_161 x_1 x_169 x_2 x_3 x_4 x_5 x_6 x_170;
                      ret x_171
                    EStateM.Result.error →
                      let x_172 : obj := proj[0] x_168;
                      let x_173 : obj := proj[1] x_168;
                      let x_323 : obj := reset[2] x_168;
                      let x_174 : obj := reuse x_323 in ctor_1[EStateM.Result.error] x_172 x_173;
                      ret x_174
                  EStateM.Result.error →
                    let x_175 : obj := proj[0] x_165;
                    let x_176 : obj := proj[1] x_165;
                    let x_325 : obj := reset[2] x_165;
                    let x_177 : obj := reuse x_325 in ctor_1[EStateM.Result.error] x_175 x_176;
                    ret x_177
                Bool.true →
                  let x_178 : obj := proj[3] x_57;
                  let x_179 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_58 x_57 x_153 x_161 x_1 x_178 x_2 x_3 x_4 x_5 x_6 x_162;
                  ret x_179
              EStateM.Result.error →
                let x_180 : obj := proj[0] x_160;
                let x_181 : obj := proj[1] x_160;
                let x_327 : obj := reset[2] x_160;
                let x_182 : obj := reuse x_327 in ctor_1[EStateM.Result.error] x_180 x_181;
                ret x_182
            EStateM.Result.error →
              let x_183 : obj := proj[0] x_156;
              let x_184 : obj := proj[1] x_156;
              let x_329 : obj := reset[2] x_156;
              let x_185 : obj := reuse x_329 in ctor_1[EStateM.Result.error] x_183 x_184;
              ret x_185
          EStateM.Result.error →
            ⊥
  Lean.Compiler.LCNF.Code.jmp →
    let x_186 : obj := proj[0] x_1;
    let x_187 : obj := proj[1] x_1;
    block_238 (x_188 : obj) (x_189 : obj) (x_190 : obj) :=
      block_225 (x_191 : obj) :=
        case x_1 : obj of
        Lean.Compiler.LCNF.Code.let →
          let x_192 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5;
          let x_193 : obj := panic._at._private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltsImp._spec_1 x_192;
          let x_194 : obj := ctor_0[EStateM.Result.ok] x_193 x_190;
          ret x_194
        Lean.Compiler.LCNF.Code.fun →
          let x_195 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5;
          let x_196 : obj := panic._at._private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltsImp._spec_1 x_195;
          let x_197 : obj := ctor_0[EStateM.Result.ok] x_196 x_190;
          ret x_197
        Lean.Compiler.LCNF.Code.jp →
          let x_198 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5;
          let x_199 : obj := panic._at._private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltsImp._spec_1 x_198;
          let x_200 : obj := ctor_0[EStateM.Result.ok] x_199 x_190;
          ret x_200
        Lean.Compiler.LCNF.Code.jmp →
          let x_201 : obj := proj[0] x_1;
          let x_202 : obj := proj[1] x_1;
          let x_203 : obj := Array.size ◾ x_191;
          let x_204 : usize := USize.ofNat x_203;
          let x_205 : usize := 0;
          let x_206 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_3 x_204 x_205 x_191;
          let x_207 : u8 := Lean.Name.beq x_201 x_186;
          case x_207 : obj of
          Bool.false →
            let x_359 : obj := reset[2] x_1;
            let x_208 : obj := reuse x_359 in ctor_3[Lean.Compiler.LCNF.Code.jmp] x_186 x_206;
            let x_209 : obj := ctor_0[EStateM.Result.ok] x_208 x_190;
            ret x_209
          Bool.true →
            let x_210 : usize := ptrAddrUnsafe ◾ x_202;
            let x_211 : usize := ptrAddrUnsafe ◾ x_206;
            let x_212 : u8 := USize.decEq x_210 x_211;
            case x_212 : obj of
            Bool.false →
              let x_360 : obj := reset[2] x_1;
              let x_213 : obj := reuse x_360 in ctor_3[Lean.Compiler.LCNF.Code.jmp] x_186 x_206;
              let x_214 : obj := ctor_0[EStateM.Result.ok] x_213 x_190;
              ret x_214
            Bool.true →
              let x_215 : obj := ctor_0[EStateM.Result.ok] x_1 x_190;
              ret x_215
        Lean.Compiler.LCNF.Code.cases →
          let x_216 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5;
          let x_217 : obj := panic._at._private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltsImp._spec_1 x_216;
          let x_218 : obj := ctor_0[EStateM.Result.ok] x_217 x_190;
          ret x_218
        Lean.Compiler.LCNF.Code.return →
          let x_219 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5;
          let x_220 : obj := panic._at._private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltsImp._spec_1 x_219;
          let x_221 : obj := ctor_0[EStateM.Result.ok] x_220 x_190;
          ret x_221
        Lean.Compiler.LCNF.Code.unreach →
          let x_222 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5;
          let x_223 : obj := panic._at._private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltsImp._spec_1 x_222;
          let x_224 : obj := ctor_0[EStateM.Result.ok] x_223 x_190;
          ret x_224;
      let x_226 : obj := proj[2] x_189;
      let x_227 : obj := Array.zip._rarg x_226 x_187;
      let x_228 : obj := Array.size ◾ x_227;
      let x_229 : obj := 0;
      let x_230 : u8 := Nat.decLt x_229 x_228;
      case x_230 : obj of
      Bool.false →
        let x_231 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
        jmp block_225 x_231
      Bool.true →
        let x_232 : u8 := Nat.decLe x_228 x_228;
        case x_232 : obj of
        Bool.false →
          let x_233 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
          jmp block_225 x_233
        Bool.true →
          let x_234 : usize := 0;
          let x_235 : usize := USize.ofNat x_228;
          let x_236 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
          let x_237 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_4 x_188 x_227 x_234 x_235 x_236;
          jmp block_225 x_237;
    let x_239 : obj := Lean.Compiler.LCNF.getFunDecl x_186 x_3 x_4 x_5 x_6 x_7;
    let x_240 : obj := Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1 x_2 x_186;
    case x_240 : obj of
    Option.none →
      case x_239 : obj of
      EStateM.Result.ok →
        let x_241 : obj := proj[0] x_239;
        let x_242 : obj := proj[1] x_239;
        let x_243 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.isInJpScope._closed_3;
        let x_244 : obj := panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_5 x_243;
        jmp block_238 x_244 x_241 x_242
      EStateM.Result.error →
        let x_245 : obj := proj[0] x_239;
        let x_246 : obj := proj[1] x_239;
        let x_365 : obj := reset[2] x_239;
        let x_247 : obj := reuse x_365 in ctor_1[EStateM.Result.error] x_245 x_246;
        ret x_247
    Option.some →
      case x_239 : obj of
      EStateM.Result.ok →
        let x_248 : obj := proj[0] x_240;
        let x_249 : obj := proj[0] x_239;
        let x_250 : obj := proj[1] x_239;
        jmp block_238 x_248 x_249 x_250
      EStateM.Result.error →
        let x_251 : obj := proj[0] x_239;
        let x_252 : obj := proj[1] x_239;
        let x_367 : obj := reset[2] x_239;
        let x_253 : obj := reuse x_367 in ctor_1[EStateM.Result.error] x_251 x_252;
        ret x_253
  Lean.Compiler.LCNF.Code.cases →
    let x_254 : obj := proj[0] x_1;
    case x_254 : obj of
    Lean.Compiler.LCNF.CasesCore.mk →
      let x_255 : obj := proj[0] x_254;
      let x_256 : obj := proj[1] x_254;
      let x_257 : obj := proj[2] x_254;
      let x_258 : obj := proj[3] x_254;
      let x_382 : obj := reset[4] x_254;
      let x_259 : obj := Array.size ◾ x_258;
      let x_260 : usize := USize.ofNat x_259;
      let x_261 : usize := 0;
      let x_262 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_7 x_260 x_261 x_258 x_2 x_3 x_4 x_5 x_6 x_7;
      case x_262 : obj of
      EStateM.Result.ok →
        let x_263 : obj := proj[0] x_262;
        let x_264 : obj := proj[1] x_262;
        let x_380 : obj := reset[2] x_262;
        let x_265 : usize := ptrAddrUnsafe ◾ x_258;
        let x_266 : usize := ptrAddrUnsafe ◾ x_263;
        let x_267 : u8 := USize.decEq x_265 x_266;
        case x_267 : obj of
        Bool.false →
          let x_383 : obj := reset[1] x_1;
          let x_268 : obj := reuse x_382 in ctor_0[Lean.Compiler.LCNF.CasesCore.mk] x_255 x_256 x_257 x_263;
          let x_269 : obj := reuse x_383 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_268;
          let x_270 : obj := reuse x_380 in ctor_0[EStateM.Result.ok] x_269 x_264;
          ret x_270
        Bool.true →
          let x_271 : usize := ptrAddrUnsafe ◾ x_256;
          let x_272 : u8 := USize.decEq x_271 x_271;
          case x_272 : obj of
          Bool.false →
            let x_384 : obj := reset[1] x_1;
            let x_273 : obj := reuse x_382 in ctor_0[Lean.Compiler.LCNF.CasesCore.mk] x_255 x_256 x_257 x_263;
            let x_274 : obj := reuse x_384 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_273;
            let x_275 : obj := reuse x_380 in ctor_0[EStateM.Result.ok] x_274 x_264;
            ret x_275
          Bool.true →
            let x_276 : u8 := Lean.Name.beq x_257 x_257;
            case x_276 : obj of
            Bool.false →
              let x_385 : obj := reset[1] x_1;
              let x_277 : obj := reuse x_382 in ctor_0[Lean.Compiler.LCNF.CasesCore.mk] x_255 x_256 x_257 x_263;
              let x_278 : obj := reuse x_385 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_277;
              let x_279 : obj := reuse x_380 in ctor_0[EStateM.Result.ok] x_278 x_264;
              ret x_279
            Bool.true →
              let x_280 : obj := reuse x_380 in ctor_0[EStateM.Result.ok] x_1 x_264;
              ret x_280
      EStateM.Result.error →
        let x_281 : obj := proj[0] x_262;
        let x_282 : obj := proj[1] x_262;
        let x_381 : obj := reset[2] x_262;
        let x_283 : obj := reuse x_381 in ctor_1[EStateM.Result.error] x_281 x_282;
        ret x_283
  Lean.Compiler.LCNF.Code.return →
    let x_284 : obj := ctor_0[EStateM.Result.ok] x_1 x_7;
    ret x_284
  Lean.Compiler.LCNF.Code.unreach →
    let x_285 : obj := ctor_0[EStateM.Result.ok] x_1 x_7;
    ret x_285
[reset_reuse]
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) : obj :=
  case x_1 : obj of
  Lean.Compiler.LCNF.Decl.mk →
    let x_7 : obj := proj[0] x_1;
    let x_8 : obj := proj[1] x_1;
    let x_9 : obj := proj[2] x_1;
    let x_10 : obj := proj[3] x_1;
    let x_11 : obj := proj[4] x_1;
    let x_12 : u8 := sproj[6, 0] x_1;
    let x_13 : u8 := sproj[6, 1] x_1;
    let x_14 : obj := proj[5] x_1;
    let x_52 : obj := reset[6] x_1;
    let x_15 : obj := ctor_0[Lean.RBNode.leaf];
    let x_16 : obj := ST.Prim.mkRef ◾ ◾ x_15 x_6;
    case x_16 : obj of
    EStateM.Result.ok →
      let x_17 : obj := proj[0] x_16;
      let x_18 : obj := proj[1] x_16;
      let x_19 : obj := ST.Prim.mkRef ◾ ◾ x_15 x_18;
      case x_19 : obj of
      EStateM.Result.ok →
        let x_20 : obj := proj[0] x_19;
        let x_21 : obj := proj[1] x_19;
        let x_22 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze x_11 x_15 x_20 x_17 x_2 x_3 x_4 x_5 x_21;
        case x_22 : obj of
        EStateM.Result.ok →
          let x_23 : obj := proj[1] x_22;
          let x_24 : obj := ST.Prim.Ref.get ◾ ◾ x_20 x_23;
          case x_24 : obj of
          EStateM.Result.ok →
            let x_25 : obj := proj[0] x_24;
            let x_26 : obj := proj[1] x_24;
            let x_27 : obj := ST.Prim.Ref.get ◾ ◾ x_17 x_26;
            case x_27 : obj of
            EStateM.Result.ok →
              let x_28 : obj := proj[1] x_27;
              let x_29 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_11 x_25 x_2 x_3 x_4 x_5 x_28;
              case x_29 : obj of
              EStateM.Result.ok →
                let x_30 : obj := proj[0] x_29;
                let x_31 : obj := proj[1] x_29;
                let x_40 : obj := reset[2] x_29;
                let x_32 : obj := reuse x_52 in ctor_0.0.2[Lean.Compiler.LCNF.Decl.mk] x_7 x_8 x_9 x_10 x_30 x_14;
                sset x_32[6, 0] : u8 := x_12;
                sset x_32[6, 1] : u8 := x_13;
                let x_33 : obj := reuse x_40 in ctor_0[EStateM.Result.ok] x_32 x_31;
                ret x_33
              EStateM.Result.error →
                let x_34 : obj := proj[0] x_29;
                let x_35 : obj := proj[1] x_29;
                let x_41 : obj := reset[2] x_29;
                let x_36 : obj := reuse x_41 in ctor_1[EStateM.Result.error] x_34 x_35;
                ret x_36
            EStateM.Result.error →
              ⊥
          EStateM.Result.error →
            ⊥
        EStateM.Result.error →
          let x_37 : obj := proj[0] x_22;
          let x_38 : obj := proj[1] x_22;
          let x_47 : obj := reset[2] x_22;
          let x_39 : obj := reuse x_47 in ctor_1[EStateM.Result.error] x_37 x_38;
          ret x_39
      EStateM.Result.error →
        ⊥
    EStateM.Result.error →
      ⊥