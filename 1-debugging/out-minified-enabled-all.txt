def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) : obj :=
  case x_1 : obj of
  Lean.Compiler.LCNF.Code.let →
    let x_8 : obj := proj[0] x_1;
    let x_9 : obj := proj[1] x_1;
    let x_10 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_9 x_2 x_3 x_4 x_5 x_6 x_7;
    case x_10 : obj of
    EStateM.Result.ok →
      let x_11 : obj := proj[0] x_10;
      let x_12 : obj := proj[1] x_10;
      let x_286 : obj := reset[2] x_10;
      let x_13 : usize := ptrAddrUnsafe ◾ x_9;
      let x_14 : usize := ptrAddrUnsafe ◾ x_11;
      let x_15 : u8 := USize.decEq x_13 x_14;
      case x_15 : obj of
      Bool.false →
        let x_288 : obj := reset[2] x_1;
        let x_16 : obj := reuse x_286 in ctor_0[Lean.Compiler.LCNF.Code.let] x_8 x_11;
        let x_17 : obj := reuse x_288 in ctor_0[EStateM.Result.ok] x_16 x_12;
        ret x_17
      Bool.true →
        let x_18 : usize := ptrAddrUnsafe ◾ x_8;
        let x_19 : u8 := USize.decEq x_18 x_18;
        case x_19 : obj of
        Bool.false →
          let x_289 : obj := reset[2] x_1;
          let x_20 : obj := reuse x_286 in ctor_0[Lean.Compiler.LCNF.Code.let] x_8 x_11;
          let x_21 : obj := reuse x_289 in ctor_0[EStateM.Result.ok] x_20 x_12;
          ret x_21
        Bool.true →
          let x_22 : obj := reuse x_286 in ctor_0[EStateM.Result.ok] x_1 x_12;
          ret x_22
    EStateM.Result.error →
      let x_23 : obj := proj[0] x_10;
      let x_24 : obj := proj[1] x_10;
      let x_287 : obj := reset[2] x_10;
      let x_25 : obj := reuse x_287 in ctor_1[EStateM.Result.error] x_23 x_24;
      ret x_25
  Lean.Compiler.LCNF.Code.fun →
    let x_26 : obj := proj[0] x_1;
    let x_27 : obj := proj[1] x_1;
    let x_28 : obj := proj[4] x_26;
    let x_29 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_28 x_2 x_3 x_4 x_5 x_6 x_7;
    case x_29 : obj of
    EStateM.Result.ok →
      let x_30 : obj := proj[0] x_29;
      let x_31 : obj := proj[1] x_29;
      let x_32 : obj := proj[3] x_26;
      let x_33 : obj := proj[2] x_26;
      let x_34 : obj := _private.Lean.Compiler.LCNF.CompilerM.0.Lean.Compiler.LCNF.updateFunDeclImp x_26 x_32 x_33 x_30 x_3 x_4 x_5 x_6 x_31;
      case x_34 : obj of
      EStateM.Result.ok →
        let x_35 : obj := proj[0] x_34;
        let x_36 : obj := proj[1] x_34;
        let x_294 : obj := reset[2] x_34;
        let x_37 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_27 x_2 x_3 x_4 x_5 x_6 x_36;
        case x_37 : obj of
        EStateM.Result.ok →
          let x_38 : obj := proj[0] x_37;
          let x_39 : obj := proj[1] x_37;
          let x_292 : obj := reset[2] x_37;
          let x_40 : usize := ptrAddrUnsafe ◾ x_27;
          let x_41 : usize := ptrAddrUnsafe ◾ x_38;
          let x_42 : u8 := USize.decEq x_40 x_41;
          case x_42 : obj of
          Bool.false →
            let x_43 : obj := reuse! x_292 in ctor_1[Lean.Compiler.LCNF.Code.fun] x_35 x_38;
            let x_44 : obj := reuse x_294 in ctor_0[EStateM.Result.ok] x_43 x_39;
            ret x_44
          Bool.true →
            let x_45 : usize := ptrAddrUnsafe ◾ x_26;
            let x_46 : usize := ptrAddrUnsafe ◾ x_35;
            let x_47 : u8 := USize.decEq x_45 x_46;
            case x_47 : obj of
            Bool.false →
              let x_48 : obj := reuse! x_292 in ctor_1[Lean.Compiler.LCNF.Code.fun] x_35 x_38;
              let x_49 : obj := reuse x_294 in ctor_0[EStateM.Result.ok] x_48 x_39;
              ret x_49
            Bool.true →
              let x_50 : obj := reuse x_292 in ctor_0[EStateM.Result.ok] x_1 x_39;
              ret x_50
        EStateM.Result.error →
          let x_51 : obj := proj[0] x_37;
          let x_52 : obj := proj[1] x_37;
          let x_293 : obj := reset[2] x_37;
          let x_53 : obj := reuse x_293 in ctor_1[EStateM.Result.error] x_51 x_52;
          ret x_53
      EStateM.Result.error →
        ⊥
    EStateM.Result.error →
      let x_54 : obj := proj[0] x_29;
      let x_55 : obj := proj[1] x_29;
      let x_297 : obj := reset[2] x_29;
      let x_56 : obj := reuse x_297 in ctor_1[EStateM.Result.error] x_54 x_55;
      ret x_56
  Lean.Compiler.LCNF.Code.jp →
    let x_57 : obj := proj[0] x_1;
    let x_58 : obj := proj[1] x_1;
    let x_59 : obj := proj[0] x_57;
    let x_60 : obj := Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1 x_2 x_59;
    case x_60 : obj of
    Option.none →
      let x_61 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_58 x_2 x_3 x_4 x_5 x_6 x_7;
      case x_61 : obj of
      EStateM.Result.ok →
        let x_62 : obj := proj[0] x_61;
        let x_63 : obj := proj[1] x_61;
        let x_304 : obj := reset[2] x_61;
        let x_64 : usize := ptrAddrUnsafe ◾ x_58;
        let x_65 : usize := ptrAddrUnsafe ◾ x_62;
        let x_66 : u8 := USize.decEq x_64 x_65;
        case x_66 : obj of
        Bool.false →
          let x_333 : obj := reset[2] x_1;
          let x_67 : obj := reuse! x_304 in ctor_2[Lean.Compiler.LCNF.Code.jp] x_57 x_62;
          let x_68 : obj := reuse! x_333 in ctor_0[EStateM.Result.ok] x_67 x_63;
          ret x_68
        Bool.true →
          let x_69 : usize := ptrAddrUnsafe ◾ x_57;
          let x_70 : u8 := USize.decEq x_69 x_69;
          case x_70 : obj of
          Bool.false →
            let x_334 : obj := reset[2] x_1;
            let x_71 : obj := reuse! x_304 in ctor_2[Lean.Compiler.LCNF.Code.jp] x_57 x_62;
            let x_72 : obj := reuse! x_334 in ctor_0[EStateM.Result.ok] x_71 x_63;
            ret x_72
          Bool.true →
            let x_73 : obj := reuse x_304 in ctor_0[EStateM.Result.ok] x_1 x_63;
            ret x_73
      EStateM.Result.error →
        let x_74 : obj := proj[0] x_61;
        let x_75 : obj := proj[1] x_61;
        let x_305 : obj := reset[2] x_61;
        let x_76 : obj := reuse x_305 in ctor_1[EStateM.Result.error] x_74 x_75;
        ret x_76
    Option.some →
      let x_77 : obj := proj[0] x_60;
      let x_78 : obj := proj[2] x_57;
      let x_79 : obj := Array.size ◾ x_78;
      let x_80 : obj := 0;
      let x_81 : u8 := Nat.decLt x_80 x_79;
      case x_81 : obj of
      Bool.false →
        let x_82 : obj := proj[4] x_57;
        let x_83 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_82 x_2 x_3 x_4 x_5 x_6 x_7;
        case x_83 : obj of
        EStateM.Result.ok →
          let x_84 : obj := proj[0] x_83;
          let x_85 : obj := proj[1] x_83;
          let x_86 : u8 := 0;
          let x_87 : obj := Lean.Compiler.LCNF.normCodeImp x_86 x_84 x_77 x_3 x_4 x_5 x_6 x_85;
          case x_87 : obj of
          EStateM.Result.ok →
            let x_88 : obj := proj[0] x_87;
            let x_89 : obj := proj[1] x_87;
            let x_90 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_2;
            let x_91 : u8 := Nat.beq x_90 x_79;
            case x_91 : obj of
            Bool.false →
              let x_92 : obj := Lean.Compiler.LCNF.Code.inferType x_88 x_3 x_4 x_5 x_6 x_89;
              case x_92 : obj of
              EStateM.Result.ok →
                let x_93 : obj := proj[0] x_92;
                let x_94 : obj := proj[1] x_92;
                let x_95 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
                let x_96 : obj := Lean.Compiler.LCNF.mkForallParams x_95 x_93 x_3 x_4 x_5 x_6 x_94;
                case x_96 : obj of
                EStateM.Result.ok →
                  let x_97 : obj := proj[0] x_96;
                  let x_98 : obj := proj[1] x_96;
                  let x_99 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_58 x_57 x_95 x_88 x_1 x_97 x_2 x_3 x_4 x_5 x_6 x_98;
                  ret x_99
                EStateM.Result.error →
                  let x_100 : obj := proj[0] x_96;
                  let x_101 : obj := proj[1] x_96;
                  let x_307 : obj := reset[2] x_96;
                  let x_102 : obj := reuse x_307 in ctor_1[EStateM.Result.error] x_100 x_101;
                  ret x_102
              EStateM.Result.error →
                let x_103 : obj := proj[0] x_92;
                let x_104 : obj := proj[1] x_92;
                let x_309 : obj := reset[2] x_92;
                let x_105 : obj := reuse x_309 in ctor_1[EStateM.Result.error] x_103 x_104;
                ret x_105
            Bool.true →
              let x_106 : obj := proj[3] x_57;
              let x_107 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
              let x_108 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_58 x_57 x_107 x_88 x_1 x_106 x_2 x_3 x_4 x_5 x_6 x_89;
              ret x_108
          EStateM.Result.error →
            let x_109 : obj := proj[0] x_87;
            let x_110 : obj := proj[1] x_87;
            let x_311 : obj := reset[2] x_87;
            let x_111 : obj := reuse x_311 in ctor_1[EStateM.Result.error] x_109 x_110;
            ret x_111
        EStateM.Result.error →
          let x_112 : obj := proj[0] x_83;
          let x_113 : obj := proj[1] x_83;
          let x_313 : obj := reset[2] x_83;
          let x_114 : obj := reuse x_313 in ctor_1[EStateM.Result.error] x_112 x_113;
          ret x_114
      Bool.true →
        let x_115 : u8 := Nat.decLe x_79 x_79;
        case x_115 : obj of
        Bool.false →
          let x_116 : obj := proj[4] x_57;
          let x_117 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_116 x_2 x_3 x_4 x_5 x_6 x_7;
          case x_117 : obj of
          EStateM.Result.ok →
            let x_118 : obj := proj[0] x_117;
            let x_119 : obj := proj[1] x_117;
            let x_120 : u8 := 0;
            let x_121 : obj := Lean.Compiler.LCNF.normCodeImp x_120 x_118 x_77 x_3 x_4 x_5 x_6 x_119;
            case x_121 : obj of
            EStateM.Result.ok →
              let x_122 : obj := proj[0] x_121;
              let x_123 : obj := proj[1] x_121;
              let x_124 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_2;
              let x_125 : u8 := Nat.beq x_124 x_79;
              case x_125 : obj of
              Bool.false →
                let x_126 : obj := Lean.Compiler.LCNF.Code.inferType x_122 x_3 x_4 x_5 x_6 x_123;
                case x_126 : obj of
                EStateM.Result.ok →
                  let x_127 : obj := proj[0] x_126;
                  let x_128 : obj := proj[1] x_126;
                  let x_129 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
                  let x_130 : obj := Lean.Compiler.LCNF.mkForallParams x_129 x_127 x_3 x_4 x_5 x_6 x_128;
                  case x_130 : obj of
                  EStateM.Result.ok →
                    let x_131 : obj := proj[0] x_130;
                    let x_132 : obj := proj[1] x_130;
                    let x_133 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_58 x_57 x_129 x_122 x_1 x_131 x_2 x_3 x_4 x_5 x_6 x_132;
                    ret x_133
                  EStateM.Result.error →
                    let x_134 : obj := proj[0] x_130;
                    let x_135 : obj := proj[1] x_130;
                    let x_315 : obj := reset[2] x_130;
                    let x_136 : obj := reuse x_315 in ctor_1[EStateM.Result.error] x_134 x_135;
                    ret x_136
                EStateM.Result.error →
                  let x_137 : obj := proj[0] x_126;
                  let x_138 : obj := proj[1] x_126;
                  let x_317 : obj := reset[2] x_126;
                  let x_139 : obj := reuse x_317 in ctor_1[EStateM.Result.error] x_137 x_138;
                  ret x_139
              Bool.true →
                let x_140 : obj := proj[3] x_57;
                let x_141 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
                let x_142 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_58 x_57 x_141 x_122 x_1 x_140 x_2 x_3 x_4 x_5 x_6 x_123;
                ret x_142
            EStateM.Result.error →
              let x_143 : obj := proj[0] x_121;
              let x_144 : obj := proj[1] x_121;
              let x_319 : obj := reset[2] x_121;
              let x_145 : obj := reuse x_319 in ctor_1[EStateM.Result.error] x_143 x_144;
              ret x_145
          EStateM.Result.error →
            let x_146 : obj := proj[0] x_117;
            let x_147 : obj := proj[1] x_117;
            let x_321 : obj := reset[2] x_117;
            let x_148 : obj := reuse x_321 in ctor_1[EStateM.Result.error] x_146 x_147;
            ret x_148
        Bool.true →
          let x_149 : usize := 0;
          let x_150 : usize := USize.ofNat x_79;
          let x_151 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
          let x_152 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2 x_77 x_78 x_149 x_150 x_151 x_2 x_3 x_4 x_5 x_6 x_7;
          case x_152 : obj of
          EStateM.Result.ok →
            let x_153 : obj := proj[0] x_152;
            let x_154 : obj := proj[1] x_152;
            let x_155 : obj := proj[4] x_57;
            let x_156 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_155 x_2 x_3 x_4 x_5 x_6 x_154;
            case x_156 : obj of
            EStateM.Result.ok →
              let x_157 : obj := proj[0] x_156;
              let x_158 : obj := proj[1] x_156;
              let x_159 : u8 := 0;
              let x_160 : obj := Lean.Compiler.LCNF.normCodeImp x_159 x_157 x_77 x_3 x_4 x_5 x_6 x_158;
              case x_160 : obj of
              EStateM.Result.ok →
                let x_161 : obj := proj[0] x_160;
                let x_162 : obj := proj[1] x_160;
                let x_163 : obj := Array.size ◾ x_153;
                let x_164 : u8 := Nat.beq x_163 x_79;
                case x_164 : obj of
                Bool.false →
                  let x_165 : obj := Lean.Compiler.LCNF.Code.inferType x_161 x_3 x_4 x_5 x_6 x_162;
                  case x_165 : obj of
                  EStateM.Result.ok →
                    let x_166 : obj := proj[0] x_165;
                    let x_167 : obj := proj[1] x_165;
                    let x_168 : obj := Lean.Compiler.LCNF.mkForallParams x_153 x_166 x_3 x_4 x_5 x_6 x_167;
                    case x_168 : obj of
                    EStateM.Result.ok →
                      let x_169 : obj := proj[0] x_168;
                      let x_170 : obj := proj[1] x_168;
                      let x_171 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_58 x_57 x_153 x_161 x_1 x_169 x_2 x_3 x_4 x_5 x_6 x_170;
                      ret x_171
                    EStateM.Result.error →
                      let x_172 : obj := proj[0] x_168;
                      let x_173 : obj := proj[1] x_168;
                      let x_323 : obj := reset[2] x_168;
                      let x_174 : obj := reuse x_323 in ctor_1[EStateM.Result.error] x_172 x_173;
                      ret x_174
                  EStateM.Result.error →
                    let x_175 : obj := proj[0] x_165;
                    let x_176 : obj := proj[1] x_165;
                    let x_325 : obj := reset[2] x_165;
                    let x_177 : obj := reuse x_325 in ctor_1[EStateM.Result.error] x_175 x_176;
                    ret x_177
                Bool.true →
                  let x_178 : obj := proj[3] x_57;
                  let x_179 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_58 x_57 x_153 x_161 x_1 x_178 x_2 x_3 x_4 x_5 x_6 x_162;
                  ret x_179
              EStateM.Result.error →
                let x_180 : obj := proj[0] x_160;
                let x_181 : obj := proj[1] x_160;
                let x_327 : obj := reset[2] x_160;
                let x_182 : obj := reuse x_327 in ctor_1[EStateM.Result.error] x_180 x_181;
                ret x_182
            EStateM.Result.error →
              let x_183 : obj := proj[0] x_156;
              let x_184 : obj := proj[1] x_156;
              let x_329 : obj := reset[2] x_156;
              let x_185 : obj := reuse x_329 in ctor_1[EStateM.Result.error] x_183 x_184;
              ret x_185
          EStateM.Result.error →
            ⊥
  Lean.Compiler.LCNF.Code.jmp →
    let x_186 : obj := proj[0] x_1;
    let x_187 : obj := proj[1] x_1;
    block_238 (x_188 : obj) (x_189 : obj) (x_190 : obj) :=
      block_225 (x_191 : obj) :=
        case x_1 : obj of
        Lean.Compiler.LCNF.Code.let →
          let x_356 : obj := reset[2] x_1;
          let x_192 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5;
          let x_193 : obj := panic._at._private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltsImp._spec_1 x_192;
          let x_194 : obj := reuse x_356 in ctor_0[EStateM.Result.ok] x_193 x_190;
          ret x_194
        Lean.Compiler.LCNF.Code.fun →
          let x_357 : obj := reset[2] x_1;
          let x_195 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5;
          let x_196 : obj := panic._at._private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltsImp._spec_1 x_195;
          let x_197 : obj := reuse! x_357 in ctor_0[EStateM.Result.ok] x_196 x_190;
          ret x_197
        Lean.Compiler.LCNF.Code.jp →
          let x_358 : obj := reset[2] x_1;
          let x_198 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5;
          let x_199 : obj := panic._at._private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltsImp._spec_1 x_198;
          let x_200 : obj := reuse! x_358 in ctor_0[EStateM.Result.ok] x_199 x_190;
          ret x_200
        Lean.Compiler.LCNF.Code.jmp →
          let x_201 : obj := proj[0] x_1;
          let x_202 : obj := proj[1] x_1;
          let x_203 : obj := Array.size ◾ x_191;
          let x_204 : usize := USize.ofNat x_203;
          let x_205 : usize := 0;
          let x_206 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_3 x_204 x_205 x_191;
          let x_207 : u8 := Lean.Name.beq x_201 x_186;
          case x_207 : obj of
          Bool.false →
            let x_359 : obj := reset[2] x_1;
            let x_375 : obj := reset[2] x_1;
            let x_208 : obj := reuse x_359 in ctor_3[Lean.Compiler.LCNF.Code.jmp] x_186 x_206;
            let x_209 : obj := reuse! x_375 in ctor_0[EStateM.Result.ok] x_208 x_190;
            ret x_209
          Bool.true →
            let x_210 : usize := ptrAddrUnsafe ◾ x_202;
            let x_211 : usize := ptrAddrUnsafe ◾ x_206;
            let x_212 : u8 := USize.decEq x_210 x_211;
            case x_212 : obj of
            Bool.false →
              let x_360 : obj := reset[2] x_1;
              let x_376 : obj := reset[2] x_1;
              let x_213 : obj := reuse x_360 in ctor_3[Lean.Compiler.LCNF.Code.jmp] x_186 x_206;
              let x_214 : obj := reuse! x_376 in ctor_0[EStateM.Result.ok] x_213 x_190;
              ret x_214
            Bool.true →
              let x_215 : obj := ctor_0[EStateM.Result.ok] x_1 x_190;
              ret x_215
        Lean.Compiler.LCNF.Code.cases →
          let x_377 : obj := reset[2] x_1;
          let x_216 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5;
          let x_217 : obj := panic._at._private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltsImp._spec_1 x_216;
          let x_218 : obj := reuse! x_377 in ctor_0[EStateM.Result.ok] x_217 x_190;
          ret x_218
        Lean.Compiler.LCNF.Code.return →
          let x_378 : obj := reset[2] x_1;
          let x_219 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5;
          let x_220 : obj := panic._at._private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltsImp._spec_1 x_219;
          let x_221 : obj := reuse! x_378 in ctor_0[EStateM.Result.ok] x_220 x_190;
          ret x_221
        Lean.Compiler.LCNF.Code.unreach →
          let x_379 : obj := reset[2] x_1;
          let x_222 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5;
          let x_223 : obj := panic._at._private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltsImp._spec_1 x_222;
          let x_224 : obj := reuse! x_379 in ctor_0[EStateM.Result.ok] x_223 x_190;
          ret x_224;
      let x_226 : obj := proj[2] x_189;
      let x_227 : obj := Array.zip._rarg x_226 x_187;
      let x_228 : obj := Array.size ◾ x_227;
      let x_229 : obj := 0;
      let x_230 : u8 := Nat.decLt x_229 x_228;
      case x_230 : obj of
      Bool.false →
        let x_231 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
        jmp block_225 x_231
      Bool.true →
        let x_232 : u8 := Nat.decLe x_228 x_228;
        case x_232 : obj of
        Bool.false →
          let x_233 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
          jmp block_225 x_233
        Bool.true →
          let x_234 : usize := 0;
          let x_235 : usize := USize.ofNat x_228;
          let x_236 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
          let x_237 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_4 x_188 x_227 x_234 x_235 x_236;
          jmp block_225 x_237;
    let x_239 : obj := Lean.Compiler.LCNF.getFunDecl x_186 x_3 x_4 x_5 x_6 x_7;
    let x_240 : obj := Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1 x_2 x_186;
    case x_240 : obj of
    Option.none →
      case x_239 : obj of
      EStateM.Result.ok →
        let x_241 : obj := proj[0] x_239;
        let x_242 : obj := proj[1] x_239;
        let x_243 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.isInJpScope._closed_3;
        let x_244 : obj := panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_5 x_243;
        jmp block_238 x_244 x_241 x_242
      EStateM.Result.error →
        let x_245 : obj := proj[0] x_239;
        let x_246 : obj := proj[1] x_239;
        let x_365 : obj := reset[2] x_239;
        let x_247 : obj := reuse x_365 in ctor_1[EStateM.Result.error] x_245 x_246;
        ret x_247
    Option.some →
      case x_239 : obj of
      EStateM.Result.ok →
        let x_248 : obj := proj[0] x_240;
        let x_249 : obj := proj[0] x_239;
        let x_250 : obj := proj[1] x_239;
        jmp block_238 x_248 x_249 x_250
      EStateM.Result.error →
        let x_251 : obj := proj[0] x_239;
        let x_252 : obj := proj[1] x_239;
        let x_367 : obj := reset[2] x_239;
        let x_253 : obj := reuse x_367 in ctor_1[EStateM.Result.error] x_251 x_252;
        ret x_253
  Lean.Compiler.LCNF.Code.cases →
    let x_254 : obj := proj[0] x_1;
    case x_254 : obj of
    Lean.Compiler.LCNF.CasesCore.mk →
      let x_255 : obj := proj[0] x_254;
      let x_256 : obj := proj[1] x_254;
      let x_257 : obj := proj[2] x_254;
      let x_258 : obj := proj[3] x_254;
      let x_382 : obj := reset[4] x_254;
      let x_259 : obj := Array.size ◾ x_258;
      let x_260 : usize := USize.ofNat x_259;
      let x_261 : usize := 0;
      let x_262 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_7 x_260 x_261 x_258 x_2 x_3 x_4 x_5 x_6 x_7;
      case x_262 : obj of
      EStateM.Result.ok →
        let x_263 : obj := proj[0] x_262;
        let x_264 : obj := proj[1] x_262;
        let x_380 : obj := reset[2] x_262;
        let x_265 : usize := ptrAddrUnsafe ◾ x_258;
        let x_266 : usize := ptrAddrUnsafe ◾ x_263;
        let x_267 : u8 := USize.decEq x_265 x_266;
        case x_267 : obj of
        Bool.false →
          let x_383 : obj := reset[1] x_1;
          let x_268 : obj := reuse x_382 in ctor_0[Lean.Compiler.LCNF.CasesCore.mk] x_255 x_256 x_257 x_263;
          let x_269 : obj := reuse x_383 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_268;
          let x_270 : obj := reuse x_380 in ctor_0[EStateM.Result.ok] x_269 x_264;
          ret x_270
        Bool.true →
          let x_271 : usize := ptrAddrUnsafe ◾ x_256;
          let x_272 : u8 := USize.decEq x_271 x_271;
          case x_272 : obj of
          Bool.false →
            let x_384 : obj := reset[1] x_1;
            let x_273 : obj := reuse x_382 in ctor_0[Lean.Compiler.LCNF.CasesCore.mk] x_255 x_256 x_257 x_263;
            let x_274 : obj := reuse x_384 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_273;
            let x_275 : obj := reuse x_380 in ctor_0[EStateM.Result.ok] x_274 x_264;
            ret x_275
          Bool.true →
            let x_276 : u8 := Lean.Name.beq x_257 x_257;
            case x_276 : obj of
            Bool.false →
              let x_385 : obj := reset[1] x_1;
              let x_277 : obj := reuse x_382 in ctor_0[Lean.Compiler.LCNF.CasesCore.mk] x_255 x_256 x_257 x_263;
              let x_278 : obj := reuse x_385 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_277;
              let x_279 : obj := reuse x_380 in ctor_0[EStateM.Result.ok] x_278 x_264;
              ret x_279
            Bool.true →
              let x_280 : obj := reuse x_380 in ctor_0[EStateM.Result.ok] x_1 x_264;
              ret x_280
      EStateM.Result.error →
        let x_281 : obj := proj[0] x_262;
        let x_282 : obj := proj[1] x_262;
        let x_381 : obj := reset[2] x_262;
        let x_283 : obj := reuse x_381 in ctor_1[EStateM.Result.error] x_281 x_282;
        ret x_283
  Lean.Compiler.LCNF.Code.return →
    let x_284 : obj := ctor_0[EStateM.Result.ok] x_1 x_7;
    ret x_284
  Lean.Compiler.LCNF.Code.unreach →
    let x_285 : obj := ctor_0[EStateM.Result.ok] x_1 x_7;
    ret x_285
[reset_reuse]
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) : obj :=
