
[result]
def ReaderT.pure._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_1._rarg (x_1 : obj) (x_2 : @& obj) (x_3 : @& obj) (x_4 : @& obj) (x_5 : @& obj) (x_6 : @& obj) (x_7 : @& obj) (x_8 : @& obj) (x_9 : obj) : obj :=
  let x_10 : obj := ctor_0[EStateM.Result.ok] x_1 x_9;
  ret x_10
def ReaderT.pure._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_1 (x_1 : ◾) : obj :=
  let x_2 : obj := pap ReaderT.pure._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_1._rarg._boxed;
  ret x_2
def ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) : obj :=
  inc x_9;
  inc x_8;
  inc x_7;
  inc x_6;
  inc x_5;
  inc x_4;
  inc x_3;
  let x_11 : obj := app x_1 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
  case x_11 : obj of
  EStateM.Result.ok →
    let x_12 : obj := proj[0] x_11;
    inc x_12;
    let x_13 : obj := proj[1] x_11;
    inc x_13;
    dec x_11;
    let x_14 : obj := app x_2 x_12 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_13;
    ret x_14
  EStateM.Result.error →
    dec x_9;
    dec x_8;
    dec x_7;
    dec x_6;
    dec x_5;
    dec x_4;
    dec x_3;
    dec x_2;
    let x_15 : u8 := isShared x_11;
    case x_15 : u8 of
    Bool.false →
      ret x_11
    Bool.true →
      let x_16 : obj := proj[0] x_11;
      let x_17 : obj := proj[1] x_11;
      inc x_17;
      inc x_16;
      dec x_11;
      let x_18 : obj := ctor_1[EStateM.Result.error] x_16 x_17;
      ret x_18
def ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2 (x_1 : ◾) (x_2 : ◾) : obj :=
  let x_3 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg;
  ret x_3
def Lean.Compiler.LCNF.ScopeM.withBackTrackingScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_4 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  let x_10 : obj := Lean.Compiler.LCNF.ScopeM.getScope x_4 x_5 x_6 x_7 x_8 x_9;
  let x_11 : obj := proj[0] x_10;
  inc x_11;
  let x_12 : obj := proj[1] x_10;
  inc x_12;
  dec x_10;
  inc x_8;
  inc x_7;
  inc x_6;
  inc x_5;
  inc x_4;
  let x_13 : obj := app x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_12;
  case x_13 : obj of
  EStateM.Result.ok →
    let x_14 : obj := proj[0] x_13;
    inc x_14;
    let x_15 : obj := proj[1] x_13;
    inc x_15;
    dec x_13;
    let x_16 : obj := Lean.Compiler.LCNF.ScopeM.setScope x_11 x_4 x_5 x_6 x_7 x_8 x_15;
    dec x_8;
    dec x_7;
    dec x_6;
    dec x_5;
    dec x_4;
    let x_17 : u8 := isShared x_16;
    case x_17 : u8 of
    Bool.false →
      let x_18 : obj := proj[0] x_16;
      dec x_18;
      set x_16[0] := x_14;
      ret x_16
    Bool.true →
      let x_19 : obj := proj[1] x_16;
      inc x_19;
      dec x_16;
      let x_20 : obj := ctor_0[EStateM.Result.ok] x_14 x_19;
      ret x_20
  EStateM.Result.error →
    let x_21 : obj := proj[0] x_13;
    inc x_21;
    let x_22 : obj := proj[1] x_13;
    inc x_22;
    dec x_13;
    let x_23 : obj := Lean.Compiler.LCNF.ScopeM.setScope x_11 x_4 x_5 x_6 x_7 x_8 x_22;
    dec x_8;
    dec x_7;
    dec x_6;
    dec x_5;
    dec x_4;
    let x_24 : u8 := isShared x_23;
    case x_24 : u8 of
    Bool.false →
      let x_25 : obj := proj[0] x_23;
      dec x_25;
      setTag x_23 := 1;
      set x_23[0] := x_21;
      ret x_23
    Bool.true →
      let x_26 : obj := proj[1] x_23;
      inc x_26;
      dec x_23;
      let x_27 : obj := ctor_1[EStateM.Result.error] x_21 x_26;
      ret x_27
def Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_3 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  let x_10 : obj := pap Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointFinder.find.go._spec_2._lambda_2._boxed x_1;
  let x_11 : obj := Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointFinder.find.go._spec_2._closed_1;
  let x_12 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg x_11 x_10;
  let x_13 : obj := Lean.Compiler.LCNF.ScopeM.withBackTrackingScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_4 x_12 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
  ret x_13
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_5 (x_1 : @& obj) (x_2 : usize) (x_3 : usize) (x_4 : obj) (x_5 : @& obj) (x_6 : @& obj) (x_7 : @& obj) (x_8 : @& obj) (x_9 : @& obj) (x_10 : @& obj) (x_11 : @& obj) (x_12 : obj) : obj :=
  let x_13 : u8 := USize.decEq x_2 x_3;
  case x_13 : u8 of
  Bool.false →
    dec x_4;
    let x_14 : obj := Array.uget ◾ x_1 x_2 ◾;
    let x_15 : obj := proj[0] x_14;
    inc x_15;
    dec x_14;
    let x_16 : obj := Lean.Compiler.LCNF.ScopeM.addToScope x_15 x_7 x_8 x_9 x_10 x_11 x_12;
    let x_17 : obj := proj[0] x_16;
    inc x_17;
    let x_18 : obj := proj[1] x_16;
    inc x_18;
    dec x_16;
    let x_19 : usize := 1;
    let x_20 : usize := USize.add x_2 x_19;
    let x_21 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_5 x_1 x_20 x_3 x_17 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_18;
    ret x_21
  Bool.true →
    let x_22 : obj := ctor_0[EStateM.Result.ok] x_4 x_12;
    ret x_22
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._lambda_1 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) : obj :=
  dec x_2;
  let x_11 : obj := proj[4] x_1;
  inc x_11;
  dec x_1;
  let x_12 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze x_11 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
  ret x_12
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._boxed_const_1 : obj :=
  let x_1 : usize := 0;
  let x_2 : obj := box x_1;
  ret x_2
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  let x_10 : obj := proj[2] x_1;
  inc x_10;
  let x_11 : obj := Array.size ◾ x_10;
  let x_12 : obj := 0;
  let x_13 : u8 := Nat.decLt x_12 x_11;
  let x_14 : obj := pap Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._lambda_1 x_1;
  case x_13 : u8 of
  Bool.false →
    dec x_11;
    dec x_10;
    let x_15 : obj := ctor_0[PUnit.unit];
    let x_16 : obj := pap ReaderT.pure._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_1._rarg._boxed x_15;
    let x_17 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg x_16 x_14;
    let x_18 : obj := Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_3 x_17 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
    ret x_18
  Bool.true →
    let x_19 : u8 := Nat.decLe x_11 x_11;
    case x_19 : u8 of
    Bool.false →
      dec x_11;
      dec x_10;
      let x_20 : obj := ctor_0[PUnit.unit];
      let x_21 : obj := pap ReaderT.pure._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_1._rarg._boxed x_20;
      let x_22 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg x_21 x_14;
      let x_23 : obj := Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_3 x_22 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
      ret x_23
    Bool.true →
      let x_24 : usize := USize.ofNat x_11;
      dec x_11;
      let x_25 : obj := ctor_0[PUnit.unit];
      let x_26 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._boxed_const_1;
      let x_27 : obj := box x_24;
      let x_28 : obj := pap Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_5._boxed x_10 x_26 x_27 x_25;
      let x_29 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg x_28 x_14;
      let x_30 : obj := Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_3 x_29 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
      ret x_30
def Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1 (x_1 : @& obj) (x_2 : @& obj) : obj :=
  case x_1 : obj of
  Lean.RBNode.leaf →
    let x_3 : obj := ctor_0[Option.none];
    ret x_3
  Lean.RBNode.node →
    let x_4 : obj := proj[0] x_1;
    let x_5 : obj := proj[1] x_1;
    let x_6 : obj := proj[2] x_1;
    let x_7 : obj := proj[3] x_1;
    let x_8 : u8 := Lean.Name.quickCmp x_2 x_5;
    case x_8 : u8 of
    Ordering.lt →
      let x_9 : obj := Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1 x_4 x_2;
      ret x_9
    Ordering.eq →
      inc x_6;
      let x_10 : obj := ctor_1[Option.some] x_6;
      ret x_10
    Ordering.gt →
      let x_11 : obj := Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1 x_7 x_2;
      ret x_11
def Lean.Compiler.LCNF.allFVarM.go._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_3._closed_1 : obj :=
  let x_1 : obj := ctor_0[PUnit.unit];
  let x_2 : obj := ctor_1[Option.some] x_1;
  ret x_2
def Lean.Compiler.LCNF.allFVarM.go._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_3 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) : obj :=
  let x_11 : obj := app x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
  case x_11 : obj of
  EStateM.Result.ok →
    let x_12 : obj := proj[0] x_11;
    inc x_12;
    let x_13 : u8 := unbox x_12;
    dec x_12;
    case x_13 : u8 of
    Bool.false →
      let x_14 : u8 := isShared x_11;
      case x_14 : u8 of
      Bool.false →
        let x_15 : obj := proj[0] x_11;
        dec x_15;
        let x_16 : obj := ctor_0[Option.none];
        set x_11[0] := x_16;
        ret x_11
      Bool.true →
        let x_17 : obj := proj[1] x_11;
        inc x_17;
        dec x_11;
        let x_18 : obj := ctor_0[Option.none];
        let x_19 : obj := ctor_0[EStateM.Result.ok] x_18 x_17;
        ret x_19
    Bool.true →
      let x_20 : u8 := isShared x_11;
      case x_20 : u8 of
      Bool.false →
        let x_21 : obj := proj[0] x_11;
        dec x_21;
        let x_22 : obj := Lean.Compiler.LCNF.allFVarM.go._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_3._closed_1;
        set x_11[0] := x_22;
        ret x_11
      Bool.true →
        let x_23 : obj := proj[1] x_11;
        inc x_23;
        dec x_11;
        let x_24 : obj := Lean.Compiler.LCNF.allFVarM.go._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_3._closed_1;
        let x_25 : obj := ctor_0[EStateM.Result.ok] x_24 x_23;
        ret x_25
  EStateM.Result.error →
    let x_26 : u8 := isShared x_11;
    case x_26 : u8 of
    Bool.false →
      ret x_11
    Bool.true →
      let x_27 : obj := proj[0] x_11;
      let x_28 : obj := proj[1] x_11;
      inc x_28;
      inc x_27;
      dec x_11;
      let x_29 : obj := ctor_1[EStateM.Result.error] x_27 x_28;
      ret x_29
def panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_6._closed_1 : obj :=
  let x_1 : obj := panic._at._private.miscompile.0.Lean.Compiler.LCNF.JoinPointFinder.removeCandidatesInArg._spec_3._closed_3;
  let x_2 : obj := OptionT.instMonadOptionT._rarg x_1;
  ret x_2
def panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_6._closed_2 : obj :=
  let x_1 : obj := panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_6._closed_1;
  let x_2 : obj := instInhabitedPUnit;
  let x_3 : obj := instInhabited._rarg x_1 x_2;
  ret x_3
def panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_6 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  let x_10 : obj := panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_6._closed_2;
  let x_11 : obj := panicCore ◾ x_10 x_1;
  let x_12 : obj := app x_11 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
  ret x_12
def Lean.Compiler.LCNF.Expr.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_5 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) : obj :=
  case x_2 : obj of
  Lean.Expr.fvar._impl →
    let x_11 : obj := proj[0] x_2;
    inc x_11;
    dec x_2;
    let x_12 : obj := app x_1 x_11 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    ret x_12
  Lean.Expr.mvar._impl →
    dec x_2;
    dec x_1;
    let x_13 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at._private.miscompile.0.Lean.Compiler.LCNF.JoinPointFinder.removeCandidatesInArg._spec_2._closed_4;
    let x_14 : obj := panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_6 x_13 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    ret x_14
  Lean.Expr.app._impl →
    let x_15 : obj := proj[0] x_2;
    inc x_15;
    let x_16 : obj := proj[1] x_2;
    inc x_16;
    dec x_2;
    inc x_9;
    inc x_8;
    inc x_7;
    inc x_6;
    inc x_5;
    inc x_4;
    inc x_3;
    inc x_1;
    let x_17 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_5 x_1 x_15 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    case x_17 : obj of
    EStateM.Result.ok →
      let x_18 : obj := proj[0] x_17;
      inc x_18;
      case x_18 : obj of
      Option.none →
        dec x_16;
        dec x_9;
        dec x_8;
        dec x_7;
        dec x_6;
        dec x_5;
        dec x_4;
        dec x_3;
        dec x_1;
        let x_19 : u8 := isShared x_17;
        case x_19 : u8 of
        Bool.false →
          let x_20 : obj := proj[0] x_17;
          dec x_20;
          let x_21 : obj := ctor_0[Option.none];
          set x_17[0] := x_21;
          ret x_17
        Bool.true →
          let x_22 : obj := proj[1] x_17;
          inc x_22;
          dec x_17;
          let x_23 : obj := ctor_0[Option.none];
          let x_24 : obj := ctor_0[EStateM.Result.ok] x_23 x_22;
          ret x_24
      Option.some →
        dec x_18;
        let x_25 : obj := proj[1] x_17;
        inc x_25;
        dec x_17;
        let x_26 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_5 x_1 x_16 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_25;
        ret x_26
    EStateM.Result.error →
      dec x_16;
      dec x_9;
      dec x_8;
      dec x_7;
      dec x_6;
      dec x_5;
      dec x_4;
      dec x_3;
      dec x_1;
      let x_27 : u8 := isShared x_17;
      case x_27 : u8 of
      Bool.false →
        ret x_17
      Bool.true →
        let x_28 : obj := proj[0] x_17;
        let x_29 : obj := proj[1] x_17;
        inc x_29;
        inc x_28;
        dec x_17;
        let x_30 : obj := ctor_1[EStateM.Result.error] x_28 x_29;
        ret x_30
  Lean.Expr.lam._impl →
    let x_31 : obj := proj[1] x_2;
    inc x_31;
    let x_32 : obj := proj[2] x_2;
    inc x_32;
    dec x_2;
    inc x_9;
    inc x_8;
    inc x_7;
    inc x_6;
    inc x_5;
    inc x_4;
    inc x_3;
    inc x_1;
    let x_33 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_5 x_1 x_31 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    case x_33 : obj of
    EStateM.Result.ok →
      let x_34 : obj := proj[0] x_33;
      inc x_34;
      case x_34 : obj of
      Option.none →
        dec x_32;
        dec x_9;
        dec x_8;
        dec x_7;
        dec x_6;
        dec x_5;
        dec x_4;
        dec x_3;
        dec x_1;
        let x_35 : u8 := isShared x_33;
        case x_35 : u8 of
        Bool.false →
          let x_36 : obj := proj[0] x_33;
          dec x_36;
          let x_37 : obj := ctor_0[Option.none];
          set x_33[0] := x_37;
          ret x_33
        Bool.true →
          let x_38 : obj := proj[1] x_33;
          inc x_38;
          dec x_33;
          let x_39 : obj := ctor_0[Option.none];
          let x_40 : obj := ctor_0[EStateM.Result.ok] x_39 x_38;
          ret x_40
      Option.some →
        dec x_34;
        let x_41 : obj := proj[1] x_33;
        inc x_41;
        dec x_33;
        let x_42 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_5 x_1 x_32 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_41;
        ret x_42
    EStateM.Result.error →
      dec x_32;
      dec x_9;
      dec x_8;
      dec x_7;
      dec x_6;
      dec x_5;
      dec x_4;
      dec x_3;
      dec x_1;
      let x_43 : u8 := isShared x_33;
      case x_43 : u8 of
      Bool.false →
        ret x_33
      Bool.true →
        let x_44 : obj := proj[0] x_33;
        let x_45 : obj := proj[1] x_33;
        inc x_45;
        inc x_44;
        dec x_33;
        let x_46 : obj := ctor_1[EStateM.Result.error] x_44 x_45;
        ret x_46
  Lean.Expr.forallE._impl →
    let x_47 : obj := proj[1] x_2;
    inc x_47;
    let x_48 : obj := proj[2] x_2;
    inc x_48;
    dec x_2;
    inc x_9;
    inc x_8;
    inc x_7;
    inc x_6;
    inc x_5;
    inc x_4;
    inc x_3;
    inc x_1;
    let x_49 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_5 x_1 x_47 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    case x_49 : obj of
    EStateM.Result.ok →
      let x_50 : obj := proj[0] x_49;
      inc x_50;
      case x_50 : obj of
      Option.none →
        dec x_48;
        dec x_9;
        dec x_8;
        dec x_7;
        dec x_6;
        dec x_5;
        dec x_4;
        dec x_3;
        dec x_1;
        let x_51 : u8 := isShared x_49;
        case x_51 : u8 of
        Bool.false →
          let x_52 : obj := proj[0] x_49;
          dec x_52;
          let x_53 : obj := ctor_0[Option.none];
          set x_49[0] := x_53;
          ret x_49
        Bool.true →
          let x_54 : obj := proj[1] x_49;
          inc x_54;
          dec x_49;
          let x_55 : obj := ctor_0[Option.none];
          let x_56 : obj := ctor_0[EStateM.Result.ok] x_55 x_54;
          ret x_56
      Option.some →
        dec x_50;
        let x_57 : obj := proj[1] x_49;
        inc x_57;
        dec x_49;
        let x_58 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_5 x_1 x_48 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_57;
        ret x_58
    EStateM.Result.error →
      dec x_48;
      dec x_9;
      dec x_8;
      dec x_7;
      dec x_6;
      dec x_5;
      dec x_4;
      dec x_3;
      dec x_1;
      let x_59 : u8 := isShared x_49;
      case x_59 : u8 of
      Bool.false →
        ret x_49
      Bool.true →
        let x_60 : obj := proj[0] x_49;
        let x_61 : obj := proj[1] x_49;
        inc x_61;
        inc x_60;
        dec x_49;
        let x_62 : obj := ctor_1[EStateM.Result.error] x_60 x_61;
        ret x_62
  Lean.Expr.letE._impl →
    dec x_2;
    dec x_1;
    let x_63 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at._private.miscompile.0.Lean.Compiler.LCNF.JoinPointFinder.removeCandidatesInArg._spec_2._closed_4;
    let x_64 : obj := panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_6 x_63 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    ret x_64
  Lean.Expr.proj._impl →
    dec x_2;
    dec x_1;
    let x_65 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at._private.miscompile.0.Lean.Compiler.LCNF.JoinPointFinder.removeCandidatesInArg._spec_2._closed_4;
    let x_66 : obj := panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_6 x_65 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    ret x_66
  default →
    dec x_9;
    dec x_8;
    dec x_7;
    dec x_6;
    dec x_5;
    dec x_4;
    dec x_3;
    dec x_2;
    dec x_1;
    let x_67 : obj := Lean.Compiler.LCNF.allFVarM.go._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_3._closed_1;
    let x_68 : obj := ctor_0[EStateM.Result.ok] x_67 x_10;
    ret x_68
def Lean.Compiler.LCNF.Arg.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_4 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) : obj :=
  case x_2 : obj of
  Lean.Compiler.LCNF.Arg.erased →
    dec x_9;
    dec x_8;
    dec x_7;
    dec x_6;
    dec x_5;
    dec x_4;
    dec x_3;
    dec x_1;
    let x_11 : obj := Lean.Compiler.LCNF.allFVarM.go._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_3._closed_1;
    let x_12 : obj := ctor_0[EStateM.Result.ok] x_11 x_10;
    ret x_12
  Lean.Compiler.LCNF.Arg.fvar →
    let x_13 : obj := proj[0] x_2;
    inc x_13;
    dec x_2;
    let x_14 : obj := app x_1 x_13 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    ret x_14
  Lean.Compiler.LCNF.Arg.type →
    let x_15 : obj := proj[0] x_2;
    inc x_15;
    dec x_2;
    let x_16 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_5 x_1 x_15 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
    ret x_16
def Lean.Compiler.LCNF.allFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_2 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) : obj :=
  let x_11 : obj := pap Lean.Compiler.LCNF.allFVarM.go._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_3 x_1;
  let x_12 : obj := Lean.Compiler.LCNF.Arg.forFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_4 x_11 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
  case x_12 : obj of
  EStateM.Result.ok →
    let x_13 : obj := proj[0] x_12;
    inc x_13;
    case x_13 : obj of
    Option.none →
      let x_14 : u8 := isShared x_12;
      case x_14 : u8 of
      Bool.false →
        let x_15 : obj := proj[0] x_12;
        dec x_15;
        let x_16 : u8 := 0;
        let x_17 : obj := box x_16;
        set x_12[0] := x_17;
        ret x_12
      Bool.true →
        let x_18 : obj := proj[1] x_12;
        inc x_18;
        dec x_12;
        let x_19 : u8 := 0;
        let x_20 : obj := box x_19;
        let x_21 : obj := ctor_0[EStateM.Result.ok] x_20 x_18;
        ret x_21
    Option.some →
      dec x_13;
      let x_22 : u8 := isShared x_12;
      case x_22 : u8 of
      Bool.false →
        let x_23 : obj := proj[0] x_12;
        dec x_23;
        let x_24 : u8 := 1;
        let x_25 : obj := box x_24;
        set x_12[0] := x_25;
        ret x_12
      Bool.true →
        let x_26 : obj := proj[1] x_12;
        inc x_26;
        dec x_12;
        let x_27 : u8 := 1;
        let x_28 : obj := box x_27;
        let x_29 : obj := ctor_0[EStateM.Result.ok] x_28 x_26;
        ret x_29
  EStateM.Result.error →
    let x_30 : u8 := isShared x_12;
    case x_30 : u8 of
    Bool.false →
      ret x_12
    Bool.true →
      let x_31 : obj := proj[0] x_12;
      let x_32 : obj := proj[1] x_12;
      inc x_32;
      inc x_31;
      dec x_12;
      let x_33 : obj := ctor_1[EStateM.Result.error] x_31 x_32;
      ret x_33
def Lean.mkHashMap._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_7 (x_1 : @& obj) : obj :=
  let x_2 : obj := Lean.mkHashMapImp._rarg x_1;
  ret x_2
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_8 (x_1 : obj) (x_2 : @& obj) (x_3 : usize) (x_4 : usize) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) (x_11 : obj) (x_12 : obj) (x_13 : obj) : obj :=
  let x_14 : u8 := USize.decEq x_3 x_4;
  case x_14 : u8 of
  Bool.false →
    let x_15 : obj := Array.uget ◾ x_2 x_3 ◾;
    let x_16 : obj := proj[0] x_15;
    inc x_16;
    let x_17 : obj := proj[1] x_15;
    inc x_17;
    dec x_15;
    inc x_1;
    let x_18 : obj := pap Lean.Compiler.LCNF.JoinPointCommonArgs.isInJpScope._boxed x_1;
    inc x_12;
    inc x_11;
    inc x_10;
    inc x_9;
    inc x_8;
    inc x_7;
    inc x_6;
    inc x_17;
    let x_19 : obj := Lean.Compiler.LCNF.allFVarM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_2 x_18 x_17 x_6 x_7 x_8 x_9 x_10 x_11 x_12 x_13;
    case x_19 : obj of
    EStateM.Result.ok →
      let x_20 : obj := proj[0] x_19;
      inc x_20;
      let x_21 : u8 := unbox x_20;
      dec x_20;
      case x_21 : u8 of
      Bool.false →
        dec x_17;
        dec x_16;
        let x_22 : obj := proj[1] x_19;
        inc x_22;
        dec x_19;
        let x_23 : usize := 1;
        let x_24 : usize := USize.add x_3 x_23;
        let x_25 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_8 x_1 x_2 x_24 x_4 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12 x_22;
        ret x_25
      Bool.true →
        let x_26 : obj := proj[1] x_19;
        inc x_26;
        dec x_19;
        let x_27 : obj := proj[0] x_16;
        inc x_27;
        dec x_16;
        let x_28 : obj := Lean.Compiler.LCNF.Arg.toExpr x_17;
        let x_29 : obj := Lean.HashMap.insert._at.Lean.Compiler.LCNF.addFVarSubst._spec_1 x_5 x_27 x_28;
        let x_30 : usize := 1;
        let x_31 : usize := USize.add x_3 x_30;
        let x_32 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_8 x_1 x_2 x_31 x_4 x_29 x_6 x_7 x_8 x_9 x_10 x_11 x_12 x_26;
        ret x_32
    EStateM.Result.error →
      dec x_17;
      dec x_16;
      dec x_12;
      dec x_11;
      dec x_10;
      dec x_9;
      dec x_8;
      dec x_7;
      dec x_6;
      dec x_5;
      dec x_1;
      let x_33 : u8 := isShared x_19;
      case x_33 : u8 of
      Bool.false →
        ret x_19
      Bool.true →
        let x_34 : obj := proj[0] x_19;
        let x_35 : obj := proj[1] x_19;
        inc x_35;
        inc x_34;
        dec x_19;
        let x_36 : obj := ctor_1[EStateM.Result.error] x_34 x_35;
        ret x_36
  Bool.true →
    dec x_12;
    dec x_11;
    dec x_10;
    dec x_9;
    dec x_8;
    dec x_7;
    dec x_6;
    dec x_1;
    let x_37 : obj := ctor_0[EStateM.Result.ok] x_5 x_13;
    ret x_37
def Lean.AssocList.erase._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_10 (x_1 : @& obj) (x_2 : obj) : obj :=
  case x_2 : obj of
  Lean.AssocList.nil →
    let x_3 : obj := ctor_0[Lean.AssocList.nil];
    ret x_3
  Lean.AssocList.cons →
    let x_4 : u8 := isShared x_2;
    case x_4 : u8 of
    Bool.false →
      let x_5 : obj := proj[0] x_2;
      let x_6 : obj := proj[1] x_2;
      let x_7 : obj := proj[2] x_2;
      let x_8 : u8 := Lean.Name.beq x_5 x_1;
      case x_8 : u8 of
      Bool.false →
        let x_9 : obj := Lean.AssocList.erase._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_10 x_1 x_7;
        set x_2[2] := x_9;
        ret x_2
      Bool.true →
        del x_2;
        dec x_6;
        dec x_5;
        ret x_7
    Bool.true →
      let x_10 : obj := proj[0] x_2;
      let x_11 : obj := proj[1] x_2;
      let x_12 : obj := proj[2] x_2;
      inc x_12;
      inc x_11;
      inc x_10;
      dec x_2;
      let x_13 : u8 := Lean.Name.beq x_10 x_1;
      case x_13 : u8 of
      Bool.false →
        let x_14 : obj := Lean.AssocList.erase._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_10 x_1 x_12;
        let x_15 : obj := ctor_1[Lean.AssocList.cons] x_10 x_11 x_14;
        ret x_15
      Bool.true →
        dec x_11;
        dec x_10;
        ret x_12
def Lean.HashMapImp.erase._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_9 (x_1 : obj) (x_2 : @& obj) : obj :=
  let x_3 : obj := proj[0] x_1;
  inc x_3;
  let x_4 : obj := proj[1] x_1;
  inc x_4;
  let x_5 : obj := Array.size ◾ x_4;
  let x_6 : u64 := _private.Lean.Expr.0.Lean.hashFVarId._@.Lean.Expr._hyg.1674 x_2;
  let x_7 : usize := _private.Lean.Data.HashMap.0.Lean.HashMapImp.mkIdx x_5 x_6 ◾;
  let x_8 : obj := Array.uget ◾ x_4 x_7 ◾;
  let x_9 : u8 := Lean.AssocList.contains._at.Lean.Compiler.LCNF.addFVarSubst._spec_2 x_2 x_8;
  case x_9 : u8 of
  Bool.false →
    dec x_8;
    dec x_4;
    dec x_3;
    ret x_1
  Bool.true →
    let x_10 : u8 := isShared x_1;
    case x_10 : u8 of
    Bool.false →
      let x_11 : obj := proj[1] x_1;
      dec x_11;
      let x_12 : obj := proj[0] x_1;
      dec x_12;
      let x_13 : obj := 1;
      let x_14 : obj := Nat.sub x_3 x_13;
      dec x_3;
      let x_15 : obj := Lean.AssocList.erase._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_10 x_2 x_8;
      let x_16 : obj := Array.uset ◾ x_4 x_7 x_15 ◾;
      set x_1[1] := x_16;
      set x_1[0] := x_14;
      ret x_1
    Bool.true →
      dec x_1;
      let x_17 : obj := 1;
      let x_18 : obj := Nat.sub x_3 x_17;
      dec x_3;
      let x_19 : obj := Lean.AssocList.erase._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_10 x_2 x_8;
      let x_20 : obj := Array.uset ◾ x_4 x_7 x_19 ◾;
      let x_21 : obj := ctor_0[Lean.HashMapImp.mk] x_18 x_20;
      ret x_21
def Array.forInUnsafe.loop._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_11 (x_1 : @& obj) (x_2 : usize) (x_3 : usize) (x_4 : obj) (x_5 : @& obj) (x_6 : @& obj) (x_7 : @& obj) (x_8 : @& obj) (x_9 : @& obj) (x_10 : @& obj) (x_11 : @& obj) (x_12 : obj) : obj :=
  let x_13 : u8 := USize.decLt x_3 x_2;
  case x_13 : u8 of
  Bool.false →
    let x_14 : obj := ctor_0[EStateM.Result.ok] x_4 x_12;
    ret x_14
  Bool.true →
    let x_15 : obj := Array.uget ◾ x_1 x_3 ◾;
    let x_16 : obj := proj[0] x_15;
    inc x_16;
    let x_17 : obj := proj[1] x_15;
    inc x_17;
    dec x_15;
    let x_18 : obj := proj[0] x_16;
    inc x_18;
    dec x_16;
    inc x_18;
    inc x_4;
    let x_19 : obj := Lean.HashMapImp.find?._at._private.Lean.Compiler.LCNF.CompilerM.0.Lean.Compiler.LCNF.normExprImp.go._spec_1 x_4 x_18;
    case x_19 : obj of
    Option.none →
      dec x_18;
      dec x_17;
      let x_20 : usize := 1;
      let x_21 : usize := USize.add x_3 x_20;
      let x_22 : obj := Array.forInUnsafe.loop._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_11 x_1 x_2 x_21 x_4 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12;
      ret x_22
    Option.some →
      let x_23 : obj := proj[0] x_19;
      inc x_23;
      dec x_19;
      let x_24 : obj := Lean.Compiler.LCNF.Arg.toExpr x_17;
      let x_25 : u8 := Lean.Expr.eqv x_24 x_23;
      dec x_23;
      dec x_24;
      case x_25 : u8 of
      Bool.false →
        let x_26 : obj := Lean.HashMapImp.erase._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_9 x_4 x_18;
        dec x_18;
        let x_27 : usize := 1;
        let x_28 : usize := USize.add x_3 x_27;
        let x_29 : obj := Array.forInUnsafe.loop._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_11 x_1 x_2 x_28 x_26 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12;
        ret x_29
      Bool.true →
        dec x_18;
        let x_30 : usize := 1;
        let x_31 : usize := USize.add x_3 x_30;
        let x_32 : obj := Array.forInUnsafe.loop._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_11 x_1 x_2 x_31 x_4 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12;
        ret x_32
def Lean.Compiler.LCNF.ScopeM.withBackTrackingScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_13 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  let x_10 : obj := Lean.Compiler.LCNF.ScopeM.getScope x_4 x_5 x_6 x_7 x_8 x_9;
  let x_11 : obj := proj[0] x_10;
  inc x_11;
  let x_12 : obj := proj[1] x_10;
  inc x_12;
  dec x_10;
  inc x_8;
  inc x_7;
  inc x_6;
  inc x_5;
  inc x_4;
  let x_13 : obj := app x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_12;
  case x_13 : obj of
  EStateM.Result.ok →
    let x_14 : obj := proj[0] x_13;
    inc x_14;
    let x_15 : obj := proj[1] x_13;
    inc x_15;
    dec x_13;
    let x_16 : obj := Lean.Compiler.LCNF.ScopeM.setScope x_11 x_4 x_5 x_6 x_7 x_8 x_15;
    dec x_8;
    dec x_7;
    dec x_6;
    dec x_5;
    dec x_4;
    let x_17 : u8 := isShared x_16;
    case x_17 : u8 of
    Bool.false →
      let x_18 : obj := proj[0] x_16;
      dec x_18;
      set x_16[0] := x_14;
      ret x_16
    Bool.true →
      let x_19 : obj := proj[1] x_16;
      inc x_19;
      dec x_16;
      let x_20 : obj := ctor_0[EStateM.Result.ok] x_14 x_19;
      ret x_20
  EStateM.Result.error →
    let x_21 : obj := proj[0] x_13;
    inc x_21;
    let x_22 : obj := proj[1] x_13;
    inc x_22;
    dec x_13;
    let x_23 : obj := Lean.Compiler.LCNF.ScopeM.setScope x_11 x_4 x_5 x_6 x_7 x_8 x_22;
    dec x_8;
    dec x_7;
    dec x_6;
    dec x_5;
    dec x_4;
    let x_24 : u8 := isShared x_23;
    case x_24 : u8 of
    Bool.false →
      let x_25 : obj := proj[0] x_23;
      dec x_25;
      setTag x_23 := 1;
      set x_23[0] := x_21;
      ret x_23
    Bool.true →
      let x_26 : obj := proj[1] x_23;
      inc x_26;
      dec x_23;
      let x_27 : obj := ctor_1[EStateM.Result.error] x_21 x_26;
      ret x_27
def Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_12 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  let x_10 : obj := pap Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointFinder.find.go._spec_2._lambda_2._boxed x_1;
  let x_11 : obj := Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointFinder.find.go._spec_2._closed_1;
  let x_12 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg x_11 x_10;
  let x_13 : obj := Lean.Compiler.LCNF.ScopeM.withBackTrackingScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_13 x_12 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
  ret x_13
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14._lambda_1 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) : obj :=
  dec x_2;
  let x_11 : obj := Lean.Compiler.LCNF.AltCore.getCode x_1;
  dec x_1;
  let x_12 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze x_11 x_3 x_4 x_5 x_6 x_7 x_8 x_9 x_10;
  ret x_12
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14._boxed_const_1 : obj :=
  let x_1 : usize := 0;
  let x_2 : obj := box x_1;
  ret x_2
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14 (x_1 : @& obj) (x_2 : usize) (x_3 : usize) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) (x_11 : obj) (x_12 : obj) : obj :=
  let x_13 : u8 := USize.decEq x_2 x_3;
  case x_13 : u8 of
  Bool.false →
    dec x_4;
    let x_14 : obj := Array.uget ◾ x_1 x_2 ◾;
    let x_15 : obj := Lean.Compiler.LCNF.AltCore.getParams x_14;
    let x_16 : obj := Array.size ◾ x_15;
    let x_17 : obj := 0;
    let x_18 : u8 := Nat.decLt x_17 x_16;
    let x_19 : obj := pap Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14._lambda_1 x_14;
    case x_18 : u8 of
    Bool.false →
      dec x_16;
      dec x_15;
      let x_20 : obj := ctor_0[PUnit.unit];
      let x_21 : obj := pap ReaderT.pure._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_1._rarg._boxed x_20;
      let x_22 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg x_21 x_19;
      inc x_11;
      inc x_10;
      inc x_9;
      inc x_8;
      inc x_7;
      inc x_6;
      inc x_5;
      let x_23 : obj := Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_12 x_22 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12;
      case x_23 : obj of
      EStateM.Result.ok →
        let x_24 : obj := proj[0] x_23;
        inc x_24;
        let x_25 : obj := proj[1] x_23;
        inc x_25;
        dec x_23;
        let x_26 : usize := 1;
        let x_27 : usize := USize.add x_2 x_26;
        let x_28 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14 x_1 x_27 x_3 x_24 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_25;
        ret x_28
      EStateM.Result.error →
        dec x_11;
        dec x_10;
        dec x_9;
        dec x_8;
        dec x_7;
        dec x_6;
        dec x_5;
        let x_29 : u8 := isShared x_23;
        case x_29 : u8 of
        Bool.false →
          ret x_23
        Bool.true →
          let x_30 : obj := proj[0] x_23;
          let x_31 : obj := proj[1] x_23;
          inc x_31;
          inc x_30;
          dec x_23;
          let x_32 : obj := ctor_1[EStateM.Result.error] x_30 x_31;
          ret x_32
    Bool.true →
      let x_33 : u8 := Nat.decLe x_16 x_16;
      case x_33 : u8 of
      Bool.false →
        dec x_16;
        dec x_15;
        let x_34 : obj := ctor_0[PUnit.unit];
        let x_35 : obj := pap ReaderT.pure._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_1._rarg._boxed x_34;
        let x_36 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg x_35 x_19;
        inc x_11;
        inc x_10;
        inc x_9;
        inc x_8;
        inc x_7;
        inc x_6;
        inc x_5;
        let x_37 : obj := Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_12 x_36 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12;
        case x_37 : obj of
        EStateM.Result.ok →
          let x_38 : obj := proj[0] x_37;
          inc x_38;
          let x_39 : obj := proj[1] x_37;
          inc x_39;
          dec x_37;
          let x_40 : usize := 1;
          let x_41 : usize := USize.add x_2 x_40;
          let x_42 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14 x_1 x_41 x_3 x_38 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_39;
          ret x_42
        EStateM.Result.error →
          dec x_11;
          dec x_10;
          dec x_9;
          dec x_8;
          dec x_7;
          dec x_6;
          dec x_5;
          let x_43 : u8 := isShared x_37;
          case x_43 : u8 of
          Bool.false →
            ret x_37
          Bool.true →
            let x_44 : obj := proj[0] x_37;
            let x_45 : obj := proj[1] x_37;
            inc x_45;
            inc x_44;
            dec x_37;
            let x_46 : obj := ctor_1[EStateM.Result.error] x_44 x_45;
            ret x_46
      Bool.true →
        let x_47 : usize := USize.ofNat x_16;
        dec x_16;
        let x_48 : obj := ctor_0[PUnit.unit];
        let x_49 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14._boxed_const_1;
        let x_50 : obj := box x_47;
        let x_51 : obj := pap Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_5._boxed x_15 x_49 x_50 x_48;
        let x_52 : obj := pap ReaderT.bind._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_2._rarg x_51 x_19;
        inc x_11;
        inc x_10;
        inc x_9;
        inc x_8;
        inc x_7;
        inc x_6;
        inc x_5;
        let x_53 : obj := Lean.Compiler.LCNF.ScopeM.withNewScope._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_12 x_52 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12;
        case x_53 : obj of
        EStateM.Result.ok →
          let x_54 : obj := proj[0] x_53;
          inc x_54;
          let x_55 : obj := proj[1] x_53;
          inc x_55;
          dec x_53;
          let x_56 : usize := 1;
          let x_57 : usize := USize.add x_2 x_56;
          let x_58 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14 x_1 x_57 x_3 x_54 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_55;
          ret x_58
        EStateM.Result.error →
          dec x_11;
          dec x_10;
          dec x_9;
          dec x_8;
          dec x_7;
          dec x_6;
          dec x_5;
          let x_59 : u8 := isShared x_53;
          case x_59 : u8 of
          Bool.false →
            ret x_53
          Bool.true →
            let x_60 : obj := proj[0] x_53;
            let x_61 : obj := proj[1] x_53;
            inc x_61;
            inc x_60;
            dec x_53;
            let x_62 : obj := ctor_1[EStateM.Result.error] x_60 x_61;
            ret x_62
  Bool.true →
    dec x_11;
    dec x_10;
    dec x_9;
    dec x_8;
    dec x_7;
    dec x_6;
    dec x_5;
    let x_63 : obj := ctor_0[EStateM.Result.ok] x_4 x_12;
    ret x_63
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  case x_1 : obj of
  Lean.Compiler.LCNF.Code.let →
    let x_10 : obj := proj[0] x_1;
    inc x_10;
    let x_11 : obj := proj[1] x_1;
    inc x_11;
    dec x_1;
    let x_12 : obj := proj[0] x_10;
    inc x_12;
    dec x_10;
    let x_13 : obj := Lean.Compiler.LCNF.ScopeM.addToScope x_12 x_4 x_5 x_6 x_7 x_8 x_9;
    let x_14 : obj := proj[1] x_13;
    inc x_14;
    dec x_13;
    let x_15 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze x_11 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_14;
    ret x_15
  Lean.Compiler.LCNF.Code.fun →
    let x_16 : obj := proj[0] x_1;
    inc x_16;
    let x_17 : obj := proj[1] x_1;
    inc x_17;
    dec x_1;
    inc x_8;
    inc x_7;
    inc x_6;
    inc x_5;
    inc x_4;
    inc x_3;
    inc x_2;
    inc x_16;
    let x_18 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl x_16 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
    case x_18 : obj of
    EStateM.Result.ok →
      let x_19 : obj := proj[1] x_18;
      inc x_19;
      dec x_18;
      let x_20 : obj := proj[0] x_16;
      inc x_20;
      dec x_16;
      let x_21 : obj := Lean.Compiler.LCNF.ScopeM.addToScope x_20 x_4 x_5 x_6 x_7 x_8 x_19;
      let x_22 : obj := proj[1] x_21;
      inc x_22;
      dec x_21;
      let x_23 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze x_17 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_22;
      ret x_23
    EStateM.Result.error →
      dec x_17;
      dec x_16;
      dec x_8;
      dec x_7;
      dec x_6;
      dec x_5;
      dec x_4;
      dec x_3;
      dec x_2;
      let x_24 : u8 := isShared x_18;
      case x_24 : u8 of
      Bool.false →
        ret x_18
      Bool.true →
        let x_25 : obj := proj[0] x_18;
        let x_26 : obj := proj[1] x_18;
        inc x_26;
        inc x_25;
        dec x_18;
        let x_27 : obj := ctor_1[EStateM.Result.error] x_25 x_26;
        ret x_27
  Lean.Compiler.LCNF.Code.jp →
    let x_28 : obj := proj[0] x_1;
    inc x_28;
    let x_29 : obj := proj[1] x_1;
    inc x_29;
    dec x_1;
    inc x_8;
    inc x_7;
    inc x_6;
    inc x_5;
    inc x_4;
    inc x_3;
    inc x_2;
    inc x_28;
    let x_30 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl x_28 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
    case x_30 : obj of
    EStateM.Result.ok →
      let x_31 : obj := proj[1] x_30;
      inc x_31;
      dec x_30;
      let x_32 : obj := Lean.Compiler.LCNF.ScopeM.getScope x_4 x_5 x_6 x_7 x_8 x_31;
      let x_33 : obj := proj[0] x_32;
      inc x_33;
      let x_34 : obj := proj[1] x_32;
      inc x_34;
      dec x_32;
      let x_35 : obj := proj[0] x_28;
      inc x_35;
      dec x_28;
      inc x_35;
      let x_36 : obj := Lean.RBNode.insert._at.Lean.FVarIdMap.insert._spec_1._rarg x_2 x_35 x_33;
      let x_37 : obj := Lean.Compiler.LCNF.ScopeM.addToScope x_35 x_4 x_5 x_6 x_7 x_8 x_34;
      let x_38 : obj := proj[1] x_37;
      inc x_38;
      dec x_37;
      let x_39 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze x_29 x_36 x_3 x_4 x_5 x_6 x_7 x_8 x_38;
      ret x_39
    EStateM.Result.error →
      dec x_29;
      dec x_28;
      dec x_8;
      dec x_7;
      dec x_6;
      dec x_5;
      dec x_4;
      dec x_3;
      dec x_2;
      let x_40 : u8 := isShared x_30;
      case x_40 : u8 of
      Bool.false →
        ret x_30
      Bool.true →
        let x_41 : obj := proj[0] x_30;
        let x_42 : obj := proj[1] x_30;
        inc x_42;
        inc x_41;
        dec x_30;
        let x_43 : obj := ctor_1[EStateM.Result.error] x_41 x_42;
        ret x_43
  Lean.Compiler.LCNF.Code.jmp →
    let x_44 : obj := proj[0] x_1;
    inc x_44;
    let x_45 : obj := proj[1] x_1;
    inc x_45;
    dec x_1;
    inc x_44;
    let x_46 : obj := Lean.Compiler.LCNF.getFunDecl x_44 x_5 x_6 x_7 x_8 x_9;
    case x_46 : obj of
    EStateM.Result.ok →
      let x_47 : obj := proj[0] x_46;
      inc x_47;
      let x_48 : obj := proj[1] x_46;
      inc x_48;
      dec x_46;
      let x_49 : obj := ST.Prim.Ref.get ◾ ◾ x_3 x_48;
      let x_50 : obj := proj[0] x_49;
      inc x_50;
      let x_51 : obj := proj[1] x_49;
      inc x_51;
      dec x_49;
      let x_52 : obj := Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1 x_50 x_44;
      dec x_50;
      case x_52 : obj of
      Option.none →
        let x_53 : obj := 8;
        let x_54 : obj := Lean.mkHashMapImp._rarg x_53;
        let x_55 : obj := proj[2] x_47;
        inc x_55;
        dec x_47;
        let x_56 : obj := Array.zip._rarg x_55 x_45;
        dec x_45;
        dec x_55;
        let x_57 : obj := Array.size ◾ x_56;
        let x_58 : obj := 0;
        let x_59 : u8 := Nat.decLt x_58 x_57;
        case x_59 : u8 of
        Bool.false →
          dec x_57;
          dec x_56;
          dec x_8;
          dec x_7;
          dec x_6;
          dec x_5;
          dec x_4;
          dec x_2;
          let x_60 : obj := ST.Prim.Ref.take ◾ ◾ x_3 x_51;
          let x_61 : obj := proj[0] x_60;
          inc x_61;
          let x_62 : obj := proj[1] x_60;
          inc x_62;
          dec x_60;
          let x_63 : obj := Lean.RBNode.insert._at.Lean.FVarIdMap.insert._spec_1._rarg x_61 x_44 x_54;
          let x_64 : obj := ST.Prim.Ref.set ◾ ◾ x_3 x_63 x_62;
          dec x_3;
          let x_65 : u8 := isShared x_64;
          case x_65 : u8 of
          Bool.false →
            let x_66 : obj := proj[0] x_64;
            dec x_66;
            let x_67 : obj := ctor_0[PUnit.unit];
            set x_64[0] := x_67;
            ret x_64
          Bool.true →
            let x_68 : obj := proj[1] x_64;
            inc x_68;
            dec x_64;
            let x_69 : obj := ctor_0[PUnit.unit];
            let x_70 : obj := ctor_0[EStateM.Result.ok] x_69 x_68;
            ret x_70
        Bool.true →
          let x_71 : u8 := Nat.decLe x_57 x_57;
          case x_71 : u8 of
          Bool.false →
            dec x_57;
            dec x_56;
            dec x_8;
            dec x_7;
            dec x_6;
            dec x_5;
            dec x_4;
            dec x_2;
            let x_72 : obj := ST.Prim.Ref.take ◾ ◾ x_3 x_51;
            let x_73 : obj := proj[0] x_72;
            inc x_73;
            let x_74 : obj := proj[1] x_72;
            inc x_74;
            dec x_72;
            let x_75 : obj := Lean.RBNode.insert._at.Lean.FVarIdMap.insert._spec_1._rarg x_73 x_44 x_54;
            let x_76 : obj := ST.Prim.Ref.set ◾ ◾ x_3 x_75 x_74;
            dec x_3;
            let x_77 : u8 := isShared x_76;
            case x_77 : u8 of
            Bool.false →
              let x_78 : obj := proj[0] x_76;
              dec x_78;
              let x_79 : obj := ctor_0[PUnit.unit];
              set x_76[0] := x_79;
              ret x_76
            Bool.true →
              let x_80 : obj := proj[1] x_76;
              inc x_80;
              dec x_76;
              let x_81 : obj := ctor_0[PUnit.unit];
              let x_82 : obj := ctor_0[EStateM.Result.ok] x_81 x_80;
              ret x_82
          Bool.true →
            let x_83 : usize := 0;
            let x_84 : usize := USize.ofNat x_57;
            dec x_57;
            inc x_3;
            inc x_44;
            let x_85 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_8 x_44 x_56 x_83 x_84 x_54 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_51;
            dec x_56;
            case x_85 : obj of
            EStateM.Result.ok →
              let x_86 : obj := proj[0] x_85;
              inc x_86;
              let x_87 : obj := proj[1] x_85;
              inc x_87;
              dec x_85;
              let x_88 : obj := ST.Prim.Ref.take ◾ ◾ x_3 x_87;
              let x_89 : obj := proj[0] x_88;
              inc x_89;
              let x_90 : obj := proj[1] x_88;
              inc x_90;
              dec x_88;
              let x_91 : obj := Lean.RBNode.insert._at.Lean.FVarIdMap.insert._spec_1._rarg x_89 x_44 x_86;
              let x_92 : obj := ST.Prim.Ref.set ◾ ◾ x_3 x_91 x_90;
              dec x_3;
              let x_93 : u8 := isShared x_92;
              case x_93 : u8 of
              Bool.false →
                let x_94 : obj := proj[0] x_92;
                dec x_94;
                let x_95 : obj := ctor_0[PUnit.unit];
                set x_92[0] := x_95;
                ret x_92
              Bool.true →
                let x_96 : obj := proj[1] x_92;
                inc x_96;
                dec x_92;
                let x_97 : obj := ctor_0[PUnit.unit];
                let x_98 : obj := ctor_0[EStateM.Result.ok] x_97 x_96;
                ret x_98
            EStateM.Result.error →
              dec x_44;
              dec x_3;
              let x_99 : u8 := isShared x_85;
              case x_99 : u8 of
              Bool.false →
                ret x_85
              Bool.true →
                let x_100 : obj := proj[0] x_85;
                let x_101 : obj := proj[1] x_85;
                inc x_101;
                inc x_100;
                dec x_85;
                let x_102 : obj := ctor_1[EStateM.Result.error] x_100 x_101;
                ret x_102
      Option.some →
        let x_103 : obj := proj[0] x_52;
        inc x_103;
        dec x_52;
        let x_104 : obj := proj[2] x_47;
        inc x_104;
        dec x_47;
        let x_105 : obj := Array.zip._rarg x_104 x_45;
        dec x_45;
        dec x_104;
        let x_106 : obj := Array.size ◾ x_105;
        let x_107 : usize := USize.ofNat x_106;
        dec x_106;
        let x_108 : usize := 0;
        let x_109 : obj := Array.forInUnsafe.loop._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_11 x_105 x_107 x_108 x_103 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_51;
        dec x_8;
        dec x_7;
        dec x_6;
        dec x_5;
        dec x_4;
        dec x_2;
        dec x_105;
        let x_110 : obj := proj[0] x_109;
        inc x_110;
        let x_111 : obj := proj[1] x_109;
        inc x_111;
        dec x_109;
        let x_112 : obj := ST.Prim.Ref.take ◾ ◾ x_3 x_111;
        let x_113 : obj := proj[0] x_112;
        inc x_113;
        let x_114 : obj := proj[1] x_112;
        inc x_114;
        dec x_112;
        let x_115 : obj := Lean.RBNode.insert._at.Lean.FVarIdMap.insert._spec_1._rarg x_113 x_44 x_110;
        let x_116 : obj := ST.Prim.Ref.set ◾ ◾ x_3 x_115 x_114;
        dec x_3;
        let x_117 : u8 := isShared x_116;
        case x_117 : u8 of
        Bool.false →
          let x_118 : obj := proj[0] x_116;
          dec x_118;
          let x_119 : obj := ctor_0[PUnit.unit];
          set x_116[0] := x_119;
          ret x_116
        Bool.true →
          let x_120 : obj := proj[1] x_116;
          inc x_120;
          dec x_116;
          let x_121 : obj := ctor_0[PUnit.unit];
          let x_122 : obj := ctor_0[EStateM.Result.ok] x_121 x_120;
          ret x_122
    EStateM.Result.error →
      dec x_45;
      dec x_44;
      dec x_8;
      dec x_7;
      dec x_6;
      dec x_5;
      dec x_4;
      dec x_3;
      dec x_2;
      let x_123 : u8 := isShared x_46;
      case x_123 : u8 of
      Bool.false →
        ret x_46
      Bool.true →
        let x_124 : obj := proj[0] x_46;
        let x_125 : obj := proj[1] x_46;
        inc x_125;
        inc x_124;
        dec x_46;
        let x_126 : obj := ctor_1[EStateM.Result.error] x_124 x_125;
        ret x_126
  Lean.Compiler.LCNF.Code.cases →
    let x_127 : obj := proj[0] x_1;
    inc x_127;
    dec x_1;
    let x_128 : obj := proj[3] x_127;
    inc x_128;
    dec x_127;
    let x_129 : obj := Array.size ◾ x_128;
    let x_130 : obj := 0;
    let x_131 : u8 := Nat.decLt x_130 x_129;
    case x_131 : u8 of
    Bool.false →
      dec x_129;
      dec x_128;
      dec x_8;
      dec x_7;
      dec x_6;
      dec x_5;
      dec x_4;
      dec x_3;
      dec x_2;
      let x_132 : obj := ctor_0[PUnit.unit];
      let x_133 : obj := ctor_0[EStateM.Result.ok] x_132 x_9;
      ret x_133
    Bool.true →
      let x_134 : u8 := Nat.decLe x_129 x_129;
      case x_134 : u8 of
      Bool.false →
        dec x_129;
        dec x_128;
        dec x_8;
        dec x_7;
        dec x_6;
        dec x_5;
        dec x_4;
        dec x_3;
        dec x_2;
        let x_135 : obj := ctor_0[PUnit.unit];
        let x_136 : obj := ctor_0[EStateM.Result.ok] x_135 x_9;
        ret x_136
      Bool.true →
        let x_137 : usize := 0;
        let x_138 : usize := USize.ofNat x_129;
        dec x_129;
        let x_139 : obj := ctor_0[PUnit.unit];
        let x_140 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14 x_128 x_137 x_138 x_139 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
        dec x_128;
        ret x_140
  default →
    dec x_8;
    dec x_7;
    dec x_6;
    dec x_5;
    dec x_4;
    dec x_3;
    dec x_2;
    dec x_1;
    let x_141 : obj := ctor_0[PUnit.unit];
    let x_142 : obj := ctor_0[EStateM.Result.ok] x_141 x_9;
    ret x_142
def ReaderT.pure._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_1._rarg._boxed (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  let x_10 : obj := ReaderT.pure._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_1._rarg x_1 x_2 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
  dec x_8;
  dec x_7;
  dec x_6;
  dec x_5;
  dec x_4;
  dec x_3;
  dec x_2;
  ret x_10
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_5._boxed (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) (x_11 : obj) (x_12 : obj) : obj :=
  let x_13 : usize := unbox x_2;
  dec x_2;
  let x_14 : usize := unbox x_3;
  dec x_3;
  let x_15 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyzeFunDecl._spec_5 x_1 x_13 x_14 x_4 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12;
  dec x_11;
  dec x_10;
  dec x_9;
  dec x_8;
  dec x_7;
  dec x_6;
  dec x_5;
  dec x_1;
  ret x_15
def Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1._boxed (x_1 : obj) (x_2 : obj) : obj :=
  let x_3 : obj := Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1 x_1 x_2;
  dec x_2;
  dec x_1;
  ret x_3
def Lean.mkHashMap._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_7._boxed (x_1 : obj) : obj :=
  let x_2 : obj := Lean.mkHashMap._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_7 x_1;
  dec x_1;
  ret x_2
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_8._boxed (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) (x_11 : obj) (x_12 : obj) (x_13 : obj) : obj :=
  let x_14 : usize := unbox x_3;
  dec x_3;
  let x_15 : usize := unbox x_4;
  dec x_4;
  let x_16 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_8 x_1 x_2 x_14 x_15 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12 x_13;
  dec x_2;
  ret x_16
def Lean.AssocList.erase._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_10._boxed (x_1 : obj) (x_2 : obj) : obj :=
  let x_3 : obj := Lean.AssocList.erase._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_10 x_1 x_2;
  dec x_1;
  ret x_3
def Lean.HashMapImp.erase._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_9._boxed (x_1 : obj) (x_2 : obj) : obj :=
  let x_3 : obj := Lean.HashMapImp.erase._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_9 x_1 x_2;
  dec x_2;
  ret x_3
def Array.forInUnsafe.loop._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_11._boxed (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) (x_11 : obj) (x_12 : obj) : obj :=
  let x_13 : usize := unbox x_2;
  dec x_2;
  let x_14 : usize := unbox x_3;
  dec x_3;
  let x_15 : obj := Array.forInUnsafe.loop._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_11 x_1 x_13 x_14 x_4 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12;
  dec x_11;
  dec x_10;
  dec x_9;
  dec x_8;
  dec x_7;
  dec x_6;
  dec x_5;
  dec x_1;
  ret x_15
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14._boxed (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) (x_11 : obj) (x_12 : obj) : obj :=
  let x_13 : usize := unbox x_2;
  dec x_2;
  let x_14 : usize := unbox x_3;
  dec x_3;
  let x_15 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_14 x_1 x_13 x_14 x_4 x_5 x_6 x_7 x_8 x_9 x_10 x_11 x_12;
  dec x_1;
  ret x_15
[result]
def Lean.HashMapImp.contains._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_1 (x_1 : @& obj) (x_2 : @& obj) : u8 :=
  let x_3 : obj := proj[1] x_1;
  let x_4 : obj := Array.size ◾ x_3;
  let x_5 : u64 := _private.Lean.Expr.0.Lean.hashFVarId._@.Lean.Expr._hyg.1674 x_2;
  let x_6 : usize := _private.Lean.Data.HashMap.0.Lean.HashMapImp.mkIdx x_4 x_5 ◾;
  let x_7 : obj := Array.uget ◾ x_3 x_6 ◾;
  let x_8 : u8 := Lean.AssocList.contains._at.Lean.Compiler.LCNF.addFVarSubst._spec_2 x_2 x_7;
  dec x_7;
  ret x_8
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2._lambda_1 (x_1 : u8) (x_2 : @& obj) (x_3 : @& obj) (x_4 : @& obj) (x_5 : @& obj) (x_6 : @& obj) (x_7 : @& obj) (x_8 : obj) : obj :=
  case x_1 : u8 of
  Bool.false →
    let x_9 : u8 := 1;
    let x_10 : obj := box x_9;
    let x_11 : obj := ctor_0[EStateM.Result.ok] x_10 x_8;
    ret x_11
  Bool.true →
    let x_12 : u8 := 0;
    let x_13 : obj := box x_12;
    let x_14 : obj := ctor_0[EStateM.Result.ok] x_13 x_8;
    ret x_14
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2 (x_1 : @& obj) (x_2 : @& obj) (x_3 : usize) (x_4 : usize) (x_5 : obj) (x_6 : @& obj) (x_7 : @& obj) (x_8 : @& obj) (x_9 : @& obj) (x_10 : @& obj) (x_11 : obj) : obj :=
  let x_12 : u8 := USize.decEq x_3 x_4;
  case x_12 : u8 of
  Bool.false →
    let x_13 : obj := Array.uget ◾ x_2 x_3 ◾;
    let x_14 : obj := proj[0] x_13;
    inc x_14;
    let x_15 : u8 := Lean.HashMapImp.contains._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_1 x_1 x_14;
    dec x_14;
    case x_15 : u8 of
    Bool.false →
      let x_16 : obj := ctor_0[PUnit.unit];
      let x_17 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2._lambda_1 x_15 x_16 x_6 x_7 x_8 x_9 x_10 x_11;
      let x_18 : obj := proj[0] x_17;
      inc x_18;
      let x_19 : u8 := unbox x_18;
      dec x_18;
      case x_19 : u8 of
      Bool.false →
        dec x_13;
        let x_20 : obj := proj[1] x_17;
        inc x_20;
        dec x_17;
        let x_21 : usize := 1;
        let x_22 : usize := USize.add x_3 x_21;
        let x_23 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2 x_1 x_2 x_22 x_4 x_5 x_6 x_7 x_8 x_9 x_10 x_20;
        ret x_23
      Bool.true →
        let x_24 : obj := proj[1] x_17;
        inc x_24;
        dec x_17;
        let x_25 : obj := Array.push ◾ x_5 x_13;
        let x_26 : usize := 1;
        let x_27 : usize := USize.add x_3 x_26;
        let x_28 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2 x_1 x_2 x_27 x_4 x_25 x_6 x_7 x_8 x_9 x_10 x_24;
        ret x_28
    Bool.true →
      let x_29 : obj := Lean.Compiler.LCNF.eraseParam x_13 x_7 x_8 x_9 x_10 x_11;
      let x_30 : obj := proj[0] x_29;
      inc x_30;
      let x_31 : obj := proj[1] x_29;
      inc x_31;
      dec x_29;
      let x_32 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2._lambda_1 x_15 x_30 x_6 x_7 x_8 x_9 x_10 x_31;
      dec x_30;
      let x_33 : obj := proj[0] x_32;
      inc x_33;
      let x_34 : u8 := unbox x_33;
      dec x_33;
      case x_34 : u8 of
      Bool.false →
        dec x_13;
        let x_35 : obj := proj[1] x_32;
        inc x_35;
        dec x_32;
        let x_36 : usize := 1;
        let x_37 : usize := USize.add x_3 x_36;
        let x_38 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2 x_1 x_2 x_37 x_4 x_5 x_6 x_7 x_8 x_9 x_10 x_35;
        ret x_38
      Bool.true →
        let x_39 : obj := proj[1] x_32;
        inc x_39;
        dec x_32;
        let x_40 : obj := Array.push ◾ x_5 x_13;
        let x_41 : usize := 1;
        let x_42 : usize := USize.add x_3 x_41;
        let x_43 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2 x_1 x_2 x_42 x_4 x_40 x_6 x_7 x_8 x_9 x_10 x_39;
        ret x_43
  Bool.true →
    let x_44 : obj := ctor_0[EStateM.Result.ok] x_5 x_11;
    ret x_44
def Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_3 (x_1 : usize) (x_2 : usize) (x_3 : obj) : obj :=
  let x_4 : u8 := USize.decLt x_2 x_1;
  case x_4 : u8 of
  Bool.false →
    ret x_3
  Bool.true →
    let x_5 : obj := Array.uget ◾ x_3 x_2 ◾;
    let x_6 : obj := 0;
    let x_7 : obj := Array.uset ◾ x_3 x_2 x_6 ◾;
    let x_8 : obj := proj[1] x_5;
    inc x_8;
    dec x_5;
    let x_9 : usize := 1;
    let x_10 : usize := USize.add x_2 x_9;
    let x_11 : obj := Array.uset ◾ x_7 x_2 x_8 ◾;
    let x_12 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_3 x_1 x_10 x_11;
    ret x_12
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_4 (x_1 : @& obj) (x_2 : @& obj) (x_3 : usize) (x_4 : usize) (x_5 : obj) : obj :=
  let x_6 : u8 := USize.decEq x_3 x_4;
  case x_6 : u8 of
  Bool.false →
    let x_7 : obj := Array.uget ◾ x_2 x_3 ◾;
    let x_8 : obj := proj[0] x_7;
    inc x_8;
    let x_9 : obj := proj[0] x_8;
    inc x_9;
    dec x_8;
    let x_10 : usize := 1;
    let x_11 : usize := USize.add x_3 x_10;
    let x_12 : u8 := Lean.HashMapImp.contains._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_1 x_1 x_9;
    dec x_9;
    case x_12 : u8 of
    Bool.false →
      let x_13 : obj := Array.push ◾ x_5 x_7;
      let x_14 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_4 x_1 x_2 x_11 x_4 x_13;
      ret x_14
    Bool.true →
      dec x_7;
      let x_15 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_4 x_1 x_2 x_11 x_4 x_5;
      ret x_15
  Bool.true →
    ret x_5
def panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_5 (x_1 : obj) : obj :=
  let x_2 : obj := Lean.Compiler.LCNF.JoinPointFinder.find._closed_1;
  let x_3 : obj := panicCore ◾ x_2 x_1;
  ret x_3
def Lean.Compiler.LCNF.AltCore.mapCodeM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_6 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) : obj :=
  let x_9 : obj := Lean.Compiler.LCNF.AltCore.getCode x_1;
  let x_10 : obj := app x_2 x_9 x_3 x_4 x_5 x_6 x_7 x_8;
  case x_10 : obj of
  EStateM.Result.ok →
    let x_11 : u8 := isShared x_10;
    case x_11 : u8 of
    Bool.false →
      let x_12 : obj := proj[0] x_10;
      let x_13 : obj := _private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltCodeImp x_1 x_12;
      set x_10[0] := x_13;
      ret x_10
    Bool.true →
      let x_14 : obj := proj[0] x_10;
      let x_15 : obj := proj[1] x_10;
      inc x_15;
      inc x_14;
      dec x_10;
      let x_16 : obj := _private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltCodeImp x_1 x_14;
      let x_17 : obj := ctor_0[EStateM.Result.ok] x_16 x_15;
      ret x_17
  EStateM.Result.error →
    dec x_1;
    let x_18 : u8 := isShared x_10;
    case x_18 : u8 of
    Bool.false →
      ret x_10
    Bool.true →
      let x_19 : obj := proj[0] x_10;
      let x_20 : obj := proj[1] x_10;
      inc x_20;
      inc x_19;
      dec x_10;
      let x_21 : obj := ctor_1[EStateM.Result.error] x_19 x_20;
      ret x_21
def Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_7._closed_1 : obj :=
  let x_1 : obj := pap Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce;
  ret x_1
def Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_7 (x_1 : usize) (x_2 : usize) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  let x_10 : u8 := USize.decLt x_2 x_1;
  case x_10 : u8 of
  Bool.false →
    dec x_8;
    dec x_7;
    dec x_6;
    dec x_5;
    dec x_4;
    let x_11 : obj := ctor_0[EStateM.Result.ok] x_3 x_9;
    ret x_11
  Bool.true →
    let x_12 : obj := Array.uget ◾ x_3 x_2 ◾;
    let x_13 : obj := 0;
    let x_14 : obj := Array.uset ◾ x_3 x_2 x_13 ◾;
    let x_15 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_7._closed_1;
    inc x_8;
    inc x_7;
    inc x_6;
    inc x_5;
    inc x_4;
    let x_16 : obj := Lean.Compiler.LCNF.AltCore.mapCodeM._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_6 x_12 x_15 x_4 x_5 x_6 x_7 x_8 x_9;
    case x_16 : obj of
    EStateM.Result.ok →
      let x_17 : obj := proj[0] x_16;
      inc x_17;
      let x_18 : obj := proj[1] x_16;
      inc x_18;
      dec x_16;
      let x_19 : usize := 1;
      let x_20 : usize := USize.add x_2 x_19;
      let x_21 : obj := Array.uset ◾ x_14 x_2 x_17 ◾;
      let x_22 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_7 x_1 x_20 x_21 x_4 x_5 x_6 x_7 x_8 x_18;
      ret x_22
    EStateM.Result.error →
      dec x_14;
      dec x_8;
      dec x_7;
      dec x_6;
      dec x_5;
      dec x_4;
      let x_23 : u8 := isShared x_16;
      case x_23 : u8 of
      Bool.false →
        ret x_16
      Bool.true →
        let x_24 : obj := proj[0] x_16;
        let x_25 : obj := proj[1] x_16;
        inc x_25;
        inc x_24;
        dec x_16;
        let x_26 : obj := ctor_1[EStateM.Result.error] x_24 x_25;
        ret x_26
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) (x_11 : obj) (x_12 : obj) : obj :=
  inc x_11;
  inc x_10;
  inc x_9;
  inc x_8;
  inc x_1;
  let x_13 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_1 x_7 x_8 x_9 x_10 x_11 x_12;
  case x_13 : obj of
  EStateM.Result.ok →
    let x_14 : u8 := isShared x_13;
    case x_14 : u8 of
    Bool.false →
      let x_15 : obj := proj[0] x_13;
      let x_16 : obj := proj[1] x_13;
      inc x_2;
      let x_17 : obj := _private.Lean.Compiler.LCNF.CompilerM.0.Lean.Compiler.LCNF.updateFunDeclImp x_2 x_6 x_3 x_4 x_8 x_9 x_10 x_11 x_16;
      dec x_11;
      dec x_10;
      dec x_9;
      dec x_8;
      let x_18 : u8 := isShared x_17;
      case x_18 : u8 of
      Bool.false →
        let x_19 : obj := proj[0] x_17;
        let x_20 : obj := proj[1] x_17;
        let x_21 : usize := ptrAddrUnsafe ◾ x_1;
        dec x_1;
        let x_22 : usize := ptrAddrUnsafe ◾ x_15;
        let x_23 : u8 := USize.decEq x_21 x_22;
        case x_23 : u8 of
        Bool.false →
          dec x_5;
          dec x_2;
          setTag x_17 := 2;
          set x_17[1] := x_15;
          set x_13[1] := x_20;
          set x_13[0] := x_17;
          ret x_13
        Bool.true →
          let x_24 : usize := ptrAddrUnsafe ◾ x_2;
          dec x_2;
          let x_25 : usize := ptrAddrUnsafe ◾ x_19;
          let x_26 : u8 := USize.decEq x_24 x_25;
          case x_26 : u8 of
          Bool.false →
            dec x_5;
            setTag x_17 := 2;
            set x_17[1] := x_15;
            set x_13[1] := x_20;
            set x_13[0] := x_17;
            ret x_13
          Bool.true →
            dec x_19;
            del x_13;
            dec x_15;
            set x_17[0] := x_5;
            ret x_17
      Bool.true →
        let x_27 : obj := proj[0] x_17;
        let x_28 : obj := proj[1] x_17;
        inc x_28;
        inc x_27;
        dec x_17;
        let x_29 : usize := ptrAddrUnsafe ◾ x_1;
        dec x_1;
        let x_30 : usize := ptrAddrUnsafe ◾ x_15;
        let x_31 : u8 := USize.decEq x_29 x_30;
        case x_31 : u8 of
        Bool.false →
          dec x_5;
          dec x_2;
          let x_32 : obj := ctor_2[Lean.Compiler.LCNF.Code.jp] x_27 x_15;
          set x_13[1] := x_28;
          set x_13[0] := x_32;
          ret x_13
        Bool.true →
          let x_33 : usize := ptrAddrUnsafe ◾ x_2;
          dec x_2;
          let x_34 : usize := ptrAddrUnsafe ◾ x_27;
          let x_35 : u8 := USize.decEq x_33 x_34;
          case x_35 : u8 of
          Bool.false →
            dec x_5;
            let x_36 : obj := ctor_2[Lean.Compiler.LCNF.Code.jp] x_27 x_15;
            set x_13[1] := x_28;
            set x_13[0] := x_36;
            ret x_13
          Bool.true →
            dec x_27;
            del x_13;
            dec x_15;
            let x_37 : obj := ctor_0[EStateM.Result.ok] x_5 x_28;
            ret x_37
    Bool.true →
      let x_38 : obj := proj[0] x_13;
      let x_39 : obj := proj[1] x_13;
      inc x_39;
      inc x_38;
      dec x_13;
      inc x_2;
      let x_40 : obj := _private.Lean.Compiler.LCNF.CompilerM.0.Lean.Compiler.LCNF.updateFunDeclImp x_2 x_6 x_3 x_4 x_8 x_9 x_10 x_11 x_39;
      dec x_11;
      dec x_10;
      dec x_9;
      dec x_8;
      let x_41 : obj := proj[0] x_40;
      inc x_41;
      let x_42 : obj := proj[1] x_40;
      inc x_42;
      let x_43 : obj := reset[2] x_40;
      let x_44 : usize := ptrAddrUnsafe ◾ x_1;
      dec x_1;
      let x_45 : usize := ptrAddrUnsafe ◾ x_38;
      let x_46 : u8 := USize.decEq x_44 x_45;
      case x_46 : u8 of
      Bool.false →
        dec x_5;
        dec x_2;
        let x_47 : obj := reuse! x_43 in ctor_2[Lean.Compiler.LCNF.Code.jp] x_41 x_38;
        let x_48 : obj := ctor_0[EStateM.Result.ok] x_47 x_42;
        ret x_48
      Bool.true →
        let x_49 : usize := ptrAddrUnsafe ◾ x_2;
        dec x_2;
        let x_50 : usize := ptrAddrUnsafe ◾ x_41;
        let x_51 : u8 := USize.decEq x_49 x_50;
        case x_51 : u8 of
        Bool.false →
          dec x_5;
          let x_52 : obj := reuse! x_43 in ctor_2[Lean.Compiler.LCNF.Code.jp] x_41 x_38;
          let x_53 : obj := ctor_0[EStateM.Result.ok] x_52 x_42;
          ret x_53
        Bool.true →
          dec x_41;
          dec x_38;
          let x_54 : obj := reuse x_43 in ctor_0[EStateM.Result.ok] x_5 x_42;
          ret x_54
  EStateM.Result.error →
    dec x_11;
    dec x_10;
    dec x_9;
    dec x_8;
    dec x_6;
    dec x_5;
    dec x_4;
    dec x_3;
    dec x_2;
    dec x_1;
    let x_55 : u8 := isShared x_13;
    case x_55 : u8 of
    Bool.false →
      ret x_13
    Bool.true →
      let x_56 : obj := proj[0] x_13;
      let x_57 : obj := proj[1] x_13;
      inc x_57;
      inc x_56;
      dec x_13;
      let x_58 : obj := ctor_1[EStateM.Result.error] x_56 x_57;
      ret x_58
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1 : obj :=
  let x_1 : obj := 0;
  let x_2 : obj := Array.mkEmpty ◾ x_1;
  ret x_2
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_2 : obj :=
  let x_1 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
  let x_2 : obj := Array.size ◾ x_1;
  dec x_1;
  ret x_2
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_3 : obj :=
  let x_1 : obj := "Lean.Compiler.LCNF.Basic";
  ret x_1
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_4 : obj :=
  let x_1 : obj := "_private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateJmpImp";
  ret x_1
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5 : obj :=
  let x_1 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_3;
  let x_2 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_4;
  let x_3 : obj := 318;
  let x_4 : obj := 9;
  let x_5 : obj := Lean.Compiler.LCNF.Expr.forFVarM._at._private.miscompile.0.Lean.Compiler.LCNF.JoinPointFinder.removeCandidatesInArg._spec_2._closed_3;
  let x_6 : obj := _private.Init.Util.0.mkPanicMessageWithDecl x_1 x_2 x_3 x_4 x_5;
  dec x_5;
  dec x_2;
  dec x_1;
  ret x_6
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) : obj :=
  case x_1 : obj of
  Lean.Compiler.LCNF.Code.let →
    let x_8 : obj := proj[0] x_1;
    inc x_8;
    let x_9 : obj := proj[1] x_1;
    inc x_9;
    inc x_9;
    let x_10 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_9 x_2 x_3 x_4 x_5 x_6 x_7;
    case x_10 : obj of
    EStateM.Result.ok →
      let x_11 : u8 := isShared x_10;
      case x_11 : u8 of
      Bool.false →
        let x_12 : obj := proj[0] x_10;
        let x_13 : obj := proj[1] x_10;
        let x_14 : usize := ptrAddrUnsafe ◾ x_9;
        dec x_9;
        let x_15 : usize := ptrAddrUnsafe ◾ x_12;
        let x_16 : u8 := USize.decEq x_14 x_15;
        case x_16 : u8 of
        Bool.false →
          let x_17 : u8 := isShared x_1;
          case x_17 : u8 of
          Bool.false →
            let x_18 : obj := proj[1] x_1;
            dec x_18;
            let x_19 : obj := proj[0] x_1;
            dec x_19;
            set x_10[1] := x_12;
            set x_10[0] := x_8;
            set x_1[1] := x_13;
            set x_1[0] := x_10;
            ret x_1
          Bool.true →
            dec x_1;
            set x_10[1] := x_12;
            set x_10[0] := x_8;
            let x_20 : obj := ctor_0[EStateM.Result.ok] x_10 x_13;
            ret x_20
        Bool.true →
          let x_21 : usize := ptrAddrUnsafe ◾ x_8;
          let x_22 : u8 := USize.decEq x_21 x_21;
          case x_22 : u8 of
          Bool.false →
            let x_23 : u8 := isShared x_1;
            case x_23 : u8 of
            Bool.false →
              let x_24 : obj := proj[1] x_1;
              dec x_24;
              let x_25 : obj := proj[0] x_1;
              dec x_25;
              set x_10[1] := x_12;
              set x_10[0] := x_8;
              set x_1[1] := x_13;
              set x_1[0] := x_10;
              ret x_1
            Bool.true →
              dec x_1;
              set x_10[1] := x_12;
              set x_10[0] := x_8;
              let x_26 : obj := ctor_0[EStateM.Result.ok] x_10 x_13;
              ret x_26
          Bool.true →
            dec x_12;
            dec x_8;
            set x_10[0] := x_1;
            ret x_10
      Bool.true →
        let x_27 : obj := proj[0] x_10;
        let x_28 : obj := proj[1] x_10;
        inc x_28;
        inc x_27;
        dec x_10;
        let x_29 : usize := ptrAddrUnsafe ◾ x_9;
        dec x_9;
        let x_30 : usize := ptrAddrUnsafe ◾ x_27;
        let x_31 : u8 := USize.decEq x_29 x_30;
        case x_31 : u8 of
        Bool.false →
          let x_32 : obj := reset[2] x_1;
          let x_33 : obj := ctor_0[Lean.Compiler.LCNF.Code.let] x_8 x_27;
          let x_34 : obj := reuse x_32 in ctor_0[EStateM.Result.ok] x_33 x_28;
          ret x_34
        Bool.true →
          let x_35 : usize := ptrAddrUnsafe ◾ x_8;
          let x_36 : u8 := USize.decEq x_35 x_35;
          case x_36 : u8 of
          Bool.false →
            let x_37 : obj := reset[2] x_1;
            let x_38 : obj := ctor_0[Lean.Compiler.LCNF.Code.let] x_8 x_27;
            let x_39 : obj := reuse x_37 in ctor_0[EStateM.Result.ok] x_38 x_28;
            ret x_39
          Bool.true →
            dec x_27;
            dec x_8;
            let x_40 : obj := ctor_0[EStateM.Result.ok] x_1 x_28;
            ret x_40
    EStateM.Result.error →
      dec x_9;
      dec x_8;
      dec x_1;
      let x_41 : u8 := isShared x_10;
      case x_41 : u8 of
      Bool.false →
        ret x_10
      Bool.true →
        let x_42 : obj := proj[0] x_10;
        let x_43 : obj := proj[1] x_10;
        inc x_43;
        inc x_42;
        dec x_10;
        let x_44 : obj := ctor_1[EStateM.Result.error] x_42 x_43;
        ret x_44
  Lean.Compiler.LCNF.Code.fun →
    let x_45 : obj := proj[0] x_1;
    inc x_45;
    let x_46 : obj := proj[1] x_1;
    inc x_46;
    let x_47 : obj := proj[4] x_45;
    inc x_47;
    inc x_6;
    inc x_5;
    inc x_4;
    inc x_3;
    inc x_2;
    let x_48 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_47 x_2 x_3 x_4 x_5 x_6 x_7;
    case x_48 : obj of
    EStateM.Result.ok →
      let x_49 : obj := proj[0] x_48;
      inc x_49;
      let x_50 : obj := proj[1] x_48;
      inc x_50;
      dec x_48;
      let x_51 : obj := proj[3] x_45;
      inc x_51;
      let x_52 : obj := proj[2] x_45;
      inc x_52;
      inc x_45;
      let x_53 : obj := _private.Lean.Compiler.LCNF.CompilerM.0.Lean.Compiler.LCNF.updateFunDeclImp x_45 x_51 x_52 x_49 x_3 x_4 x_5 x_6 x_50;
      let x_54 : u8 := isShared x_53;
      case x_54 : u8 of
      Bool.false →
        let x_55 : obj := proj[0] x_53;
        let x_56 : obj := proj[1] x_53;
        inc x_46;
        let x_57 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_46 x_2 x_3 x_4 x_5 x_6 x_56;
        case x_57 : obj of
        EStateM.Result.ok →
          let x_58 : u8 := isShared x_57;
          case x_58 : u8 of
          Bool.false →
            let x_59 : obj := proj[0] x_57;
            let x_60 : obj := proj[1] x_57;
            let x_61 : usize := ptrAddrUnsafe ◾ x_46;
            dec x_46;
            let x_62 : usize := ptrAddrUnsafe ◾ x_59;
            let x_63 : u8 := USize.decEq x_61 x_62;
            case x_63 : u8 of
            Bool.false →
              dec x_45;
              dec x_1;
              setTag x_57 := 1;
              set x_57[1] := x_59;
              set x_57[0] := x_55;
              set x_53[1] := x_60;
              set x_53[0] := x_57;
              ret x_53
            Bool.true →
              let x_64 : usize := ptrAddrUnsafe ◾ x_45;
              dec x_45;
              let x_65 : usize := ptrAddrUnsafe ◾ x_55;
              let x_66 : u8 := USize.decEq x_64 x_65;
              case x_66 : u8 of
              Bool.false →
                dec x_1;
                setTag x_57 := 1;
                set x_57[1] := x_59;
                set x_57[0] := x_55;
                set x_53[1] := x_60;
                set x_53[0] := x_57;
                ret x_53
              Bool.true →
                dec x_59;
                del x_53;
                dec x_55;
                set x_57[0] := x_1;
                ret x_57
          Bool.true →
            let x_67 : obj := proj[0] x_57;
            let x_68 : obj := proj[1] x_57;
            inc x_68;
            inc x_67;
            dec x_57;
            let x_69 : usize := ptrAddrUnsafe ◾ x_46;
            dec x_46;
            let x_70 : usize := ptrAddrUnsafe ◾ x_67;
            let x_71 : u8 := USize.decEq x_69 x_70;
            case x_71 : u8 of
            Bool.false →
              dec x_45;
              dec x_1;
              let x_72 : obj := ctor_1[Lean.Compiler.LCNF.Code.fun] x_55 x_67;
              set x_53[1] := x_68;
              set x_53[0] := x_72;
              ret x_53
            Bool.true →
              let x_73 : usize := ptrAddrUnsafe ◾ x_45;
              dec x_45;
              let x_74 : usize := ptrAddrUnsafe ◾ x_55;
              let x_75 : u8 := USize.decEq x_73 x_74;
              case x_75 : u8 of
              Bool.false →
                dec x_1;
                let x_76 : obj := ctor_1[Lean.Compiler.LCNF.Code.fun] x_55 x_67;
                set x_53[1] := x_68;
                set x_53[0] := x_76;
                ret x_53
              Bool.true →
                dec x_67;
                del x_53;
                dec x_55;
                let x_77 : obj := ctor_0[EStateM.Result.ok] x_1 x_68;
                ret x_77
        EStateM.Result.error →
          del x_53;
          dec x_55;
          dec x_46;
          dec x_45;
          dec x_1;
          let x_78 : u8 := isShared x_57;
          case x_78 : u8 of
          Bool.false →
            ret x_57
          Bool.true →
            let x_79 : obj := proj[0] x_57;
            let x_80 : obj := proj[1] x_57;
            inc x_80;
            inc x_79;
            dec x_57;
            let x_81 : obj := ctor_1[EStateM.Result.error] x_79 x_80;
            ret x_81
      Bool.true →
        let x_82 : obj := proj[0] x_53;
        let x_83 : obj := proj[1] x_53;
        inc x_83;
        inc x_82;
        dec x_53;
        inc x_46;
        let x_84 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_46 x_2 x_3 x_4 x_5 x_6 x_83;
        case x_84 : obj of
        EStateM.Result.ok →
          let x_85 : obj := proj[0] x_84;
          inc x_85;
          let x_86 : obj := proj[1] x_84;
          inc x_86;
          let x_87 : obj := reset[2] x_84;
          let x_88 : usize := ptrAddrUnsafe ◾ x_46;
          dec x_46;
          let x_89 : usize := ptrAddrUnsafe ◾ x_85;
          let x_90 : u8 := USize.decEq x_88 x_89;
          case x_90 : u8 of
          Bool.false →
            dec x_45;
            dec x_1;
            let x_91 : obj := reuse! x_87 in ctor_1[Lean.Compiler.LCNF.Code.fun] x_82 x_85;
            let x_92 : obj := ctor_0[EStateM.Result.ok] x_91 x_86;
            ret x_92
          Bool.true →
            let x_93 : usize := ptrAddrUnsafe ◾ x_45;
            dec x_45;
            let x_94 : usize := ptrAddrUnsafe ◾ x_82;
            let x_95 : u8 := USize.decEq x_93 x_94;
            case x_95 : u8 of
            Bool.false →
              dec x_1;
              let x_96 : obj := reuse! x_87 in ctor_1[Lean.Compiler.LCNF.Code.fun] x_82 x_85;
              let x_97 : obj := ctor_0[EStateM.Result.ok] x_96 x_86;
              ret x_97
            Bool.true →
              dec x_85;
              dec x_82;
              let x_98 : obj := reuse x_87 in ctor_0[EStateM.Result.ok] x_1 x_86;
              ret x_98
        EStateM.Result.error →
          dec x_82;
          dec x_46;
          dec x_45;
          dec x_1;
          let x_99 : obj := proj[0] x_84;
          inc x_99;
          let x_100 : obj := proj[1] x_84;
          inc x_100;
          let x_101 : obj := reset[2] x_84;
          let x_102 : obj := reuse x_101 in ctor_1[EStateM.Result.error] x_99 x_100;
          ret x_102
    EStateM.Result.error →
      dec x_46;
      dec x_45;
      dec x_6;
      dec x_5;
      dec x_4;
      dec x_3;
      dec x_2;
      dec x_1;
      let x_103 : u8 := isShared x_48;
      case x_103 : u8 of
      Bool.false →
        ret x_48
      Bool.true →
        let x_104 : obj := proj[0] x_48;
        let x_105 : obj := proj[1] x_48;
        inc x_105;
        inc x_104;
        dec x_48;
        let x_106 : obj := ctor_1[EStateM.Result.error] x_104 x_105;
        ret x_106
  Lean.Compiler.LCNF.Code.jp →
    let x_107 : obj := proj[0] x_1;
    inc x_107;
    let x_108 : obj := proj[1] x_1;
    inc x_108;
    let x_109 : obj := proj[0] x_107;
    inc x_109;
    let x_110 : obj := Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1 x_2 x_109;
    dec x_109;
    case x_110 : obj of
    Option.none →
      inc x_108;
      let x_111 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_108 x_2 x_3 x_4 x_5 x_6 x_7;
      case x_111 : obj of
      EStateM.Result.ok →
        let x_112 : u8 := isShared x_111;
        case x_112 : u8 of
        Bool.false →
          let x_113 : obj := proj[0] x_111;
          let x_114 : obj := proj[1] x_111;
          let x_115 : usize := ptrAddrUnsafe ◾ x_108;
          dec x_108;
          let x_116 : usize := ptrAddrUnsafe ◾ x_113;
          let x_117 : u8 := USize.decEq x_115 x_116;
          case x_117 : u8 of
          Bool.false →
            let x_118 : u8 := isShared x_1;
            case x_118 : u8 of
            Bool.false →
              let x_119 : obj := proj[1] x_1;
              dec x_119;
              let x_120 : obj := proj[0] x_1;
              dec x_120;
              setTag x_111 := 2;
              set x_111[1] := x_113;
              set x_111[0] := x_107;
              setTag x_1 := 0;
              set x_1[1] := x_114;
              set x_1[0] := x_111;
              ret x_1
            Bool.true →
              dec x_1;
              setTag x_111 := 2;
              set x_111[1] := x_113;
              set x_111[0] := x_107;
              let x_121 : obj := ctor_0[EStateM.Result.ok] x_111 x_114;
              ret x_121
          Bool.true →
            let x_122 : usize := ptrAddrUnsafe ◾ x_107;
            let x_123 : u8 := USize.decEq x_122 x_122;
            case x_123 : u8 of
            Bool.false →
              let x_124 : u8 := isShared x_1;
              case x_124 : u8 of
              Bool.false →
                let x_125 : obj := proj[1] x_1;
                dec x_125;
                let x_126 : obj := proj[0] x_1;
                dec x_126;
                setTag x_111 := 2;
                set x_111[1] := x_113;
                set x_111[0] := x_107;
                setTag x_1 := 0;
                set x_1[1] := x_114;
                set x_1[0] := x_111;
                ret x_1
              Bool.true →
                dec x_1;
                setTag x_111 := 2;
                set x_111[1] := x_113;
                set x_111[0] := x_107;
                let x_127 : obj := ctor_0[EStateM.Result.ok] x_111 x_114;
                ret x_127
            Bool.true →
              dec x_113;
              dec x_107;
              set x_111[0] := x_1;
              ret x_111
        Bool.true →
          let x_128 : obj := proj[0] x_111;
          let x_129 : obj := proj[1] x_111;
          inc x_129;
          inc x_128;
          dec x_111;
          let x_130 : usize := ptrAddrUnsafe ◾ x_108;
          dec x_108;
          let x_131 : usize := ptrAddrUnsafe ◾ x_128;
          let x_132 : u8 := USize.decEq x_130 x_131;
          case x_132 : u8 of
          Bool.false →
            let x_133 : obj := reset[2] x_1;
            let x_134 : obj := ctor_2[Lean.Compiler.LCNF.Code.jp] x_107 x_128;
            let x_135 : obj := reuse! x_133 in ctor_0[EStateM.Result.ok] x_134 x_129;
            ret x_135
          Bool.true →
            let x_136 : usize := ptrAddrUnsafe ◾ x_107;
            let x_137 : u8 := USize.decEq x_136 x_136;
            case x_137 : u8 of
            Bool.false →
              let x_138 : obj := reset[2] x_1;
              let x_139 : obj := ctor_2[Lean.Compiler.LCNF.Code.jp] x_107 x_128;
              let x_140 : obj := reuse! x_138 in ctor_0[EStateM.Result.ok] x_139 x_129;
              ret x_140
            Bool.true →
              dec x_128;
              dec x_107;
              let x_141 : obj := ctor_0[EStateM.Result.ok] x_1 x_129;
              ret x_141
      EStateM.Result.error →
        dec x_108;
        dec x_107;
        dec x_1;
        let x_142 : u8 := isShared x_111;
        case x_142 : u8 of
        Bool.false →
          ret x_111
        Bool.true →
          let x_143 : obj := proj[0] x_111;
          let x_144 : obj := proj[1] x_111;
          inc x_144;
          inc x_143;
          dec x_111;
          let x_145 : obj := ctor_1[EStateM.Result.error] x_143 x_144;
          ret x_145
    Option.some →
      let x_146 : obj := proj[0] x_110;
      inc x_146;
      dec x_110;
      let x_147 : obj := proj[2] x_107;
      inc x_147;
      let x_148 : obj := Array.size ◾ x_147;
      let x_149 : obj := 0;
      let x_150 : u8 := Nat.decLt x_149 x_148;
      case x_150 : u8 of
      Bool.false →
        dec x_147;
        let x_151 : obj := proj[4] x_107;
        inc x_151;
        inc x_6;
        inc x_5;
        inc x_4;
        inc x_3;
        inc x_2;
        let x_152 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_151 x_2 x_3 x_4 x_5 x_6 x_7;
        case x_152 : obj of
        EStateM.Result.ok →
          let x_153 : obj := proj[0] x_152;
          inc x_153;
          let x_154 : obj := proj[1] x_152;
          inc x_154;
          dec x_152;
          let x_155 : u8 := 0;
          inc x_6;
          inc x_5;
          inc x_4;
          inc x_3;
          let x_156 : obj := Lean.Compiler.LCNF.normCodeImp x_155 x_153 x_146 x_3 x_4 x_5 x_6 x_154;
          case x_156 : obj of
          EStateM.Result.ok →
            let x_157 : obj := proj[0] x_156;
            inc x_157;
            let x_158 : obj := proj[1] x_156;
            inc x_158;
            dec x_156;
            let x_159 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_2;
            let x_160 : u8 := Nat.beq x_159 x_148;
            dec x_148;
            dec x_159;
            case x_160 : u8 of
            Bool.false →
              inc x_6;
              inc x_5;
              inc x_4;
              inc x_3;
              inc x_157;
              let x_161 : obj := Lean.Compiler.LCNF.Code.inferType x_157 x_3 x_4 x_5 x_6 x_158;
              case x_161 : obj of
              EStateM.Result.ok →
                let x_162 : obj := proj[0] x_161;
                inc x_162;
                let x_163 : obj := proj[1] x_161;
                inc x_163;
                dec x_161;
                let x_164 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
                inc x_6;
                inc x_5;
                inc x_4;
                inc x_3;
                inc x_164;
                let x_165 : obj := Lean.Compiler.LCNF.mkForallParams x_164 x_162 x_3 x_4 x_5 x_6 x_163;
                case x_165 : obj of
                EStateM.Result.ok →
                  let x_166 : obj := proj[0] x_165;
                  inc x_166;
                  let x_167 : obj := proj[1] x_165;
                  inc x_167;
                  dec x_165;
                  let x_168 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_108 x_107 x_164 x_157 x_1 x_166 x_2 x_3 x_4 x_5 x_6 x_167;
                  ret x_168
                EStateM.Result.error →
                  dec x_164;
                  dec x_157;
                  dec x_108;
                  dec x_107;
                  dec x_6;
                  dec x_5;
                  dec x_4;
                  dec x_3;
                  dec x_2;
                  dec x_1;
                  let x_169 : u8 := isShared x_165;
                  case x_169 : u8 of
                  Bool.false →
                    ret x_165
                  Bool.true →
                    let x_170 : obj := proj[0] x_165;
                    let x_171 : obj := proj[1] x_165;
                    inc x_171;
                    inc x_170;
                    dec x_165;
                    let x_172 : obj := ctor_1[EStateM.Result.error] x_170 x_171;
                    ret x_172
              EStateM.Result.error →
                dec x_157;
                dec x_108;
                dec x_107;
                dec x_6;
                dec x_5;
                dec x_4;
                dec x_3;
                dec x_2;
                dec x_1;
                let x_173 : u8 := isShared x_161;
                case x_173 : u8 of
                Bool.false →
                  ret x_161
                Bool.true →
                  let x_174 : obj := proj[0] x_161;
                  let x_175 : obj := proj[1] x_161;
                  inc x_175;
                  inc x_174;
                  dec x_161;
                  let x_176 : obj := ctor_1[EStateM.Result.error] x_174 x_175;
                  ret x_176
            Bool.true →
              let x_177 : obj := proj[3] x_107;
              inc x_177;
              let x_178 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
              let x_179 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_108 x_107 x_178 x_157 x_1 x_177 x_2 x_3 x_4 x_5 x_6 x_158;
              ret x_179
          EStateM.Result.error →
            dec x_148;
            dec x_108;
            dec x_107;
            dec x_6;
            dec x_5;
            dec x_4;
            dec x_3;
            dec x_2;
            dec x_1;
            let x_180 : u8 := isShared x_156;
            case x_180 : u8 of
            Bool.false →
              ret x_156
            Bool.true →
              let x_181 : obj := proj[0] x_156;
              let x_182 : obj := proj[1] x_156;
              inc x_182;
              inc x_181;
              dec x_156;
              let x_183 : obj := ctor_1[EStateM.Result.error] x_181 x_182;
              ret x_183
        EStateM.Result.error →
          dec x_148;
          dec x_146;
          dec x_108;
          dec x_107;
          dec x_6;
          dec x_5;
          dec x_4;
          dec x_3;
          dec x_2;
          dec x_1;
          let x_184 : u8 := isShared x_152;
          case x_184 : u8 of
          Bool.false →
            ret x_152
          Bool.true →
            let x_185 : obj := proj[0] x_152;
            let x_186 : obj := proj[1] x_152;
            inc x_186;
            inc x_185;
            dec x_152;
            let x_187 : obj := ctor_1[EStateM.Result.error] x_185 x_186;
            ret x_187
      Bool.true →
        let x_188 : u8 := Nat.decLe x_148 x_148;
        case x_188 : u8 of
        Bool.false →
          dec x_147;
          let x_189 : obj := proj[4] x_107;
          inc x_189;
          inc x_6;
          inc x_5;
          inc x_4;
          inc x_3;
          inc x_2;
          let x_190 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_189 x_2 x_3 x_4 x_5 x_6 x_7;
          case x_190 : obj of
          EStateM.Result.ok →
            let x_191 : obj := proj[0] x_190;
            inc x_191;
            let x_192 : obj := proj[1] x_190;
            inc x_192;
            dec x_190;
            let x_193 : u8 := 0;
            inc x_6;
            inc x_5;
            inc x_4;
            inc x_3;
            let x_194 : obj := Lean.Compiler.LCNF.normCodeImp x_193 x_191 x_146 x_3 x_4 x_5 x_6 x_192;
            case x_194 : obj of
            EStateM.Result.ok →
              let x_195 : obj := proj[0] x_194;
              inc x_195;
              let x_196 : obj := proj[1] x_194;
              inc x_196;
              dec x_194;
              let x_197 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_2;
              let x_198 : u8 := Nat.beq x_197 x_148;
              dec x_148;
              dec x_197;
              case x_198 : u8 of
              Bool.false →
                inc x_6;
                inc x_5;
                inc x_4;
                inc x_3;
                inc x_195;
                let x_199 : obj := Lean.Compiler.LCNF.Code.inferType x_195 x_3 x_4 x_5 x_6 x_196;
                case x_199 : obj of
                EStateM.Result.ok →
                  let x_200 : obj := proj[0] x_199;
                  inc x_200;
                  let x_201 : obj := proj[1] x_199;
                  inc x_201;
                  dec x_199;
                  let x_202 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
                  inc x_6;
                  inc x_5;
                  inc x_4;
                  inc x_3;
                  inc x_202;
                  let x_203 : obj := Lean.Compiler.LCNF.mkForallParams x_202 x_200 x_3 x_4 x_5 x_6 x_201;
                  case x_203 : obj of
                  EStateM.Result.ok →
                    let x_204 : obj := proj[0] x_203;
                    inc x_204;
                    let x_205 : obj := proj[1] x_203;
                    inc x_205;
                    dec x_203;
                    let x_206 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_108 x_107 x_202 x_195 x_1 x_204 x_2 x_3 x_4 x_5 x_6 x_205;
                    ret x_206
                  EStateM.Result.error →
                    dec x_202;
                    dec x_195;
                    dec x_108;
                    dec x_107;
                    dec x_6;
                    dec x_5;
                    dec x_4;
                    dec x_3;
                    dec x_2;
                    dec x_1;
                    let x_207 : u8 := isShared x_203;
                    case x_207 : u8 of
                    Bool.false →
                      ret x_203
                    Bool.true →
                      let x_208 : obj := proj[0] x_203;
                      let x_209 : obj := proj[1] x_203;
                      inc x_209;
                      inc x_208;
                      dec x_203;
                      let x_210 : obj := ctor_1[EStateM.Result.error] x_208 x_209;
                      ret x_210
                EStateM.Result.error →
                  dec x_195;
                  dec x_108;
                  dec x_107;
                  dec x_6;
                  dec x_5;
                  dec x_4;
                  dec x_3;
                  dec x_2;
                  dec x_1;
                  let x_211 : u8 := isShared x_199;
                  case x_211 : u8 of
                  Bool.false →
                    ret x_199
                  Bool.true →
                    let x_212 : obj := proj[0] x_199;
                    let x_213 : obj := proj[1] x_199;
                    inc x_213;
                    inc x_212;
                    dec x_199;
                    let x_214 : obj := ctor_1[EStateM.Result.error] x_212 x_213;
                    ret x_214
              Bool.true →
                let x_215 : obj := proj[3] x_107;
                inc x_215;
                let x_216 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
                let x_217 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_108 x_107 x_216 x_195 x_1 x_215 x_2 x_3 x_4 x_5 x_6 x_196;
                ret x_217
            EStateM.Result.error →
              dec x_148;
              dec x_108;
              dec x_107;
              dec x_6;
              dec x_5;
              dec x_4;
              dec x_3;
              dec x_2;
              dec x_1;
              let x_218 : u8 := isShared x_194;
              case x_218 : u8 of
              Bool.false →
                ret x_194
              Bool.true →
                let x_219 : obj := proj[0] x_194;
                let x_220 : obj := proj[1] x_194;
                inc x_220;
                inc x_219;
                dec x_194;
                let x_221 : obj := ctor_1[EStateM.Result.error] x_219 x_220;
                ret x_221
          EStateM.Result.error →
            dec x_148;
            dec x_146;
            dec x_108;
            dec x_107;
            dec x_6;
            dec x_5;
            dec x_4;
            dec x_3;
            dec x_2;
            dec x_1;
            let x_222 : u8 := isShared x_190;
            case x_222 : u8 of
            Bool.false →
              ret x_190
            Bool.true →
              let x_223 : obj := proj[0] x_190;
              let x_224 : obj := proj[1] x_190;
              inc x_224;
              inc x_223;
              dec x_190;
              let x_225 : obj := ctor_1[EStateM.Result.error] x_223 x_224;
              ret x_225
        Bool.true →
          let x_226 : usize := 0;
          let x_227 : usize := USize.ofNat x_148;
          let x_228 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
          let x_229 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2 x_146 x_147 x_226 x_227 x_228 x_2 x_3 x_4 x_5 x_6 x_7;
          dec x_147;
          let x_230 : obj := proj[0] x_229;
          inc x_230;
          let x_231 : obj := proj[1] x_229;
          inc x_231;
          dec x_229;
          let x_232 : obj := proj[4] x_107;
          inc x_232;
          inc x_6;
          inc x_5;
          inc x_4;
          inc x_3;
          inc x_2;
          let x_233 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_232 x_2 x_3 x_4 x_5 x_6 x_231;
          case x_233 : obj of
          EStateM.Result.ok →
            let x_234 : obj := proj[0] x_233;
            inc x_234;
            let x_235 : obj := proj[1] x_233;
            inc x_235;
            dec x_233;
            let x_236 : u8 := 0;
            inc x_6;
            inc x_5;
            inc x_4;
            inc x_3;
            let x_237 : obj := Lean.Compiler.LCNF.normCodeImp x_236 x_234 x_146 x_3 x_4 x_5 x_6 x_235;
            case x_237 : obj of
            EStateM.Result.ok →
              let x_238 : obj := proj[0] x_237;
              inc x_238;
              let x_239 : obj := proj[1] x_237;
              inc x_239;
              dec x_237;
              let x_240 : obj := Array.size ◾ x_230;
              let x_241 : u8 := Nat.beq x_240 x_148;
              dec x_148;
              dec x_240;
              case x_241 : u8 of
              Bool.false →
                inc x_6;
                inc x_5;
                inc x_4;
                inc x_3;
                inc x_238;
                let x_242 : obj := Lean.Compiler.LCNF.Code.inferType x_238 x_3 x_4 x_5 x_6 x_239;
                case x_242 : obj of
                EStateM.Result.ok →
                  let x_243 : obj := proj[0] x_242;
                  inc x_243;
                  let x_244 : obj := proj[1] x_242;
                  inc x_244;
                  dec x_242;
                  inc x_6;
                  inc x_5;
                  inc x_4;
                  inc x_3;
                  inc x_230;
                  let x_245 : obj := Lean.Compiler.LCNF.mkForallParams x_230 x_243 x_3 x_4 x_5 x_6 x_244;
                  case x_245 : obj of
                  EStateM.Result.ok →
                    let x_246 : obj := proj[0] x_245;
                    inc x_246;
                    let x_247 : obj := proj[1] x_245;
                    inc x_247;
                    dec x_245;
                    let x_248 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_108 x_107 x_230 x_238 x_1 x_246 x_2 x_3 x_4 x_5 x_6 x_247;
                    ret x_248
                  EStateM.Result.error →
                    dec x_238;
                    dec x_230;
                    dec x_108;
                    dec x_107;
                    dec x_6;
                    dec x_5;
                    dec x_4;
                    dec x_3;
                    dec x_2;
                    dec x_1;
                    let x_249 : u8 := isShared x_245;
                    case x_249 : u8 of
                    Bool.false →
                      ret x_245
                    Bool.true →
                      let x_250 : obj := proj[0] x_245;
                      let x_251 : obj := proj[1] x_245;
                      inc x_251;
                      inc x_250;
                      dec x_245;
                      let x_252 : obj := ctor_1[EStateM.Result.error] x_250 x_251;
                      ret x_252
                EStateM.Result.error →
                  dec x_238;
                  dec x_230;
                  dec x_108;
                  dec x_107;
                  dec x_6;
                  dec x_5;
                  dec x_4;
                  dec x_3;
                  dec x_2;
                  dec x_1;
                  let x_253 : u8 := isShared x_242;
                  case x_253 : u8 of
                  Bool.false →
                    ret x_242
                  Bool.true →
                    let x_254 : obj := proj[0] x_242;
                    let x_255 : obj := proj[1] x_242;
                    inc x_255;
                    inc x_254;
                    dec x_242;
                    let x_256 : obj := ctor_1[EStateM.Result.error] x_254 x_255;
                    ret x_256
              Bool.true →
                let x_257 : obj := proj[3] x_107;
                inc x_257;
                let x_258 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._lambda_1 x_108 x_107 x_230 x_238 x_1 x_257 x_2 x_3 x_4 x_5 x_6 x_239;
                ret x_258
            EStateM.Result.error →
              dec x_230;
              dec x_148;
              dec x_108;
              dec x_107;
              dec x_6;
              dec x_5;
              dec x_4;
              dec x_3;
              dec x_2;
              dec x_1;
              let x_259 : u8 := isShared x_237;
              case x_259 : u8 of
              Bool.false →
                ret x_237
              Bool.true →
                let x_260 : obj := proj[0] x_237;
                let x_261 : obj := proj[1] x_237;
                inc x_261;
                inc x_260;
                dec x_237;
                let x_262 : obj := ctor_1[EStateM.Result.error] x_260 x_261;
                ret x_262
          EStateM.Result.error →
            dec x_230;
            dec x_148;
            dec x_146;
            dec x_108;
            dec x_107;
            dec x_6;
            dec x_5;
            dec x_4;
            dec x_3;
            dec x_2;
            dec x_1;
            let x_263 : u8 := isShared x_233;
            case x_263 : u8 of
            Bool.false →
              ret x_233
            Bool.true →
              let x_264 : obj := proj[0] x_233;
              let x_265 : obj := proj[1] x_233;
              inc x_265;
              inc x_264;
              dec x_233;
              let x_266 : obj := ctor_1[EStateM.Result.error] x_264 x_265;
              ret x_266
  Lean.Compiler.LCNF.Code.jmp →
    let x_267 : obj := proj[0] x_1;
    inc x_267;
    let x_268 : obj := proj[1] x_1;
    inc x_268;
    block_333 (x_269 : obj) (x_270 : obj) (x_271 : obj) :=
      block_320 (x_272 : obj) :=
        case x_1 : obj of
        Lean.Compiler.LCNF.Code.let →
          dec x_272;
          dec x_267;
          let x_273 : u8 := isShared x_1;
          case x_273 : u8 of
          Bool.false →
            let x_274 : obj := proj[1] x_1;
            dec x_274;
            let x_275 : obj := proj[0] x_1;
            dec x_275;
            let x_276 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5;
            let x_277 : obj := panic._at._private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltsImp._spec_1 x_276;
            set x_1[1] := x_271;
            set x_1[0] := x_277;
            ret x_1
          Bool.true →
            dec x_1;
            let x_278 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5;
            let x_279 : obj := panic._at._private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltsImp._spec_1 x_278;
            let x_280 : obj := ctor_0[EStateM.Result.ok] x_279 x_271;
            ret x_280
        Lean.Compiler.LCNF.Code.jmp →
          let x_281 : obj := proj[0] x_1;
          inc x_281;
          let x_282 : obj := proj[1] x_1;
          inc x_282;
          let x_283 : obj := Array.size ◾ x_272;
          let x_284 : usize := USize.ofNat x_283;
          dec x_283;
          let x_285 : usize := 0;
          let x_286 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_3 x_284 x_285 x_272;
          let x_287 : u8 := Lean.Name.beq x_281 x_267;
          dec x_281;
          case x_287 : u8 of
          Bool.false →
            dec x_282;
            let x_288 : u8 := isShared x_1;
            case x_288 : u8 of
            Bool.false →
              let x_289 : obj := proj[1] x_1;
              dec x_289;
              let x_290 : obj := proj[0] x_1;
              dec x_290;
              let x_291 : u8 := isShared x_1;
              case x_291 : u8 of
              Bool.false →
                let x_292 : obj := proj[1] x_1;
                dec x_292;
                let x_293 : obj := proj[0] x_1;
                dec x_293;
                set x_1[1] := x_286;
                setTag x_1 := 0;
                set x_1[1] := x_271;
                set x_1[0] := x_1;
                ret x_1
              Bool.true →
                dec x_1;
                set x_1[1] := x_286;
                let x_294 : obj := ctor_0[EStateM.Result.ok] x_1 x_271;
                ret x_294
            Bool.true →
              dec x_1;
              let x_295 : obj := reset[2] x_1;
              let x_296 : obj := ctor_3[Lean.Compiler.LCNF.Code.jmp] x_267 x_286;
              let x_297 : obj := reuse! x_295 in ctor_0[EStateM.Result.ok] x_296 x_271;
              ret x_297
          Bool.true →
            let x_298 : usize := ptrAddrUnsafe ◾ x_282;
            dec x_282;
            let x_299 : usize := ptrAddrUnsafe ◾ x_286;
            let x_300 : u8 := USize.decEq x_298 x_299;
            case x_300 : u8 of
            Bool.false →
              let x_301 : u8 := isShared x_1;
              case x_301 : u8 of
              Bool.false →
                let x_302 : obj := proj[1] x_1;
                dec x_302;
                let x_303 : obj := proj[0] x_1;
                dec x_303;
                let x_304 : u8 := isShared x_1;
                case x_304 : u8 of
                Bool.false →
                  let x_305 : obj := proj[1] x_1;
                  dec x_305;
                  let x_306 : obj := proj[0] x_1;
                  dec x_306;
                  set x_1[1] := x_286;
                  setTag x_1 := 0;
                  set x_1[1] := x_271;
                  set x_1[0] := x_1;
                  ret x_1
                Bool.true →
                  dec x_1;
                  set x_1[1] := x_286;
                  let x_307 : obj := ctor_0[EStateM.Result.ok] x_1 x_271;
                  ret x_307
              Bool.true →
                dec x_1;
                let x_308 : obj := reset[2] x_1;
                let x_309 : obj := ctor_3[Lean.Compiler.LCNF.Code.jmp] x_267 x_286;
                let x_310 : obj := reuse! x_308 in ctor_0[EStateM.Result.ok] x_309 x_271;
                ret x_310
            Bool.true →
              dec x_286;
              dec x_267;
              let x_311 : obj := ctor_0[EStateM.Result.ok] x_1 x_271;
              ret x_311
        default →
          dec x_272;
          dec x_267;
          let x_312 : u8 := isShared x_1;
          case x_312 : u8 of
          Bool.false →
            let x_313 : obj := proj[1] x_1;
            dec x_313;
            let x_314 : obj := proj[0] x_1;
            dec x_314;
            let x_315 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5;
            let x_316 : obj := panic._at._private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltsImp._spec_1 x_315;
            setTag x_1 := 0;
            set x_1[1] := x_271;
            set x_1[0] := x_316;
            ret x_1
          Bool.true →
            dec x_1;
            let x_317 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_5;
            let x_318 : obj := panic._at._private.Lean.Compiler.LCNF.Basic.0.Lean.Compiler.LCNF.updateAltsImp._spec_1 x_317;
            let x_319 : obj := ctor_0[EStateM.Result.ok] x_318 x_271;
            ret x_319;
      let x_321 : obj := proj[2] x_270;
      inc x_321;
      dec x_270;
      let x_322 : obj := Array.zip._rarg x_321 x_268;
      dec x_268;
      dec x_321;
      let x_323 : obj := Array.size ◾ x_322;
      let x_324 : obj := 0;
      let x_325 : u8 := Nat.decLt x_324 x_323;
      case x_325 : u8 of
      Bool.false →
        dec x_323;
        dec x_322;
        dec x_269;
        let x_326 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
        jmp block_320 x_326
      Bool.true →
        let x_327 : u8 := Nat.decLe x_323 x_323;
        case x_327 : u8 of
        Bool.false →
          dec x_323;
          dec x_322;
          dec x_269;
          let x_328 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
          jmp block_320 x_328
        Bool.true →
          let x_329 : usize := 0;
          let x_330 : usize := USize.ofNat x_323;
          dec x_323;
          let x_331 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._closed_1;
          let x_332 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_4 x_269 x_322 x_329 x_330 x_331;
          dec x_322;
          dec x_269;
          jmp block_320 x_332;
    inc x_267;
    let x_334 : obj := Lean.Compiler.LCNF.getFunDecl x_267 x_3 x_4 x_5 x_6 x_7;
    dec x_6;
    dec x_5;
    dec x_4;
    dec x_3;
    let x_335 : obj := Lean.RBNode.find._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze._spec_1 x_2 x_267;
    dec x_2;
    case x_335 : obj of
    Option.none →
      case x_334 : obj of
      EStateM.Result.ok →
        let x_336 : obj := proj[0] x_334;
        inc x_336;
        let x_337 : obj := proj[1] x_334;
        inc x_337;
        dec x_334;
        let x_338 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.isInJpScope._closed_3;
        let x_339 : obj := panic._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_5 x_338;
        jmp block_333 x_339 x_336 x_337
      EStateM.Result.error →
        dec x_268;
        dec x_267;
        dec x_1;
        let x_340 : u8 := isShared x_334;
        case x_340 : u8 of
        Bool.false →
          ret x_334
        Bool.true →
          let x_341 : obj := proj[0] x_334;
          let x_342 : obj := proj[1] x_334;
          inc x_342;
          inc x_341;
          dec x_334;
          let x_343 : obj := ctor_1[EStateM.Result.error] x_341 x_342;
          ret x_343
    Option.some →
      case x_334 : obj of
      EStateM.Result.ok →
        let x_344 : obj := proj[0] x_335;
        inc x_344;
        dec x_335;
        let x_345 : obj := proj[0] x_334;
        inc x_345;
        let x_346 : obj := proj[1] x_334;
        inc x_346;
        dec x_334;
        jmp block_333 x_344 x_345 x_346
      EStateM.Result.error →
        dec x_335;
        dec x_268;
        dec x_267;
        dec x_1;
        let x_347 : u8 := isShared x_334;
        case x_347 : u8 of
        Bool.false →
          ret x_334
        Bool.true →
          let x_348 : obj := proj[0] x_334;
          let x_349 : obj := proj[1] x_334;
          inc x_349;
          inc x_348;
          dec x_334;
          let x_350 : obj := ctor_1[EStateM.Result.error] x_348 x_349;
          ret x_350
  Lean.Compiler.LCNF.Code.cases →
    let x_351 : obj := proj[0] x_1;
    inc x_351;
    let x_352 : u8 := isShared x_351;
    case x_352 : u8 of
    Bool.false →
      let x_353 : obj := proj[0] x_351;
      let x_354 : obj := proj[1] x_351;
      let x_355 : obj := proj[2] x_351;
      let x_356 : obj := proj[3] x_351;
      let x_357 : obj := Array.size ◾ x_356;
      let x_358 : usize := USize.ofNat x_357;
      dec x_357;
      let x_359 : usize := 0;
      inc x_356;
      let x_360 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_7 x_358 x_359 x_356 x_2 x_3 x_4 x_5 x_6 x_7;
      case x_360 : obj of
      EStateM.Result.ok →
        let x_361 : u8 := isShared x_360;
        case x_361 : u8 of
        Bool.false →
          let x_362 : obj := proj[0] x_360;
          let x_363 : usize := ptrAddrUnsafe ◾ x_356;
          dec x_356;
          let x_364 : usize := ptrAddrUnsafe ◾ x_362;
          let x_365 : u8 := USize.decEq x_363 x_364;
          case x_365 : u8 of
          Bool.false →
            let x_366 : u8 := isShared x_1;
            case x_366 : u8 of
            Bool.false →
              let x_367 : obj := proj[0] x_1;
              dec x_367;
              set x_351[3] := x_362;
              set x_360[0] := x_1;
              ret x_360
            Bool.true →
              dec x_1;
              set x_351[3] := x_362;
              let x_368 : obj := ctor_4[Lean.Compiler.LCNF.Code.cases] x_351;
              set x_360[0] := x_368;
              ret x_360
          Bool.true →
            let x_369 : usize := ptrAddrUnsafe ◾ x_354;
            let x_370 : u8 := USize.decEq x_369 x_369;
            case x_370 : u8 of
            Bool.false →
              let x_371 : u8 := isShared x_1;
              case x_371 : u8 of
              Bool.false →
                let x_372 : obj := proj[0] x_1;
                dec x_372;
                set x_351[3] := x_362;
                set x_360[0] := x_1;
                ret x_360
              Bool.true →
                dec x_1;
                set x_351[3] := x_362;
                let x_373 : obj := ctor_4[Lean.Compiler.LCNF.Code.cases] x_351;
                set x_360[0] := x_373;
                ret x_360
            Bool.true →
              let x_374 : u8 := Lean.Name.beq x_355 x_355;
              case x_374 : u8 of
              Bool.false →
                let x_375 : u8 := isShared x_1;
                case x_375 : u8 of
                Bool.false →
                  let x_376 : obj := proj[0] x_1;
                  dec x_376;
                  set x_351[3] := x_362;
                  set x_360[0] := x_1;
                  ret x_360
                Bool.true →
                  dec x_1;
                  set x_351[3] := x_362;
                  let x_377 : obj := ctor_4[Lean.Compiler.LCNF.Code.cases] x_351;
                  set x_360[0] := x_377;
                  ret x_360
              Bool.true →
                dec x_362;
                del x_351;
                dec x_355;
                dec x_354;
                dec x_353;
                set x_360[0] := x_1;
                ret x_360
        Bool.true →
          let x_378 : obj := proj[0] x_360;
          let x_379 : obj := proj[1] x_360;
          inc x_379;
          inc x_378;
          dec x_360;
          let x_380 : usize := ptrAddrUnsafe ◾ x_356;
          dec x_356;
          let x_381 : usize := ptrAddrUnsafe ◾ x_378;
          let x_382 : u8 := USize.decEq x_380 x_381;
          case x_382 : u8 of
          Bool.false →
            let x_383 : obj := reset[1] x_1;
            set x_351[3] := x_378;
            let x_384 : obj := reuse x_383 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_351;
            let x_385 : obj := ctor_0[EStateM.Result.ok] x_384 x_379;
            ret x_385
          Bool.true →
            let x_386 : usize := ptrAddrUnsafe ◾ x_354;
            let x_387 : u8 := USize.decEq x_386 x_386;
            case x_387 : u8 of
            Bool.false →
              let x_388 : obj := reset[1] x_1;
              set x_351[3] := x_378;
              let x_389 : obj := reuse x_388 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_351;
              let x_390 : obj := ctor_0[EStateM.Result.ok] x_389 x_379;
              ret x_390
            Bool.true →
              let x_391 : u8 := Lean.Name.beq x_355 x_355;
              case x_391 : u8 of
              Bool.false →
                let x_392 : obj := reset[1] x_1;
                set x_351[3] := x_378;
                let x_393 : obj := reuse x_392 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_351;
                let x_394 : obj := ctor_0[EStateM.Result.ok] x_393 x_379;
                ret x_394
              Bool.true →
                dec x_378;
                del x_351;
                dec x_355;
                dec x_354;
                dec x_353;
                let x_395 : obj := ctor_0[EStateM.Result.ok] x_1 x_379;
                ret x_395
      EStateM.Result.error →
        del x_351;
        dec x_356;
        dec x_355;
        dec x_354;
        dec x_353;
        dec x_1;
        let x_396 : u8 := isShared x_360;
        case x_396 : u8 of
        Bool.false →
          ret x_360
        Bool.true →
          let x_397 : obj := proj[0] x_360;
          let x_398 : obj := proj[1] x_360;
          inc x_398;
          inc x_397;
          dec x_360;
          let x_399 : obj := ctor_1[EStateM.Result.error] x_397 x_398;
          ret x_399
    Bool.true →
      let x_400 : obj := proj[0] x_351;
      let x_401 : obj := proj[1] x_351;
      let x_402 : obj := proj[2] x_351;
      let x_403 : obj := proj[3] x_351;
      inc x_403;
      inc x_402;
      inc x_401;
      inc x_400;
      dec x_351;
      let x_404 : obj := Array.size ◾ x_403;
      let x_405 : usize := USize.ofNat x_404;
      dec x_404;
      let x_406 : usize := 0;
      inc x_403;
      let x_407 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_7 x_405 x_406 x_403 x_2 x_3 x_4 x_5 x_6 x_7;
      case x_407 : obj of
      EStateM.Result.ok →
        let x_408 : obj := proj[0] x_407;
        inc x_408;
        let x_409 : obj := proj[1] x_407;
        inc x_409;
        let x_410 : obj := reset[2] x_407;
        let x_411 : usize := ptrAddrUnsafe ◾ x_403;
        dec x_403;
        let x_412 : usize := ptrAddrUnsafe ◾ x_408;
        let x_413 : u8 := USize.decEq x_411 x_412;
        case x_413 : u8 of
        Bool.false →
          let x_414 : obj := reset[1] x_1;
          let x_415 : obj := ctor_0[Lean.Compiler.LCNF.CasesCore.mk] x_400 x_401 x_402 x_408;
          let x_416 : obj := reuse x_414 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_415;
          let x_417 : obj := reuse x_410 in ctor_0[EStateM.Result.ok] x_416 x_409;
          ret x_417
        Bool.true →
          let x_418 : usize := ptrAddrUnsafe ◾ x_401;
          let x_419 : u8 := USize.decEq x_418 x_418;
          case x_419 : u8 of
          Bool.false →
            let x_420 : obj := reset[1] x_1;
            let x_421 : obj := ctor_0[Lean.Compiler.LCNF.CasesCore.mk] x_400 x_401 x_402 x_408;
            let x_422 : obj := reuse x_420 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_421;
            let x_423 : obj := reuse x_410 in ctor_0[EStateM.Result.ok] x_422 x_409;
            ret x_423
          Bool.true →
            let x_424 : u8 := Lean.Name.beq x_402 x_402;
            case x_424 : u8 of
            Bool.false →
              let x_425 : obj := reset[1] x_1;
              let x_426 : obj := ctor_0[Lean.Compiler.LCNF.CasesCore.mk] x_400 x_401 x_402 x_408;
              let x_427 : obj := reuse x_425 in ctor_4[Lean.Compiler.LCNF.Code.cases] x_426;
              let x_428 : obj := reuse x_410 in ctor_0[EStateM.Result.ok] x_427 x_409;
              ret x_428
            Bool.true →
              dec x_408;
              dec x_402;
              dec x_401;
              dec x_400;
              let x_429 : obj := reuse x_410 in ctor_0[EStateM.Result.ok] x_1 x_409;
              ret x_429
      EStateM.Result.error →
        dec x_403;
        dec x_402;
        dec x_401;
        dec x_400;
        dec x_1;
        let x_430 : obj := proj[0] x_407;
        inc x_430;
        let x_431 : obj := proj[1] x_407;
        inc x_431;
        let x_432 : obj := reset[2] x_407;
        let x_433 : obj := reuse x_432 in ctor_1[EStateM.Result.error] x_430 x_431;
        ret x_433
  default →
    dec x_6;
    dec x_5;
    dec x_4;
    dec x_3;
    dec x_2;
    let x_434 : obj := ctor_0[EStateM.Result.ok] x_1 x_7;
    ret x_434
def Lean.HashMapImp.contains._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_1._boxed (x_1 : obj) (x_2 : obj) : obj :=
  let x_3 : u8 := Lean.HashMapImp.contains._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_1 x_1 x_2;
  dec x_2;
  dec x_1;
  let x_4 : obj := box x_3;
  ret x_4
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2._lambda_1._boxed (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) : obj :=
  let x_9 : u8 := unbox x_1;
  dec x_1;
  let x_10 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2._lambda_1 x_9 x_2 x_3 x_4 x_5 x_6 x_7 x_8;
  dec x_7;
  dec x_6;
  dec x_5;
  dec x_4;
  dec x_3;
  dec x_2;
  ret x_10
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2._boxed (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) (x_10 : obj) (x_11 : obj) : obj :=
  let x_12 : usize := unbox x_3;
  dec x_3;
  let x_13 : usize := unbox x_4;
  dec x_4;
  let x_14 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_2 x_1 x_2 x_12 x_13 x_5 x_6 x_7 x_8 x_9 x_10 x_11;
  dec x_10;
  dec x_9;
  dec x_8;
  dec x_7;
  dec x_6;
  dec x_2;
  dec x_1;
  ret x_14
def Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_3._boxed (x_1 : obj) (x_2 : obj) (x_3 : obj) : obj :=
  let x_4 : usize := unbox x_1;
  dec x_1;
  let x_5 : usize := unbox x_2;
  dec x_2;
  let x_6 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_3 x_4 x_5 x_3;
  ret x_6
def Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_4._boxed (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) : obj :=
  let x_6 : usize := unbox x_3;
  dec x_3;
  let x_7 : usize := unbox x_4;
  dec x_4;
  let x_8 : obj := Array.foldlMUnsafe.fold._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_4 x_1 x_2 x_6 x_7 x_5;
  dec x_2;
  dec x_1;
  ret x_8
def Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_7._boxed (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) (x_7 : obj) (x_8 : obj) (x_9 : obj) : obj :=
  let x_10 : usize := unbox x_1;
  dec x_1;
  let x_11 : usize := unbox x_2;
  dec x_2;
  let x_12 : obj := Array.mapMUnsafe.map._at.Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce._spec_7 x_10 x_11 x_3 x_4 x_5 x_6 x_7 x_8 x_9;
  ret x_12
[result]
def Lean.Compiler.LCNF.JoinPointCommonArgs.reduce (x_1 : obj) (x_2 : obj) (x_3 : obj) (x_4 : obj) (x_5 : obj) (x_6 : obj) : obj :=
  let x_7 : u8 := isShared x_1;
  case x_7 : u8 of
  Bool.false →
    let x_8 : obj := proj[0] x_1;
    let x_9 : obj := proj[1] x_1;
    let x_10 : obj := proj[2] x_1;
    let x_11 : obj := proj[3] x_1;
    let x_12 : obj := proj[4] x_1;
    let x_13 : obj := proj[5] x_1;
    let x_14 : obj := ctor_0[Lean.RBNode.leaf];
    let x_15 : obj := ST.Prim.mkRef ◾ ◾ x_14 x_6;
    let x_16 : obj := proj[0] x_15;
    inc x_16;
    let x_17 : obj := proj[1] x_15;
    inc x_17;
    dec x_15;
    let x_18 : obj := ST.Prim.mkRef ◾ ◾ x_14 x_17;
    let x_19 : obj := proj[0] x_18;
    inc x_19;
    let x_20 : obj := proj[1] x_18;
    inc x_20;
    dec x_18;
    inc x_5;
    inc x_4;
    inc x_3;
    inc x_2;
    inc x_16;
    inc x_19;
    inc x_12;
    let x_21 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze x_12 x_14 x_19 x_16 x_2 x_3 x_4 x_5 x_20;
    case x_21 : obj of
    EStateM.Result.ok →
      let x_22 : obj := proj[1] x_21;
      inc x_22;
      dec x_21;
      let x_23 : obj := ST.Prim.Ref.get ◾ ◾ x_19 x_22;
      dec x_19;
      let x_24 : obj := proj[0] x_23;
      inc x_24;
      let x_25 : obj := proj[1] x_23;
      inc x_25;
      dec x_23;
      let x_26 : obj := ST.Prim.Ref.get ◾ ◾ x_16 x_25;
      dec x_16;
      let x_27 : obj := proj[1] x_26;
      inc x_27;
      dec x_26;
      let x_28 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_12 x_24 x_2 x_3 x_4 x_5 x_27;
      case x_28 : obj of
      EStateM.Result.ok →
        let x_29 : u8 := isShared x_28;
        case x_29 : u8 of
        Bool.false →
          let x_30 : obj := proj[0] x_28;
          set x_1[4] := x_30;
          set x_28[0] := x_1;
          ret x_28
        Bool.true →
          let x_31 : obj := proj[0] x_28;
          let x_32 : obj := proj[1] x_28;
          inc x_32;
          inc x_31;
          dec x_28;
          set x_1[4] := x_31;
          let x_33 : obj := ctor_0[EStateM.Result.ok] x_1 x_32;
          ret x_33
      EStateM.Result.error →
        del x_1;
        dec x_13;
        dec x_11;
        dec x_10;
        dec x_9;
        dec x_8;
        let x_34 : u8 := isShared x_28;
        case x_34 : u8 of
        Bool.false →
          ret x_28
        Bool.true →
          let x_35 : obj := proj[0] x_28;
          let x_36 : obj := proj[1] x_28;
          inc x_36;
          inc x_35;
          dec x_28;
          let x_37 : obj := ctor_1[EStateM.Result.error] x_35 x_36;
          ret x_37
    EStateM.Result.error →
      dec x_19;
      dec x_16;
      del x_1;
      dec x_13;
      dec x_12;
      dec x_11;
      dec x_10;
      dec x_9;
      dec x_8;
      dec x_5;
      dec x_4;
      dec x_3;
      dec x_2;
      let x_38 : u8 := isShared x_21;
      case x_38 : u8 of
      Bool.false →
        ret x_21
      Bool.true →
        let x_39 : obj := proj[0] x_21;
        let x_40 : obj := proj[1] x_21;
        inc x_40;
        inc x_39;
        dec x_21;
        let x_41 : obj := ctor_1[EStateM.Result.error] x_39 x_40;
        ret x_41
  Bool.true →
    let x_42 : obj := proj[0] x_1;
    let x_43 : obj := proj[1] x_1;
    let x_44 : obj := proj[2] x_1;
    let x_45 : obj := proj[3] x_1;
    let x_46 : obj := proj[4] x_1;
    let x_47 : u8 := sproj[6, 0] x_1;
    let x_48 : u8 := sproj[6, 1] x_1;
    let x_49 : obj := proj[5] x_1;
    inc x_49;
    inc x_46;
    inc x_45;
    inc x_44;
    inc x_43;
    inc x_42;
    dec x_1;
    let x_50 : obj := ctor_0[Lean.RBNode.leaf];
    let x_51 : obj := ST.Prim.mkRef ◾ ◾ x_50 x_6;
    let x_52 : obj := proj[0] x_51;
    inc x_52;
    let x_53 : obj := proj[1] x_51;
    inc x_53;
    dec x_51;
    let x_54 : obj := ST.Prim.mkRef ◾ ◾ x_50 x_53;
    let x_55 : obj := proj[0] x_54;
    inc x_55;
    let x_56 : obj := proj[1] x_54;
    inc x_56;
    dec x_54;
    inc x_5;
    inc x_4;
    inc x_3;
    inc x_2;
    inc x_52;
    inc x_55;
    inc x_46;
    let x_57 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goAnalyze x_46 x_50 x_55 x_52 x_2 x_3 x_4 x_5 x_56;
    case x_57 : obj of
    EStateM.Result.ok →
      let x_58 : obj := proj[1] x_57;
      inc x_58;
      dec x_57;
      let x_59 : obj := ST.Prim.Ref.get ◾ ◾ x_55 x_58;
      dec x_55;
      let x_60 : obj := proj[0] x_59;
      inc x_60;
      let x_61 : obj := proj[1] x_59;
      inc x_61;
      dec x_59;
      let x_62 : obj := ST.Prim.Ref.get ◾ ◾ x_52 x_61;
      dec x_52;
      let x_63 : obj := proj[1] x_62;
      inc x_63;
      dec x_62;
      let x_64 : obj := Lean.Compiler.LCNF.JoinPointCommonArgs.reduce.goReduce x_46 x_60 x_2 x_3 x_4 x_5 x_63;
      case x_64 : obj of
      EStateM.Result.ok →
        let x_65 : obj := proj[0] x_64;
        inc x_65;
        let x_66 : obj := proj[1] x_64;
        inc x_66;
        let x_67 : obj := reset[2] x_64;
        let x_68 : obj := ctor_0.0.2[Lean.Compiler.LCNF.Decl.mk] x_42 x_43 x_44 x_45 x_65 x_49;
        sset x_68[6, 0] : u8 := x_47;
        sset x_68[6, 1] : u8 := x_48;
        let x_69 : obj := reuse x_67 in ctor_0[EStateM.Result.ok] x_68 x_66;
        ret x_69
      EStateM.Result.error →
        dec x_49;
        dec x_45;
        dec x_44;
        dec x_43;
        dec x_42;
        let x_70 : obj := proj[0] x_64;
        inc x_70;
        let x_71 : obj := proj[1] x_64;
        inc x_71;
        let x_72 : obj := reset[2] x_64;
        let x_73 : obj := reuse x_72 in ctor_1[EStateM.Result.error] x_70 x_71;
        ret x_73
    EStateM.Result.error →
      dec x_55;
      dec x_52;
      dec x_49;
      dec x_46;
      dec x_45;
      dec x_44;
      dec x_43;
      dec x_42;
      dec x_5;
      dec x_4;
      dec x_3;
      dec x_2;
      let x_74 : obj := proj[0] x_57;
      inc x_74;
      let x_75 : obj := proj[1] x_57;
      inc x_75;
      let x_76 : obj := reset[2] x_57;
      let x_77 : obj := reuse x_76 in ctor_1[EStateM.Result.error] x_74 x_75;
      ret x_77